<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HomeRoom</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500;700&family=VT323&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      overflow: hidden;
    }

    /* Ensure consistent emoji rendering across all systems */
    .emoji {
      font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', sans-serif;
    }

    .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
      background: transparent;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    /* Wobble animation for dock edit mode */
    @keyframes wobble {
      0% {
        transform: rotate(0deg);
      }

      25% {
        transform: rotate(-2deg);
      }

      75% {
        transform: rotate(2deg);
      }

      100% {
        transform: rotate(0deg);
      }
    }

    .animate-wobble {
      animation: wobble 0.3s infinite linear;
    }

    /* Flip Clock Animations */
    @keyframes flip-down {
      0% {
        transform: rotateX(0deg);
      }

      100% {
        transform: rotateX(-180deg);
      }
    }

    .flip-card {
      perspective: 1000px;
    }

    .flip-half {
      backface-visibility: hidden;
      transform-origin: bottom;
    }

    .flip-animate {
      animation: flip-down 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    /* Restore list styles for Notes widget contenteditable area */
    [contenteditable] ul {
      list-style-type: disc;
      padding-left: 1.5rem;
      margin: 0.5rem 0;
    }

    [contenteditable] ol {
      list-style-type: decimal;
      padding-left: 1.5rem;
      margin: 0.5rem 0;
    }

    [contenteditable] li {
      margin: 0.25rem 0;
    }
  </style>
  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Import Map -->
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "react-dom": "https://esm.sh/react-dom@18.2.0",
      "lucide-react": "https://esm.sh/lucide-react@0.292.0"
    }
  }
  </script>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef, useCallback, useLayoutEffect } from 'react';
    import { createRoot } from 'react-dom/client';
    import { createPortal } from 'react-dom';
    import {
      Mic, Eraser, Timer, Shuffle, Users, Type, Armchair,
      Camera, Dices, ChevronDown, ChevronUp, Copy,
      Maximize2, GripHorizontal, Minus, Plus, Pause, Play, RotateCcw,
      Settings, CheckSquare, Square, RefreshCw, GripVertical, Trash2,
      Wand2, CameraOff, FlipHorizontal, X, Bold, List, ChevronLeft, ChevronRight,
      Save, AlertCircle, AlertTriangle, Share2, Edit3, Layout, User, MoreVertical, MoreHorizontal, Briefcase,
      RotateCw, Lock, Unlock, Grip, Palette, Image as ImageIcon, UploadCloud, Grid,
      Sun, Moon, BarChart2, Italic, Underline, AlignLeft, Clock, Smile,
      Volume2, VolumeX, Download, Upload, Check, Info, ExternalLink, Mail, Calendar, Youtube, Lightbulb, MousePointer2, Undo2, Redo2, ArrowRightSquare, QrCode, Bell, StickyNote, PieChart, Hash, ListOrdered, Pencil
    } from 'lucide-react';

    const TimerIcon = Timer;

    // --- CONSTANTS ---
    const DEFAULT_NAMES = [];

    // --- SHARED EDITOR CONSTANTS ---
    const EDITOR_SWATCHES = ['#000000', '#475569', '#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#6366f1', '#a855f7', '#ec4899', '#ffffff'];
    const EDITOR_FONTS = ['Poppins', 'Arial', 'Georgia', 'Impact', 'Caveat', 'Bangers', 'Courier New', 'VT323', 'Oswald'];

    const FloatingFormattingToolbar = ({
      pos,
      formats,
      exec,
      onClose,
      updateData,
      widgetId,
      hasShadow,
      fontScale,
      fontFamily,
      showFontColorMenu,
      setShowFontColorMenu,
      showFontMenu,
      setShowFontMenu
    }) => {
      if (!pos) return null;

      return createPortal(
        <div
          className="fixed z-[10010] bg-white rounded-xl shadow-2xl border border-slate-200 p-1.5 flex items-center gap-1 -translate-x-1/2 animate-in fade-in slide-in-from-bottom-2 duration-200"
          style={{
            top: Math.max(10, pos.top - 55),
            left: Math.max(100, Math.min(window.innerWidth - 100, pos.left)),
            pointerEvents: 'auto'
          }}
          onMouseDown={e => e.preventDefault()}
        >
          <button onClick={() => exec('bold')} className={`p-1.5 rounded transition-all ${formats.bold ? 'bg-indigo-100 text-indigo-600 font-bold' : 'hover:bg-slate-100 text-slate-600'}`} title="Bold"><Bold size={16} /></button>
          <button onClick={() => exec('italic')} className={`p-1.5 rounded transition-all ${formats.italic ? 'bg-indigo-100 text-indigo-600 italic' : 'hover:bg-slate-100 text-slate-600'}`} title="Italic"><Italic size={16} /></button>
          <button onClick={() => exec('underline')} className={`p-1.5 rounded transition-all ${formats.underline ? 'bg-indigo-100 text-indigo-600 underline' : 'hover:bg-slate-100 text-slate-600'}`} title="Underline"><Underline size={16} /></button>

          <div className="w-px h-5 bg-slate-200 mx-1" />

          <div className="relative">
            <button onClick={(e) => { e.stopPropagation(); setShowFontColorMenu(!showFontColorMenu); setShowFontMenu(false); }} className={`p-1.5 rounded transition-all ${showFontColorMenu ? 'bg-indigo-100 text-indigo-600' : 'hover:bg-slate-100 text-slate-600'}`} title="Text Color"><Palette size={16} /></button>
            {showFontColorMenu && (
              <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 bg-white p-2 rounded-xl shadow-xl flex gap-1 z-50 border border-slate-100 animate-in fade-in slide-in-from-bottom-1">
                {EDITOR_SWATCHES.map(s => (
                  <button key={s} onClick={() => { exec('foreColor', s); setShowFontColorMenu(false); }} className="w-5 h-5 rounded-full border border-slate-200 shadow-sm hover:scale-125 transition-transform" style={{ backgroundColor: s }} />
                ))}
              </div>
            )}
          </div>

          <div className="relative">
            <button onClick={(e) => { e.stopPropagation(); setShowFontMenu(!showFontMenu); setShowFontColorMenu(false); }} className={`p-1.5 rounded transition-all ${showFontMenu ? 'bg-indigo-100 text-indigo-600' : 'hover:bg-slate-100 text-slate-600'}`} title="Font Family"><Type size={16} /></button>
            {showFontMenu && (
              <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 bg-white p-2 rounded-xl shadow-xl flex flex-col gap-1 z-50 border border-slate-100 animate-in fade-in slide-in-from-bottom-1 w-36 max-h-48 overflow-y-auto custom-scrollbar">
                {EDITOR_FONTS.map(f => (
                  <button key={f} onClick={() => { updateData(widgetId, { fontFamily: f }); setShowFontMenu(false); }} className={`px-3 py-1.5 text-xs text-left hover:bg-slate-100 rounded-lg font-medium ${fontFamily === f ? 'text-indigo-600 bg-indigo-50' : 'text-slate-700'}`} style={{ fontFamily: f }}>{f}</button>
                ))}
              </div>
            )}
          </div>

          <div className="w-px h-5 bg-slate-200 mx-1" />

          <button onClick={() => updateData(widgetId, { hasShadow: !hasShadow })} className={`p-1.5 rounded transition-all ${hasShadow ? 'bg-indigo-100 text-indigo-600' : 'hover:bg-slate-100 text-slate-600'}`} title="Glow Effect"><Sun size={16} /></button>

          {updateData && fontScale !== undefined && (
            <>
              <button onClick={() => updateData(widgetId, { fontScale: Math.max(0.1, fontScale - 0.1) })} className="p-1.5 rounded hover:bg-slate-100 text-slate-500 transition-all" title="Smaller"><Minus size={16} /></button>
              <button onClick={() => updateData(widgetId, { fontScale: Math.min(10, fontScale + 0.1) })} className="p-1.5 rounded hover:bg-slate-100 text-slate-500 transition-all" title="Larger"><Plus size={16} /></button>
            </>
          )}

          <div className="w-px h-5 bg-slate-200 mx-1" />
          <button onClick={onClose} className="p-1.5 rounded hover:bg-red-50 text-slate-400 hover:text-red-500 transition-all"><X size={16} /></button>
        </div>,
        document.body
      );
    };


    const DESK_COLORS = {
      blue: 'bg-blue-50 border-blue-400',
      red: 'bg-red-50 border-red-400',
      green: 'bg-green-50 border-green-400',
      yellow: 'bg-yellow-50 border-yellow-400'
    };

    const INIT_DOCK_ORDER = ['TIMER', 'RANDOMIZER', 'GROUP_MAKER', 'SEAT_PICKER', 'SCHEDULE', 'TEXT', 'OVERLAY_TEXT', 'TRAFFIC', 'QR', 'WEBCAM', 'DICE', 'VOTE', 'DRAWING', 'YOUTUBE', 'CALENDAR'];
    const TrafficLightIcon = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <rect x="7" y="2" width="10" height="20" rx="4" />
        <circle cx="12" cy="7" r="2" />
        <circle cx="12" cy="12" r="2" />
        <circle cx="12" cy="17" r="2" />
      </svg>
    );

    const DOCK_LABELS = {
      TIMER: { label: 'Timers', icon: <TimerIcon /> },
      CLOCK: { label: 'Clock', icon: <Clock /> },
      RANDOMIZER: { label: 'Random', icon: <Shuffle /> },
      GROUP_MAKER: { label: 'Groups', icon: <Users /> },
      SEAT_PICKER: { label: 'Seats', icon: <Armchair /> },
      TEXT: { label: 'Notes', icon: <StickyNote /> },
      OVERLAY_TEXT: { label: 'Text', icon: <Type /> },
      TRAFFIC: { label: 'Noise', icon: <TrafficLightIcon /> },
      QR: { label: 'QR Code', icon: <Share2 /> },
      WEBCAM: { label: 'Cam', icon: <Camera /> },
      DICE: { label: 'Dice', icon: <Dices /> },
      VOTE: { label: 'Poll', icon: <BarChart2 /> },
      DRAWING: { label: 'Drawing', icon: <Pencil /> },
      SCHEDULE: { label: 'Schedule', icon: <Calendar /> },
      YOUTUBE: { label: 'Embed', icon: <Youtube /> },
      CALENDAR: { label: 'Calendar', icon: <Calendar /> }
    };

    const WindowIcon = ({ size = 16 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2" />
        <line x1="12" y1="3" x2="12" y2="21" />
        <line x1="3" y1="12" x2="21" y2="12" />
      </svg>
    );

    // --- BACKGROUND PRESETS (UPDATED) ---
    const BACKGROUNDS = [
      { id: 'default', name: 'Original', type: 'preset', preview: 'bg-gradient-to-br from-blue-200 to-orange-200', style: {}, textColor: 'text-slate-800' },
      { id: 'forest', name: 'Forest', type: 'image', src: 'https://images.unsplash.com/photo-1622572860925-daa5e4219d53?q=80&w=1674&auto=format&fit=crop', textColor: 'text-white' },
      { id: 'ocean', name: 'Ocean', type: 'image', src: 'https://images.unsplash.com/photo-1439405326854-014607f694d7?auto=format&fit=crop&w=1920&q=80', textColor: 'text-white' },
      { id: 'sunset', name: 'Sunset', type: 'image', src: 'https://images.unsplash.com/photo-1503803548695-c2a7b4a5b875?q=80&w=1770&auto=format&fit=crop', textColor: 'text-white' },
      { id: 'galaxy', name: 'Galaxy', type: 'image', src: 'https://images.unsplash.com/photo-1464802686167-b939a6910659?q=80&w=1750&auto=format&fit=crop', textColor: 'text-white' },
      { id: 'puppy', name: 'Puppy', type: 'image', src: 'https://images.unsplash.com/photo-1591160690555-5debfba289f0?auto=format&fit=crop&w=1920&q=80', textColor: 'text-white' },
      { id: 'kitten', name: 'Kitten', type: 'image', src: 'https://images.unsplash.com/photo-1595433707802-6b2626ef1c91?auto=format&fit=crop&w=1920&q=80', textColor: 'text-white' },
      { id: 'aurora', name: 'Aurora', type: 'image', src: 'https://images.unsplash.com/photo-1531366936337-7c912a4589a7?auto=format&fit=crop&w=1920&q=80', textColor: 'text-white' },
    ];

    const CLOCK_STYLES = [
      { id: 'standard', name: 'Standard', preview: '12:00' },
      { id: 'analog', name: 'Analog', preview: 'ðŸ•’' },
      { id: 'modern-analog', name: 'Modern Analog', preview: 'âŒš' },
      { id: 'bighour', name: 'Big Hour', preview: '12 00' },
      { id: 'modern', name: 'Modern Digital', preview: '12:00' },
      { id: 'retro', name: 'RETRO', preview: 'ðŸ—“ï¸' }
    ];

    // --- STORAGE SERVICE ---
    const ROSTER_STORAGE_KEY = 'homeroom_roster_v2';
    const DOCK_ORDER_KEY = 'homeroom_dock_order';
    const BG_STORAGE_KEY = 'homeroom_background';
    const WIDGETS_STORAGE_KEY = 'homeroom_widgets';

    const getRoster = () => {
      try {
        const stored = JSON.parse(localStorage.getItem(ROSTER_STORAGE_KEY));
        if (!stored) return DEFAULT_NAMES.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true }));
        // Migration: If array of strings, convert to objects
        if (Array.isArray(stored) && stored.length > 0 && typeof stored[0] === 'string') {
          return stored.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true }));
        }
        return stored;
      } catch (e) { return DEFAULT_NAMES.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true })); }
    };
    const saveRoster = (roster) => { try { localStorage.setItem(ROSTER_STORAGE_KEY, JSON.stringify(roster)); } catch (e) { } };
    const hasRoster = () => !!localStorage.getItem(ROSTER_STORAGE_KEY);

    const getDockOrder = () => {
      try {
        const saved = JSON.parse(localStorage.getItem(DOCK_ORDER_KEY));
        if (!saved) return INIT_DOCK_ORDER;
        // Merge in any new widgets that might have been added
        const allSavedWidgets = [...(saved.main || []), ...(saved.drawer || [])];
        const missingWidgets = INIT_DOCK_ORDER.filter(w => !allSavedWidgets.includes(w));
        if (missingWidgets.length > 0) {
          return { main: [...(saved.main || []), ...missingWidgets], drawer: saved.drawer || [] };
        }
        return saved;
      } catch (e) { return INIT_DOCK_ORDER; }
    };
    const saveDockOrder = (order) => { try { localStorage.setItem(DOCK_ORDER_KEY, JSON.stringify(order)); } catch (e) { } };

    const getBackground = () => { try { return JSON.parse(localStorage.getItem(BG_STORAGE_KEY)) || BACKGROUNDS[0]; } catch (e) { return BACKGROUNDS[0]; } };
    const saveBackground = (bg) => { try { localStorage.setItem(BG_STORAGE_KEY, JSON.stringify(bg)); } catch (e) { } };

    // Seat Layout Persistence (survives widget close/reopen)
    const SEAT_LAYOUT_KEY = 'homeroom_seat_layout';
    const getSeatLayout = () => { try { return JSON.parse(localStorage.getItem(SEAT_LAYOUT_KEY)); } catch (e) { return null; } };
    const saveSeatLayout = (desks) => { try { localStorage.setItem(SEAT_LAYOUT_KEY, JSON.stringify(desks)); } catch (e) { } };

    // Schedule Persistence
    const SCHEDULE_STORAGE_KEY = 'homeroom_schedule';
    const DAYS_OF_WEEK = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const getDefaultScheduleTemplate = () => ({ Monday: [], Tuesday: [], Wednesday: [], Thursday: [], Friday: [] });
    const getScheduleTemplate = () => { try { return JSON.parse(localStorage.getItem(SCHEDULE_STORAGE_KEY)) || getDefaultScheduleTemplate(); } catch (e) { return getDefaultScheduleTemplate(); } };
    const saveScheduleTemplate = (schedule) => { try { localStorage.setItem(SCHEDULE_STORAGE_KEY, JSON.stringify(schedule)); } catch (e) { } };

    const getInitialStudents = () => {
      const stored = getRoster();
      // stored is guaranteed to be objects now due to getRoster migration
      return stored;
    };

    const WIDGET_SIZES = {

      TIMER: { width: 280, height: 340 },
      CLOCK: { width: 500, height: 220 },
      RANDOMIZER: { width: 250, height: 250 },
      GROUP_MAKER: { width: 900, height: 550 },
      SEAT_PICKER: { width: 900, height: 530 },
      TEXT: { width: 340, height: 260 },
      WEBCAM: { width: 320, height: 240 },
      DICE: { width: 300, height: 320 },
      TRAFFIC: { width: 220, height: 360 },
      QR: { width: 250, height: 280 },
      VOTE: { width: 400, height: 350 },
      DRAWING: { width: 600, height: 450 },

      SCHEDULE: { width: 380, height: 500 },
      YOUTUBE: { width: 480, height: 360 },
      CALENDAR: { width: 300, height: 320 },
      OVERLAY_TEXT: { width: 300, height: 80 }
    };

    // --- COMPONENTS ---
    const ClockPreview = ({ style }) => {
      const getRotation = (val, max) => (val / max) * 360;
      // Static time 10:10
      const hours = 10, minutes = 10, seconds = 30;

      if (style === 'analog') return (
        <div className="relative w-full aspect-square rounded-full border-2 border-slate-300 bg-slate-50 flex items-center justify-center overflow-hidden">
          {[...Array(12)].map((_, i) => (
            <div key={i} className="absolute w-[1px] h-[10%] bg-slate-400 left-1/2 top-0 origin-bottom" style={{ transformOrigin: '50% 500%', transform: `rotate(${i * 30}deg)` }} />
          ))}
          <div className="absolute w-[1.5px] h-[30%] bg-slate-800 rounded-full origin-bottom left-1/2 bottom-1/2 -translate-x-1/2" style={{ transform: `rotate(${getRotation(hours % 12 + minutes / 60, 12)}deg)` }} />
          <div className="absolute w-[1px] h-[40%] bg-slate-600 rounded-full origin-bottom left-1/2 bottom-1/2 -translate-x-1/2" style={{ transform: `rotate(${getRotation(minutes, 60)}deg)` }} />
          <div className="w-1 h-1 bg-slate-800 rounded-full z-10" />
        </div>
      );

      if (style === 'modern-analog') return (
        <div className="relative w-full aspect-square rounded-[22%] bg-slate-50 flex items-center justify-center border border-slate-200 shadow-sm overflow-hidden scale-90">
          {[...Array(12)].map((_, i) => (
            <div key={i} className="absolute w-[0.8px] h-1 bg-slate-300 rounded-full left-1/2 top-1/2 -ml-[0.4px] -mt-[0.5px]" style={{ transform: `rotate(${i * 30}deg) translateY(-14px)` }} />
          ))}
          <div className="absolute w-[1.5px] h-3 bg-slate-800 rounded-full origin-bottom left-1/2 top-1/2 -ml-[0.75px] -mt-[3px]" style={{ transform: `translateY(-3px) rotate(${getRotation(hours % 12 + minutes / 60, 12)}deg)` }} />
          <div className="absolute w-[1px] h-5 bg-slate-600 rounded-full origin-bottom left-1/2 top-1/2 -ml-[0.5px] -mt-[5px]" style={{ transform: `translateY(-5px) rotate(${getRotation(minutes, 60)}deg)` }} />
          <div className="absolute w-[0.5px] h-6 bg-red-400 rounded-full origin-bottom left-1/2 top-1/2 -ml-[0.25px] -mt-[6px]" style={{ transform: `translateY(-6px) rotate(${getRotation(seconds, 60)}deg)` }} />
          <div className="w-1.5 h-1.5 bg-white border border-red-500 rounded-full z-10" />
        </div>
      );

      if (style === 'bighour') return (
        <div className="flex items-center justify-center gap-0.5" style={{ transform: 'scale(0.8)' }}>
          <div className="text-lg font-black text-slate-800 leading-none">10</div>
          <div className="flex flex-col justify-start h-full pt-0.5">
            <div className="text-[8px] font-bold text-slate-500 leading-none">10</div>
            <div className="text-[6px] font-bold text-slate-300 leading-none">30</div>
          </div>
        </div>
      );

      if (style === 'modern') return (
        <div className="flex flex-col items-center justify-center">
          <div className="text-xl font-thin tracking-widest text-slate-800 leading-none tabular-nums">10:10</div>
          <div className="text-[6px] font-medium tracking-wide uppercase text-slate-400 mt-0.5">OCT 23</div>
        </div>
      );

      if (style === 'retro') return (
        <div className="bg-[#0a0a0a] rounded-md p-2 flex flex-col items-center justify-center border border-[#1a1a1a] relative overflow-hidden w-full aspect-video shadow-inner">
          <div className="absolute inset-0 bg-[linear-gradient(rgba(56,255,56,0.05)_50%,transparent_50%)] bg-[length:100%_2px] pointer-events-none" />
          <div className="text-[#38ff38] font-['VT323'] text-xl leading-none tracking-widest" style={{ textShadow: '0 0 5px rgba(56, 255, 56, 0.5)' }}>10:10</div>
          <div className="text-[#38ff38] font-['VT323'] text-[6px] opacity-70 tracking-widest uppercase mt-1">October 23</div>
        </div>
      );

      // Standard
      return (
        <div className="text-xl font-bold text-slate-800 tracking-tight">10:10</div>
      );
    };

    const ClockDisplay = ({ style, textColor, onSettingsClick, showDate = true }) => {
      const [time, setTime] = useState(new Date());

      useEffect(() => {
        const timer = setInterval(() => setTime(new Date()), 1000);
        return () => clearInterval(timer);
      }, []);

      const hours = time.getHours();
      const minutes = time.getMinutes();
      const seconds = time.getSeconds();
      const displayHours = hours % 12 || 12;
      const ampm = hours >= 12 ? 'PM' : 'AM';
      const timeString = time.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      const dateString = time.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

      const getRotation = (val, max) => (val / max) * 360;

      if (style === 'none') return null;

      const renderAnalog = () => (
        <div className={`flex flex-col items-center justify-center gap-2`}>
          <div className={`relative w-48 h-48 rounded-full border-4 backdrop-blur-md shadow-lg flex items-center justify-center ${textColor === 'text-white' ? 'border-white/50 bg-white/10' : 'border-slate-800/20 bg-white/60'}`}>
            {/* Ticks */}
            {[...Array(12)].map((_, i) => (
              <div
                key={i}
                className={`absolute w-1 h-3 ${textColor === 'text-white' ? 'bg-white/60' : 'bg-slate-800/60'}`}
                style={{
                  transform: `rotate(${i * 30}deg) translateY(-85px)`,
                }}
              />
            ))}
            {/* Hour Hand */}
            <div className={`absolute w-1.5 h-12 rounded-full origin-bottom left-1/2 bottom-1/2 -ml-[3px] ${textColor === 'text-white' ? 'bg-white' : 'bg-slate-800'}`} style={{ transform: `rotate(${getRotation(hours % 12 + minutes / 60, 12)}deg)` }} />
            {/* Minute Hand */}
            <div className={`absolute w-1 h-16 rounded-full origin-bottom left-1/2 bottom-1/2 -ml-[2px] ${textColor === 'text-white' ? 'bg-white/80' : 'bg-slate-800/80'}`} style={{ transform: `rotate(${getRotation(minutes, 60)}deg)` }} />
            {/* Second Hand */}
            <div className="absolute w-0.5 h-16 bg-red-400 rounded-full origin-bottom left-1/2 bottom-1/2 -ml-[1px]" style={{ transform: `rotate(${getRotation(seconds, 60)}deg)` }} />
            {/* Center Dot */}
            <div className={`absolute w-3 h-3 rounded-full z-10 shadow-sm ${textColor === 'text-white' ? 'bg-white' : 'bg-slate-800'}`} />
          </div>
          {/* Date below analog clock */}
          {showDate && <div className={`text-lg font-medium opacity-90 whitespace-nowrap ${textColor} drop-shadow-md text-center`}>{dateString}</div>}
        </div>
      );

      const renderBigHour = () => (
        <div className="flex items-center justify-center gap-4">
          <div className={`text-[12rem] font-black tracking-tighter ${textColor} opacity-90 drop-shadow-lg leading-none`}>{displayHours}</div>
          <div className="flex flex-col items-start justify-center gap-0">
            <div className={`text-[5rem] font-bold tracking-tight ${textColor} opacity-80 drop-shadow-md leading-none`}>{minutes.toString().padStart(2, '0')}</div>
            <div className={`text-[3rem] font-medium opacity-70 ${textColor} drop-shadow-md leading-none`}>{seconds.toString().padStart(2, '0')}</div>
          </div>
        </div>
      );

      const renderModern = () => (
        <div className="flex flex-col items-center gap-0">
          <div className={`text-8xl font-thin tracking-widest ${textColor} drop-shadow-sm`} style={{ fontVariantNumeric: 'tabular-nums' }}>{timeString.split(' ')[0]}</div>
          {showDate && <div className={`text-xl font-light tracking-wide uppercase opacity-80 ${textColor}`}>{dateString}</div>}
        </div>
      );

      const FlipUnit = ({ value, label }) => {
        const [current, setCurrent] = useState(value);
        const [next, setNext] = useState(value);
        const [isAnimating, setIsAnimating] = useState(false);

        useEffect(() => {
          if (value !== next) {
            setNext(value);
            setIsAnimating(true);
            const timer = setTimeout(() => {
              setCurrent(value);
              setIsAnimating(false);
            }, 600); // match animation duration
            return () => clearTimeout(timer);
          }
        }, [value, next]);

        // THE PERFECT SPLIT: Center numerals exactly at the fold
        const renderHalf = (val, part) => (
          <div className={`absolute inset-x-0 ${part === 'top' ? 'top-0 h-1/2 border-b border-black/50' : 'bottom-0 h-1/2'} overflow-hidden`}>
            <div className="absolute left-0 right-0 text-center font-black tabular-nums text-white/95 tracking-tighter"
              style={{
                fontSize: '19rem',
                lineHeight: '0.75',
                top: part === 'top' ? '100%' : '0%',
                transform: 'translateY(-50%)',
                textShadow: '0 4px 12px rgba(0,0,0,0.8)'
              }}>
              {val}
            </div>
          </div>
        );

        return (
          <div className="relative bg-[#1a1a1a] rounded-2xl w-52 h-64 flex flex-col shadow-2xl border-[3px] border-black/40 ring-1 ring-white/10 flip-card" style={{ perspective: '1000px' }}>
            {/* Base: Bottom Half */}
            <div className="absolute inset-x-0 bottom-0 h-1/2 bg-gradient-to-b from-[#181818] to-[#0a0a0a] rounded-b-xl overflow-hidden">
              {renderHalf(next, 'bottom')}
            </div>

            {/* Base: Top Half */}
            <div className="absolute inset-x-0 top-0 h-1/2 bg-gradient-to-b from-[#333] to-[#1e1e1e] z-10 rounded-t-xl overflow-hidden">
              {renderHalf(current, 'top')}
            </div>

            {/* Animated Leaf */}
            {isAnimating && (
              <div className="absolute inset-x-0 top-0 h-1/2 bg-gradient-to-b from-[#333] to-[#1e1e1e] z-20 origin-bottom flip-animate rounded-t-xl overflow-hidden">
                {renderHalf(current, 'top')}
                <div className="absolute inset-0 bg-black/30 animate-in fade-in duration-[600ms]" />
              </div>
            )}

            <div className="absolute top-1/2 left-0 right-0 h-[3px] bg-black shadow-2xl z-30" />
          </div>
        );
      };

      const renderRetro = () => (
        <div className="flex flex-col items-center justify-center p-6 bg-[#0a0a0a] rounded-3xl border-[6px] border-[#1a1a1a] shadow-[inset_0_0_30px_rgba(0,0,0,1)] relative overflow-hidden w-full h-full group">
          <div className="absolute inset-0 bg-[linear-gradient(rgba(56,255,56,0.08)_50%,transparent_50%)] bg-[length:100%_4px] pointer-events-none z-10 opacity-40" />
          <div className="text-[#38ff38] font-['VT323'] leading-none tracking-widest flex items-center justify-center gap-2 z-20"
            style={{ textShadow: '0 0 15px rgba(56, 255, 56, 0.7)', fontSize: 'min(24cqw, 45cqh)' }}>
            <div className="tabular-nums">10:10</div>
          </div>
          {showDate && (
            <div className="text-[#38ff38] font-['VT323'] uppercase tracking-[0.2em] opacity-80 z-20 mt-2"
              style={{ textShadow: '0 0 8px rgba(56, 255, 56, 0.5)', fontSize: 'min(6cqw, 12cqh)' }}>
              October 23
            </div>
          )}
        </div>
      );

      const renderModernAnalog = () => (
        <div className="flex flex-col items-center justify-center gap-4 w-full h-full p-6">
          <div className={`relative w-64 h-64 shadow-2xl flex items-center justify-center transition-all duration-500 overflow-hidden ${textColor === 'text-white' ? 'bg-white/20 border border-white/20' : 'bg-white border border-slate-100'}`} style={{ borderRadius: '24%' }}>
            {/* Hour Ticks */}
            {[...Array(12)].map((_, i) => (
              <div key={i} className={`absolute w-1 h-3 rounded-full ${textColor === 'text-white' ? 'bg-white/40' : 'bg-slate-400/30'}`} style={{ transform: `rotate(${i * 30}deg) translateY(-28px)` }} />
            ))}
            {/* Hands */}
            <div className="relative w-full h-full flex items-center justify-center">
              <div className={`absolute w-2 h-16 rounded-full shadow-sm origin-bottom bottom-1/2 -ml-[4px] ${textColor === 'text-white' ? 'bg-white' : 'bg-slate-800'}`} style={{ transform: `rotate(${getRotation(hours % 12 + minutes / 60, 12)}deg) translateY(-8px)` }} />
              <div className="absolute w-1.5 h-20 bg-blue-400 rounded-full shadow-sm origin-bottom bottom-1/2 -ml-[3px] opacity-90" style={{ transform: `rotate(${getRotation(minutes, 60)}deg) translateY(-10px)` }} />
              <div className="absolute w-[0.8px] h-22 bg-red-400 rounded-full shadow-sm origin-bottom bottom-1/2 -ml-[0.4px]" style={{ transform: `rotate(${getRotation(seconds, 60)}deg) translateY(-11px)` }} />
              <div className={`absolute w-3.5 h-3.5 rounded-full z-10 shadow-md border-2 border-red-500 ${textColor === 'text-white' ? 'bg-white' : 'bg-slate-800'}`} />
            </div>
          </div>
          {showDate && <div className={`text-sm font-bold uppercase tracking-[0.3em] opacity-80 text-center ${textColor}`}>{dateString}</div>}
        </div>
      );

      const renderStandard = () => (
        <>
          <div className="flex items-center gap-1.5 mb-1 opacity-80">
            <div className={`px-1.5 py-0.5 rounded text-[10px] font-black tracking-tighter shadow-md ${textColor === 'text-white' ? 'bg-white text-slate-900' : 'bg-slate-800 text-white'}`}>HR</div>
            <div className="text-xs font-bold uppercase tracking-widest">HomeRoom</div>
          </div>
          <div className={`text-8xl font-bold tracking-tight ${textColor === 'text-white' ? 'drop-shadow-lg' : 'drop-shadow-sm'}`}>{timeString}</div>
          {showDate && <div className={`text-3xl font-medium mt-2 opacity-90 ${textColor === 'text-white' ? 'drop-shadow-md' : ''}`}>{dateString}</div>}
        </>
      );

      if (style === 'none') return null;

      return (
        <div onClick={onSettingsClick} className="cursor-pointer transition-transform active:scale-95 flex flex-col items-start gap-1">
          {style === 'analog' && renderAnalog()}
          {style === 'modern-analog' && renderModernAnalog()}
          {style === 'bighour' && renderBigHour()}
          {style === 'modern' && renderModern()}
          {style === 'retro' && renderRetro()}
          {style === 'standard' && renderStandard()}
        </div>
      );
    };

    // Custom Time Picker (Items 9 & 10)
    const TimePicker = ({ time, onChange, onClose, triggerRef }) => {
      const [hours, minutes] = time.split(':').map(Number);
      const isPM = hours >= 12;
      const displayHours = hours % 12 || 12;
      const [manualInput, setManualInput] = useState("");
      const [position, setPosition] = useState(null);

      useLayoutEffect(() => {
        if (triggerRef && triggerRef.current) {
          const rect = triggerRef.current.getBoundingClientRect();
          // Logic to keep onscreen
          const top = rect.bottom + 5;
          const left = Math.max(10, Math.min(window.innerWidth - 300, rect.left));
          setPosition({ top, left });
        }
      }, [triggerRef]);

      const handleHourChange = (h) => {
        let newH = h;
        if (isPM && h !== 12) newH += 12;
        if (!isPM && h === 12) newH = 0;
        onChange(`${newH.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`);
      };

      const handleMinuteChange = (m) => {
        onChange(`${hours.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`);
      };

      const toggleAMPM = () => {
        const newH = (hours + 12) % 24;
        onChange(`${newH.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`);
      };

      const handleManualSubmit = () => {
        if (!manualInput) return;
        const [hStr, mStr] = manualInput.split(':');
        let h = parseInt(hStr);
        let m = parseInt(mStr) || 0;
        const isPMInput = manualInput.toLowerCase().includes('p');
        const isAMInput = manualInput.toLowerCase().includes('a');
        if (isNaN(h)) return;
        if (isPMInput && h < 12) h += 12;
        if (isAMInput && h === 12) h = 0;
        h = Math.max(0, Math.min(23, h));
        m = Math.max(0, Math.min(59, m));
        onChange(`${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`);
        setManualInput("");
      };

      // Close on click outside
      useEffect(() => {
        const handleOutsideClick = (e) => {
          // If click is NOT in Portal div
          if (e.target.closest('.time-picker-portal')) return;
          // If click is on trigger, handle it? No, parent handles that.
          // Just close if clicking elsewhere
          onClose();
        };
        setTimeout(() => window.addEventListener('click', handleOutsideClick), 10);
        return () => window.removeEventListener('click', handleOutsideClick);
      }, [onClose]);

      if (!position) return null;

      return createPortal(
        <div
          className="fixed bg-white border border-gray-200 rounded-xl shadow-2xl z-[99999] p-3 flex flex-col gap-2 animate-in fade-in zoom-in-95 time-picker-portal"
          style={{ top: position.top, left: position.left }}
          onClick={(e) => e.stopPropagation()}
        >
          {/* Manual Input */}
          <div className="flex gap-1 border-b border-gray-100 pb-2 mb-1">
            <input
              className="w-16 bg-gray-50 border rounded px-1 py-0.5 text-xs font-bold text-center outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="9:30"
              value={manualInput}
              onChange={(e) => setManualInput(e.target.value)}
              onKeyDown={(e) => { if (e.key === 'Enter') { handleManualSubmit(); onClose(); } }}
              autoFocus
            />
            <button onClick={() => { handleManualSubmit(); onClose(); }} className="px-2 py-0.5 bg-blue-100 text-blue-600 rounded text-[10px] font-bold hover:bg-blue-200">OK</button>
          </div>

          <div className="flex gap-3">
            <div className="h-32 overflow-y-auto custom-scrollbar w-12 text-center">
              {Array.from({ length: 12 }, (_, i) => i + 1).map(h => (
                <div key={h} onClick={() => handleHourChange(h)} className={`p-1 text-sm font-bold rounded cursor-pointer hover:bg-indigo-50 ${displayHours === h ? 'bg-indigo-100 text-indigo-600' : 'text-gray-600'}`}>
                  {h}
                </div>
              ))}
            </div>

            <div className="h-32 overflow-y-auto custom-scrollbar w-12 text-center border-l border-gray-100 pl-1">
              {Array.from({ length: 12 }, (_, i) => i * 5).map(m => (
                <div key={m} onClick={() => handleMinuteChange(m)} className={`p-1 text-sm font-bold rounded cursor-pointer hover:bg-indigo-50 ${minutes === m ? 'bg-indigo-100 text-indigo-600' : 'text-gray-600'}`}>
                  {m.toString().padStart(2, '0')}
                </div>
              ))}
            </div>

            <div className="flex flex-col gap-1 justify-center border-l border-gray-100 pl-2">
              <button onClick={() => !isPM && toggleAMPM()} className={`px-2 py-1 text-xs font-bold rounded ${!isPM ? 'bg-orange-100 text-orange-600' : 'text-gray-400 hover:bg-gray-50'}`}>AM</button>
              <button onClick={() => isPM && toggleAMPM()} className={`px-2 py-1 text-xs font-bold rounded ${isPM ? 'bg-blue-100 text-blue-600' : 'text-gray-400 hover:bg-gray-50'}`}>PM</button>
              <div className="h-px bg-gray-200 my-1" />
              <button onClick={onClose} className="px-2 py-1 text-xs font-bold text-green-600 hover:bg-green-50 rounded">Done</button>
            </div>
          </div>
        </div>,
        document.body
      );
    };

    // SeatPickerWidget rewritten for Multi-Select and Random Empty Seats
    const SeatPickerWidget = ({ widget, updateData, roster, onUpdateRoster }) => {
      const { desks = [], isEditing = false, snapToGrid = 0, fontSize = 16 } = widget.data;
      const containerRef = useRef(null);

      const [draggedDesk, setDraggedDesk] = useState(null);
      const [rotatingDesk, setRotatingDesk] = useState(null);
      const [selectedDeskIds, setSelectedDeskIds] = useState([]); // Array for multi-select

      // Selection Box State
      const [isSelecting, setIsSelecting] = useState(false);
      const [selectionBox, setSelectionBox] = useState(null); // { x, y, w, h } relative to container

      const dragStartMouse = useRef({ x: 0, y: 0 });
      const initialDeskPositions = useRef({});

      // Roster Sync
      useEffect(() => {
        const allStudentNames = roster.map(s => s.name);
        let currentDesks = Array.isArray(desks) ? [...desks] : [];
        let needsUpdate = false;

        // Ensure students are seated or new desks created
        const seated = currentDesks.map(d => d.student).filter(Boolean);
        const unseated = allStudentNames.filter(name => !seated.includes(name));

        if (unseated.length > 0) {
          needsUpdate = true;
          // Fill empty spots first
          currentDesks = currentDesks.map(d => {
            if (d.type !== "teacher" && !d.student && unseated.length > 0) { return { ...d, student: unseated.shift() }; }
            return d;
          });
          // Create new desks for remaining
          for (var i = 0; i < unseated.length; i++) {
            currentDesks.push({ id: Date.now() + Math.random(), x: 50 + (i % 5) * 110, y: 50 + Math.floor(i / 5) * 80 + 100, student: unseated[i], color: "blue", type: "student", rotation: 0 });
          }
        }
        if (needsUpdate) updateData(widget.id, { desks: currentDesks });
      }, [roster, widget.id]);

      const toggleAbsence = (studentName, e) => { if (e) { e.preventDefault(); e.stopPropagation(); } if (!studentName || !onUpdateRoster) return; const updated = roster.map(s => s.name === studentName ? { ...s, active: !s.active } : s); onUpdateRoster(updated); };

      const handleMouseDown = (e, deskId) => {
        if (!isEditing) return;
        e.stopPropagation();

        let newSelection = [...selectedDeskIds];
        if (e.ctrlKey || e.metaKey) {
          if (newSelection.includes(deskId)) newSelection = newSelection.filter(id => id !== deskId);
          else newSelection.push(deskId);
        } else {
          if (!newSelection.includes(deskId)) newSelection = [deskId];
        }

        setSelectedDeskIds(newSelection);
        setDraggedDesk(deskId);

        // Capture initial state for drag
        dragStartMouse.current = { x: e.clientX, y: e.clientY };
        const initialPos = {};
        desks.forEach(d => { initialPos[d.id] = { x: d.x, y: d.y }; });
        initialDeskPositions.current = initialPos;
      };

      const handleBgMouseDown = (e) => {
        if (!isEditing) { setSelectedDeskIds([]); return; }
        if (e.target !== containerRef.current) return;
        setSelectedDeskIds([]);
        const rect = containerRef.current.getBoundingClientRect();
        setIsSelecting(true);
        setSelectionBox({ startX: e.nativeEvent.offsetX, startY: e.nativeEvent.offsetY, x: e.nativeEvent.offsetX, y: e.nativeEvent.offsetY, w: 0, h: 0 });
      };

      const handleRotateMouseDown = (e, deskId) => { if (!isEditing) return; e.stopPropagation(); setRotatingDesk(deskId); };

      const handleGlobalMouseMove = (e) => {
        if (isSelecting && selectionBox) {
          const rect = containerRef.current.getBoundingClientRect();
          const currentX = e.clientX - rect.left;
          const currentY = e.clientY - rect.top;
          const x = Math.min(selectionBox.startX, currentX);
          const y = Math.min(selectionBox.startY, currentY);
          const w = Math.abs(currentX - selectionBox.startX);
          const h = Math.abs(currentY - selectionBox.startY);
          setSelectionBox(prev => ({ ...prev, x, y, w, h }));
        }
        else if (draggedDesk && isEditing) {
          e.stopPropagation(); e.preventDefault();
          const totalDx = e.clientX - dragStartMouse.current.x;
          const totalDy = e.clientY - dragStartMouse.current.y;

          // Calculate "Leader" new position (the one we clicked)
          const leaderStart = initialDeskPositions.current[draggedDesk];
          if (!leaderStart) return;

          let rawNewX = leaderStart.x + totalDx;
          let rawNewY = leaderStart.y + totalDy;

          // Snap the leader
          let finalLeaderX = rawNewX;
          let finalLeaderY = rawNewY;

          if (snapToGrid > 0) {
            finalLeaderX = Math.round(rawNewX / snapToGrid) * snapToGrid;
            finalLeaderY = Math.round(rawNewY / snapToGrid) * snapToGrid;
          }

          // Calculate effective delta to apply to all selected items
          const effectiveDx = finalLeaderX - leaderStart.x;
          const effectiveDy = finalLeaderY - leaderStart.y;

          updateData(widget.id, {
            desks: desks.map(d => {
              if (selectedDeskIds.includes(d.id)) {
                const start = initialDeskPositions.current[d.id];
                if (!start) return d;
                return { ...d, x: start.x + effectiveDx, y: start.y + effectiveDy };
              }
              return d;
            })
          });
        }
        else if (rotatingDesk && isEditing) {
          e.preventDefault();
          const desk = desks.find(d => d.id === rotatingDesk);
          if (desk && containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            const deskCenterX = rect.left + desk.x + (desk.type === "teacher" ? 80 : 56);
            const deskCenterY = rect.top + desk.y + (desk.type === "teacher" ? 40 : 32);
            let angle = Math.atan2(e.clientY - deskCenterY, e.clientX - deskCenterX) * (180 / Math.PI);
            if (snapToGrid > 0) angle = Math.round(angle / 15) * 15;
            updateData(widget.id, { desks: desks.map(d => { if (d.id === rotatingDesk) return { ...d, rotation: angle + 45 }; return d; }) });
          }
        }
      };

      const handleGlobalMouseUp = () => {
        if (isSelecting && selectionBox) {
          // Commit selection
          const { x, y, w, h } = selectionBox;
          const selected = desks.filter(d => {
            // Simple center point collision
            const cx = d.x + (d.type === 'teacher' ? 40 : 28);
            const cy = d.y + (d.type === 'teacher' ? 20 : 16);
            return cx >= x && cx <= x + w && cy >= y && cy <= y + h;
          }).map(d => d.id);
          setSelectedDeskIds(selected);
          setIsSelecting(false);
          setSelectionBox(null);
        }
        setDraggedDesk(null);
        setRotatingDesk(null);
        setIsSelecting(false); // Cleanup just in case
      };

      useEffect(() => {
        if (isEditing) {
          window.addEventListener("mousemove", handleGlobalMouseMove);
          window.addEventListener("mouseup", handleGlobalMouseUp);
          return () => {
            window.removeEventListener("mousemove", handleGlobalMouseMove);
            window.removeEventListener("mouseup", handleGlobalMouseUp);
          };
        }
      }, [isEditing, draggedDesk, rotatingDesk, isSelecting, selectionBox, desks, snapToGrid]);

      const handleColorClick = (color) => {
        if (selectedDeskIds.length > 0) {
          updateData(widget.id, { desks: desks.map(d => selectedDeskIds.includes(d.id) ? { ...d, color } : d) });
        } else {
          const newDesk = { id: Date.now().toString(), x: 50, y: 50, student: null, color, type: "student", rotation: 0 };
          updateData(widget.id, { desks: [...desks, newDesk] });
        }
      };

      const addTeacher = () => {
        const newDesk = { id: Date.now().toString(), x: 50, y: 50, student: null, color: "gray", type: "teacher", rotation: 0 };
        updateData(widget.id, { desks: [...desks, newDesk] });
      };

      const removeDesk = (id) => updateData(widget.id, { desks: desks.filter(d => d.id !== id) });
      const removeSelected = () => {
        updateData(widget.id, { desks: desks.filter(d => !selectedDeskIds.includes(d.id)) });
        setSelectedDeskIds([]);
      };

      const shuffleSeats = () => {
        const activeStudentNames = roster.filter(s => s.active).map(s => s.name);
        const inactiveStudentNames = roster.filter(s => !s.active).map(s => s.name);

        if (activeStudentNames.length === 0 && inactiveStudentNames.length === 0) {
          alert("No students in roster!");
          return;
        }

        const studentDesks = desks.filter(d => d.type === 'student');
        if (studentDesks.length === 0) return;

        // Find which desks have "out" students and preserve them
        const desksWithOutStudents = new Set();
        studentDesks.forEach(d => {
          if (d.student && inactiveStudentNames.includes(d.student)) {
            desksWithOutStudents.add(d.id);
          }
        });

        // Get desks available for active students (exclude desks with "out" students)
        const availableDesks = studentDesks.filter(d => !desksWithOutStudents.has(d.id));

        // Create pool of active students + nulls for empty spots
        let pool = [...activeStudentNames];
        while (pool.length < availableDesks.length) pool.push(null);

        // Shuffle the pool (active students AND empty spots)
        pool = pool.sort(() => Math.random() - 0.5);

        let poolIndex = 0;
        const newDesks = desks.map(d => {
          if (d.type !== 'student') return d;
          // Keep "out" students in their current desks
          if (desksWithOutStudents.has(d.id)) return d;
          // Assign shuffled active students to available desks
          if (poolIndex < pool.length) {
            const student = pool[poolIndex++];
            return { ...d, student };
          }
          return { ...d, student: null };
        });

        updateData(widget.id, { desks: newDesks });
      };

      // Student Swap Logic (DnD)
      const handleStudentDragStart = (e, sourceDeskId) => {
        if (isEditing) return; // Use normal DnD for layout in edit mode
        e.dataTransfer.setData('sourceDeskId', sourceDeskId);
        e.dataTransfer.effectAllowed = 'move';
      };

      const handleStudentDrop = (e, targetDeskId) => {
        if (isEditing) return;
        e.preventDefault();
        e.stopPropagation();
        const sourceDeskId = e.dataTransfer.getData('sourceDeskId');
        if (!sourceDeskId || sourceDeskId === targetDeskId) return;

        const newDesks = [...desks];
        const sourceIndex = newDesks.findIndex(d => d.id === sourceDeskId);
        const targetIndex = newDesks.findIndex(d => d.id === targetDeskId);

        if (sourceIndex === -1 || targetIndex === -1) return;

        // Swap students
        const sourceStudent = newDesks[sourceIndex].student;
        const targetStudent = newDesks[targetIndex].student;

        newDesks[sourceIndex] = { ...newDesks[sourceIndex], student: targetStudent };
        newDesks[targetIndex] = { ...newDesks[targetIndex], student: sourceStudent };

        updateData(widget.id, { desks: newDesks });
      };

      return (
        <div className="flex flex-col h-full bg-slate-50 relative overflow-hidden select-none">
          <div className="h-12 bg-white border-b flex items-center justify-between px-4 z-10 shrink-0 select-none">
            <h3 className="font-bold text-slate-700 flex items-center gap-2"><Layout size={18} /> Class Layout</h3>
            <div className="flex gap-2 items-center">
              {isEditing ? (<>
                <div className="flex items-center gap-2 mr-2">
                  <button onClick={(e) => { e.stopPropagation(); updateData(widget.id, { snapToGrid: snapToGrid > 0 ? 0 : 10 }); }} className={`px-2 py-1 rounded text-[10px] font-bold uppercase transition-colors mr-2 ${snapToGrid > 0 ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-400 hover:bg-gray-200'}`}>
                    Snap: {snapToGrid > 0 ? 'On' : 'Off'}
                  </button>
                  <div className="w-px h-6 bg-gray-200" />
                  <div className="flex bg-gray-100 rounded-lg p-0.5">
                    {["blue", "red", "green", "yellow"].map(c => (<button key={c} onClick={(e) => { e.stopPropagation(); handleColorClick(c); }} className={`w-6 h-6 rounded border m-0.5 hover:scale-110 transition-transform ${DESK_COLORS[c].split(" ")[0]} ${DESK_COLORS[c].split(" ")[1]}`} />))}
                    <button onClick={(e) => { e.stopPropagation(); addTeacher(); }} className="px-2 h-6 rounded bg-slate-600 text-[10px] m-0.5 text-white font-bold flex items-center gap-1 hover:scale-105 transition-transform"><Briefcase size={10} /> Teacher</button>
                    {selectedDeskIds.length > 0 && (
                      <>
                        <button onClick={removeSelected} className="px-2 h-6 rounded bg-red-100 text-red-600 text-[10px] m-0.5 font-bold flex items-center gap-1 hover:bg-red-200"><Trash2 size={10} /></button>
                        <button onClick={(e) => { e.stopPropagation(); updateData(widget.id, { desks: desks.map(d => selectedDeskIds.includes(d.id) ? { ...d, rotation: (d.rotation || 0) + 45 } : d) }); }} className="px-2 h-6 rounded bg-blue-100 text-blue-600 text-[10px] m-0.5 font-bold flex items-center gap-1 hover:bg-blue-200" title="Rotate Selected"><RotateCw size={10} /></button>
                      </>
                    )}
                  </div>
                </div>
                <button onClick={(e) => { e.stopPropagation(); updateData(widget.id, { isEditing: false }); setSelectedDeskIds([]); }} className="px-3 py-1 bg-green-600 text-white rounded text-xs font-bold shadow hover:bg-green-700">Done</button>
              </>) : (<>
                <button onClick={shuffleSeats} className="px-3 py-1 bg-indigo-600 text-white rounded text-xs font-bold shadow hover:bg-indigo-700 flex items-center gap-1"><Shuffle size={12} /> Shuffle</button>
                <button onClick={() => updateData(widget.id, { isEditing: true })} className="px-3 py-1 bg-white border border-gray-300 text-gray-600 rounded text-xs font-bold hover:bg-gray-50 flex items-center gap-1"><Edit3 size={12} /> Edit</button>
              </>)}
            </div>
          </div>
          <div ref={containerRef} className={`flex-1 relative overflow-hidden ${isEditing ? "bg-slate-100" : "bg-slate-50"}`} style={{ backgroundImage: isEditing ? "radial-gradient(#cbd5e1 1px, transparent 1px)" : "none", backgroundSize: `${Math.max(20, snapToGrid || 20)}px ${Math.max(20, snapToGrid || 20)}px` }} onMouseDown={handleBgMouseDown}>
            {desks.map(desk => {
              const isAbsent = desk.student && roster.find(s => s.name === desk.student && !s.active);
              const styleClass = desk.type === "teacher" ? "bg-slate-800 border-slate-600 text-white shadow-lg w-28 h-14 rounded-md" : `${DESK_COLORS[desk.color || "blue"]} w-20 h-11 rounded-lg`;
              const isSelected = selectedDeskIds.includes(desk.id);
              return (<div
                key={desk.id}
                draggable={!isEditing && !!desk.student}
                onDragStart={(e) => handleStudentDragStart(e, desk.id)}
                onDragOver={(e) => { if (!isEditing) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; } }}
                onDrop={(e) => handleStudentDrop(e, desk.id)}
                onContextMenu={(e) => toggleAbsence(desk.student, e)}
                className={`absolute shadow-sm border-2 flex items-center justify-center transition-shadow ${isEditing ? "cursor-move hover:shadow-md" : "cursor-pointer"} ${styleClass} ${isAbsent ? "opacity-60" : ""} ${isSelected ? "ring-2 ring-blue-500 ring-offset-2 z-10" : ""}`}
                style={{ left: desk.x, top: desk.y, transform: `rotate(${desk.rotation || 0}deg)`, fontSize: (desk.type === 'teacher' ? 14 : fontSize) + 'px' }}
                onMouseDown={(e) => handleMouseDown(e, desk.id)}
              >
                {isAbsent && <div className="absolute -top-2 -right-2 bg-red-500 text-white text-[8px] font-bold px-1.5 py-0.5 rounded-full z-30 shadow-sm pointer-events-none">OUT</div>}
                {isEditing && (<>
                  <button onClick={(e) => { e.stopPropagation(); removeDesk(desk.id); }} className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-0.5 shadow-sm hover:bg-red-600 w-5 h-5 flex items-center justify-center z-20"><X size={12} strokeWidth={3} /></button>
                  <div onMouseDown={(e) => handleRotateMouseDown(e, desk.id)} className="absolute -top-3 -left-3 bg-blue-500 text-white rounded-full p-1 shadow-sm hover:bg-blue-600 w-6 h-6 flex items-center justify-center z-20 cursor-grab active:cursor-grabbing"><RotateCw size={14} strokeWidth={2.5} /></div>
                </>)}
                {/* Fix text selection on name */}
                {desk.type === "teacher" ? <div className="flex flex-col items-center opacity-80 select-none"><Briefcase size={16} className="mb-0.5" /><span className="text-[8px] uppercase font-bold tracking-widest">Teacher</span></div> : (desk.student ? <span className={`font-bold text-center px-0.5 truncate w-full select-none ${isAbsent ? 'text-slate-400 line-through' : 'text-slate-800'}`} style={{ fontSize: 'inherit' }}>{desk.student}</span> : <span className={`italic text-[10px] select-none ${desk.color === "yellow" ? "text-yellow-700/50" : "text-slate-300"}`}>Empty</span>)}
                {desk.type !== "teacher" && <div className={`absolute -bottom-1 w-8 h-1 rounded-full ${desk.color === "yellow" ? "bg-yellow-200" : "bg-slate-200"}`} />}
              </div>);
            })}

            {/* Selection Box Visual */}
            {isSelecting && selectionBox && (
              <div className="absolute border border-blue-500 bg-blue-500/10 pointer-events-none z-50" style={{ left: selectionBox.x, top: selectionBox.y, width: selectionBox.w, height: selectionBox.h }} />
            )}
          </div>
        </div>);
    };




    const TextWidget = ({ widget, updateData, isGlassy, chromeless }) => {
      const data = widget.data || {};
      const { items = [], content = "", mode = 'text', fontSize = 16, color = 'yellow', textColor = 'inherit', fontFamily = 'Poppins', listTitle = "" } = data;
      const [newItemText, setNewItemText] = useState("");
      const editorRef = useRef(null);
      const [formats, setFormats] = useState({ bold: false, italic: false, underline: false });
      const [toolbarPos, setToolbarPos] = useState(null);
      const [showColorMenu, setShowColorMenu] = useState(false);
      const [showFontColorMenu, setShowFontColorMenu] = useState(false);
      const [showFontMenu, setShowFontMenu] = useState(false);
      const [draggedItemIndex, setDraggedItemIndex] = useState(null);
      const [focusId, setFocusId] = useState(null);

      const updateFormats = useCallback(() => {
        setFormats({
          bold: document.queryCommandState('bold'),
          italic: document.queryCommandState('italic'),
          underline: document.queryCommandState('underline')
        });

        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0 && !selection.isCollapsed && editorRef.current?.contains(selection.anchorNode)) {
          const range = selection.getRangeAt(0);
          const rect = range.getBoundingClientRect();
          setToolbarPos({ top: rect.top, left: rect.left + rect.width / 2 });
        } else {
          setToolbarPos(null);
        }
      }, []);

      const COLORS = {
        yellow: { bg: 'bg-yellow-100', header: 'bg-yellow-100', text: 'text-yellow-900', border: 'border-yellow-300' },
        blue: { bg: 'bg-blue-50', header: 'bg-blue-100', text: 'text-blue-900', border: 'border-blue-300' },
        green: { bg: 'bg-green-50', header: 'bg-green-100', text: 'text-green-900', border: 'border-green-300' },
        pink: { bg: 'bg-pink-50', header: 'bg-pink-100', text: 'text-pink-900', border: 'border-pink-300' },
        purple: { bg: 'bg-purple-50', header: 'bg-purple-100', text: 'text-purple-900', border: 'border-purple-300' }
      };
      const theme = COLORS[color] || COLORS.yellow;

      const exec = (command, value = null) => {
        editorRef.current?.focus();
        document.execCommand(command, false, value);
        updateFormats();
        if (editorRef.current) updateData(widget.id, { content: editorRef.current.innerHTML });
      };

      useEffect(() => {
        if (mode === 'text' && editorRef.current && document.activeElement !== editorRef.current) {
          if (editorRef.current.innerHTML !== (content || '')) {
            editorRef.current.innerHTML = content || '';
          }
        }
      }, [content, mode]);

      const addItem = () => {
        if (!newItemText.trim()) return;
        const newItem = { id: Date.now().toString(), text: newItemText.trim(), completed: false };
        updateData(widget.id, { items: [...items, newItem] });
        setNewItemText("");
      };

      const addItemAtIndex = (index) => {
        const newItem = { id: Date.now().toString(), text: "", completed: false };
        const newItems = [...items];
        newItems.splice(index + 1, 0, newItem);
        updateData(widget.id, { items: newItems });
        setFocusId(newItem.id);
      };

      const toggleItem = (id) => updateData(widget.id, { items: items.map(i => i.id === id ? { ...i, completed: !i.completed } : i).sort((a, b) => (a.completed === b.completed ? 0 : a.completed ? 1 : -1)) });
      const deleteItem = (id) => updateData(widget.id, { items: items.filter(i => i.id !== id) });
      const updateItemText = (id, text) => updateData(widget.id, { items: items.map(i => i.id === id ? { ...i, text } : i) });

      const toggleMode = () => {
        if (mode === 'text') {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = content || "";
          const rawText = tempDiv.innerText || "";
          const validLines = rawText.split('\n').map(l => l.trim()).filter(l => l.length > 0);
          const newItems = validLines.map((text, i) => ({ id: Date.now() + i + '', text, completed: false }));
          if (newItems.length === 0) newItems.push({ id: Date.now().toString(), text: '', completed: false });
          // CRITICAL FIX: Clear listTitle when converting from text to list to avoid duplication 
          // (Unless we explicitly want to split the first line as title, but user expects first line as first item)
          updateData(widget.id, { mode: 'list', items: newItems, content: "", listTitle: "" });
        } else {
          // When going list -> text, prepend the title if it exists
          let newContent = items.map(i => `<div>${i.text}</div>`).join('');
          if (listTitle) {
            newContent = `<div><strong>${listTitle}</strong></div>` + newContent;
          }
          updateData(widget.id, { mode: 'text', content: newContent, items: [], listTitle: "" });
        }
      };

      const handleDragStart = (e, index) => { setDraggedItemIndex(index); };
      const handleDragOver = (e, index) => {
        e.preventDefault();
        if (draggedItemIndex === null || draggedItemIndex === index) return;
        const newItems = [...items];
        const item = newItems[draggedItemIndex];
        newItems.splice(draggedItemIndex, 1);
        newItems.splice(index, 0, item);
        setDraggedItemIndex(index);
        updateData(widget.id, { items: newItems });
      };
      const handleDragEnd = () => { setDraggedItemIndex(null); };

      return (
        <div className={`h-full flex flex-col relative group rounded-2xl ${isGlassy && isGlassy !== 'solid' ? 'bg-transparent' : theme.bg} ${(!isGlassy || isGlassy === 'solid') && !chromeless ? 'border' : ''}`} style={{ boxShadow: (!isGlassy || isGlassy === 'solid') ? 'inset 0 0 20px rgba(0,0,0,0.05)' : 'none', fontFamily: 'Poppins, sans-serif' }} onClick={() => { setShowColorMenu(false); setShowFontColorMenu(false); setShowFontMenu(false); }}>
          {(isGlassy === 'solid' || !isGlassy) && (
            <div className={`h-10 flex items-center px-4 shrink-0 relative z-20 justify-between ${theme.header} border-b ${theme.border} bg-opacity-50`}>
              <div className="flex items-center gap-2">
                <button onClick={(e) => { e.stopPropagation(); setShowColorMenu(!showColorMenu); }} className={`w-4 h-4 rounded-full border border-black/10 shadow-sm ${theme.bg.replace('50', '400').replace('100', '400')}`} />
                {showColorMenu && (
                  <div className="absolute top-8 left-2 bg-white p-2 rounded-xl shadow-xl flex gap-1 z-50 border border-gray-100">
                    {Object.keys(COLORS).map(c => (
                      <button key={c} onClick={(e) => { e.stopPropagation(); updateData(widget.id, { color: c }); setShowColorMenu(false); }} className={`w-6 h-6 rounded-full border hover:scale-110 transition-transform ${COLORS[c].bg.replace('50', '500').replace('100', '500')}`} />
                    ))}
                  </div>
                )}
                <span className={`font-bold text-xs uppercase tracking-widest flex items-center gap-2 ${theme.text} opacity-50`}>Note</span>
              </div>
              <div className="flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                <button onClick={toggleMode} className={`p-1.5 hover:bg-black/5 rounded ${theme.text} opacity-70 hover:opacity-100 transition-colors`} title="Switch to List/Text Mode">
                  {mode === 'text' ? <List size={16} /> : <Type size={16} />}
                </button>
              </div>
            </div>
          )}
          <div key={mode} className="flex-1 relative overflow-hidden flex flex-col" onMouseDown={e => { if (isSelected && mode === 'text') e.stopPropagation(); }}>
            {mode === 'text' ? (
              <>
                <div
                  ref={editorRef}
                  className="w-full h-full p-4 outline-none overflow-auto custom-scrollbar leading-relaxed text-lg"
                  contentEditable
                  suppressContentEditableWarning
                  onInput={(e) => updateData(widget.id, { content: e.currentTarget.innerHTML })}
                  onKeyUp={updateFormats}
                  onMouseUp={updateFormats}
                  onMouseDown={(e) => {
                    if (isSelected && document.activeElement === editorRef.current) {
                      e.stopPropagation();
                    }
                    setToolbarPos(null);
                  }}
                  style={{ fontSize: fontSize + 'px', fontFamily: `${fontFamily}, sans-serif`, textShadow: data.hasShadow ? '1px 1px 2px rgba(0,0,0,0.3)' : 'none' }}
                  placeholder="Type a note..."
                />
                <FloatingFormattingToolbar
                  pos={toolbarPos}
                  formats={formats}
                  exec={exec}
                  onClose={() => setToolbarPos(null)}
                  updateData={updateData}
                  widgetId={widget.id}
                  hasShadow={data.hasShadow}
                  fontFamily={fontFamily}
                  showFontColorMenu={showFontColorMenu}
                  setShowFontColorMenu={setShowFontColorMenu}
                  showFontMenu={showFontMenu}
                  setShowFontMenu={setShowFontMenu}
                />
              </>
            ) : (
              <>
                <div className="flex-1 overflow-y-auto custom-scrollbar p-2 pl-4 z-10">
                  <div className="space-y-1">
                    <input
                      className="w-full bg-transparent border-none outline-none font-bold text-slate-700 mb-2 placeholder-slate-400/50 cursor-text relative z-10"
                      style={{ fontSize: (fontSize * 1.1) + 'px' }}
                      value={listTitle || ""}
                      placeholder="Add a title..."
                      onMouseDown={(e) => e.stopPropagation()}
                      onChange={(e) => updateData(widget.id, { listTitle: e.target.value })}
                    />
                    {items.map((item, idx) => (
                      <div key={item.id} draggable onDragStart={(e) => handleDragStart(e, idx)} onDragOver={(e) => handleDragOver(e, idx)} onDragEnd={handleDragEnd} className={`group/item flex items-start gap-2 p-1 rounded hover:bg-black/5 transition-colors ${item.completed ? 'opacity-50' : ''} ${draggedItemIndex === idx ? 'opacity-30' : ''}`}>
                        <div className="mt-1 cursor-grab active:cursor-grabbing text-gray-300 hover:text-gray-500"><GripVertical size={12} /></div>
                        <button onClick={() => toggleItem(item.id)} className={`mt-1 w-4 h-4 rounded border flex items-center justify-center shrink-0 transition-colors ${item.completed ? 'bg-green-500 border-green-500' : 'border-gray-400 bg-white'}`}>
                          {item.completed && <Check size={10} className="text-white" />}
                        </button>
                        <textarea
                          value={item.text}
                          rows={1}
                          onChange={(e) => updateItemText(item.id, e.target.value)}
                          onInput={(e) => {
                            e.target.style.height = 'auto';
                            e.target.style.height = e.target.scrollHeight + 'px';
                          }}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                              e.preventDefault();
                              addItemAtIndex(idx);
                            } else if (e.key === 'Backspace' && !item.text) {
                              e.preventDefault();
                              deleteItem(item.id);
                            }
                          }}
                          onMouseDown={(e) => e.stopPropagation()}
                          className={`flex-1 bg-transparent border-none outline-none text-sm font-medium break-words leading-relaxed pt-0.5 resize-none overflow-hidden ${item.completed ? 'line-through text-gray-500' : 'text-slate-800'}`}
                          style={{ fontSize: fontSize + 'px', height: 'auto' }}
                          autoFocus={item.id === focusId}
                          ref={(el) => {
                            if (el) {
                              el.style.height = 'auto';
                              el.style.height = el.scrollHeight + 'px';
                            }
                          }}
                        />
                        <div className="opacity-0 group-hover/item:opacity-100 flex gap-1">
                          <button onClick={() => deleteItem(item.id)} className="text-gray-300 hover:text-red-500"><X size={14} /></button>
                        </div>
                      </div>
                    ))}
                  </div>

                </div>
              </>
            )}


          </div>
        </div>
      );
    };

    const DiceWidget = ({ widget, updateData }) => {
      const { sides = 6, diceCount = 1, results = [1], isRolling, fontSize = 16 } = widget.data;
      const [showSettings, setShowSettings] = useState(false);
      // Ensure results match diceCount
      const displayResults = (results && results.length === diceCount) ? results : Array(diceCount).fill(1).map((_, i) => (results[i] || 1));

      const roll = () => {
        if (isRolling) return;
        updateData(widget.id, { isRolling: true });
        let count = 0;
        const animate = () => {
          const temp = Array.from({ length: diceCount }, () => Math.floor(Math.random() * sides) + 1);
          updateData(widget.id, { results: temp });
          count++;
          if (count < 10) { setTimeout(animate, 80); }
          else { updateData(widget.id, { isRolling: false }); }
        };
        animate();
      };

      const renderDot = (active) => <div className={`w-2.5 h-2.5 rounded-full ${active ? 'bg-indigo-600' : 'bg-transparent'}`} />; // Slightly smaller dots for 2 dice

      const renderFace = (num) => {
        if (sides !== 6) return <span className="font-black text-indigo-800" style={{ fontSize: (fontSize * 3) + 'px' }}>{num}</span>;

        // D6 Dot Layout
        const positions = {
          1: [4], 2: [0, 8], 3: [0, 4, 8], 4: [0, 2, 6, 8], 5: [0, 2, 4, 6, 8], 6: [0, 2, 3, 5, 6, 8]
        };
        const activeDots = positions[num] || [];
        return (
          <div className="grid grid-cols-3 gap-1 p-2">
            {[0, 1, 2, 3, 4, 5, 6, 7, 8].map(i => renderDot(activeDots.includes(i)))}
          </div>
        );
      };

      if (showSettings) {
        return (
          <div className="h-full bg-white flex flex-col p-4">
            <div className="flex justify-between items-center mb-4"><h3 className="font-bold">Dice Settings</h3><button onClick={() => setShowSettings(false)} className="text-blue-600">Done</button></div>
            <div className="space-y-4">
              <div>
                <label className="text-sm font-bold text-gray-700 block mb-2">Number of Dice</label>
                <div className="flex gap-2">
                  {[1, 2, 3].map(num => (
                    <button
                      key={num}
                      onClick={() => updateData(widget.id, { diceCount: num })}
                      className={`flex-1 py-2 rounded-lg font-bold transition-colors ${diceCount === num ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                    >
                      {num}
                    </button>
                  ))}
                </div>
              </div>
              <div>
                <label className="text-sm font-bold text-gray-700 block mb-2">Sides: {sides}</label>
                <input type="range" min="2" max="20" value={sides} onChange={e => updateData(widget.id, { sides: Number(e.target.value) })} className="w-full accent-indigo-600" />
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="h-full bg-gradient-to-br from-indigo-50 to-white flex flex-col items-center justify-center relative p-4 select-none cursor-pointer group" onClick={roll} style={{ transform: `scale(${fontSize / 16})`, transformOrigin: 'center' }}>
          <button onClick={(e) => { e.stopPropagation(); setShowSettings(true); }} className="absolute top-2 right-2 p-2 text-gray-300 hover:text-indigo-600 rounded-full hover:bg-indigo-50 opacity-0 group-hover:opacity-100 transition-opacity"><Settings size={16} /></button>

          <div className="flex gap-4 items-center justify-center w-full h-full">
            {displayResults.map((val, idx) => (
              <div key={idx} className={`relative shadow-xl border-2 border-indigo-100 flex items-center justify-center transform transition-transform bg-white ${isRolling ? 'rotate-180 scale-105' : ''} ${diceCount === 1 ? 'w-32 h-32 rounded-2xl' : 'w-24 h-24 rounded-xl'}`}>
                {renderFace(val)}
              </div>
            ))}
          </div>

          <div className="text-indigo-400 font-bold text-[10px] uppercase mt-4 tracking-widest absolute bottom-4">{isRolling ? "Rolling..." : `Click to Roll`}</div>
        </div>
      );
    };

    const VoteWidget = ({ widget, updateData }) => {
      const { question = "Class Poll", options = [{ id: 1, text: "Yes", count: 0 }, { id: 2, text: "No", count: 0 }], fontSize = 16 } = widget.data;
      const [isEditing, setIsEditing] = useState(false);

      const vote = (id) => updateData(widget.id, { options: options.map(o => o.id === id ? { ...o, count: o.count + 1 } : o) });
      const totalVotes = options.reduce((acc, o) => acc + o.count, 0) || 1; // avoid /0

      const updateOption = (id, text) => updateData(widget.id, { options: options.map(o => o.id === id ? { ...o, text } : o) });
      const addOption = () => updateData(widget.id, { options: [...options, { id: Date.now(), text: "", count: 0 }] });
      const removeOption = (id) => updateData(widget.id, { options: options.filter(o => o.id !== id) });
      const resetCounts = () => updateData(widget.id, { options: options.map(o => ({ ...o, count: 0 })) });

      if (isEditing) {
        return (
          <div className="h-full bg-white flex flex-col p-4 overflow-hidden">
            <div className="flex justify-between items-center mb-2"><h3 className="font-bold text-sm">Edit Poll</h3><button onClick={() => setIsEditing(false)} className="text-blue-600 font-bold text-xs bg-blue-50 px-2 py-1 rounded">Done</button></div>
            <div className="flex-1 overflow-y-auto custom-scrollbar space-y-2">
              <div className="space-y-1">
                <label className="text-[10px] font-bold uppercase text-gray-400">Question</label>
                <input className="w-full border rounded p-1 text-sm font-bold" value={question} onChange={e => updateData(widget.id, { question: e.target.value })} />
              </div>
              <div className="space-y-1">
                <label className="text-[10px] font-bold uppercase text-gray-400">Options</label>
                {options.map((o, i) => (
                  <div key={o.id} className="flex gap-1 items-center">
                    <input className="flex-1 border rounded p-1 text-sm" value={o.text} onChange={e => updateOption(o.id, e.target.value)} placeholder={`Option ${i + 1}`} />
                    <button onClick={() => removeOption(o.id)} className="text-red-400 hover:text-red-600"><Trash2 size={14} /></button>
                  </div>
                ))}
                <button onClick={addOption} className="text-blue-600 text-xs font-bold hover:underline flex items-center gap-1">+ Add Option</button>
              </div>
            </div>
            <button onClick={resetCounts} className="mt-2 w-full py-2 border border-red-200 text-red-600 rounded text-xs font-bold hover:bg-red-50">Reset Votes</button>
          </div>
        );
      }

      return (
        <div className="h-full bg-white flex flex-col p-4 relative group">
          <button onClick={() => setIsEditing(true)} className="absolute top-2 right-2 p-1 text-gray-300 hover:text-blue-600 rounded hover:bg-blue-50 opacity-0 group-hover:opacity-100 transition-opacity"><Settings size={14} /></button>
          <h3 className="font-bold text-center mb-4 text-gray-800" style={{ fontSize: fontSize + 'px' }}>{question}</h3>
          <div className="flex-1 overflow-y-auto custom-scrollbar space-y-2">
            {options.map(o => {
              const pct = Math.round((o.count / totalVotes) * 100);
              return (
                <div key={o.id} onClick={() => vote(o.id)} className="cursor-pointer group/opt">
                  <div className="flex justify-between mb-1 font-medium text-gray-600" style={{ fontSize: (fontSize - 2) + 'px' }}><span>{o.text || "Option"}</span><span>{o.count} ({options.every(x => x.count === 0) ? 0 : pct}%)</span></div>
                  <div className="h-8 bg-gray-100 rounded-lg overflow-hidden relative">
                    <div className="absolute top-0 left-0 bottom-0 bg-blue-500 transition-all duration-500 ease-out" style={{ width: options.every(x => x.count === 0) ? '0%' : `${pct}%` }} />
                    <div className="absolute inset-0 hover:bg-black/5 transition-colors" />
                  </div>
                </div>
              );
            })}
          </div>
          <div className="mt-2 text-center text-[10px] text-gray-400 uppercase tracking-widest">{options.reduce((a, b) => a + b.count, 0)} Total Votes</div>
        </div>
      );
    };

    const TrafficLightWidget = ({ widget, updateData }) => {
      const { activeLight, isListening = false, sensitivity = 50, threshold = 80, showSettings = false, fontSize = 16 } = widget.data;
      const audioContextRef = useRef(null);
      const analyserRef = useRef(null);
      const dataArrayRef = useRef(null);
      const rafId = useRef(null);

      // Cleanup audio on unmount or when listening stops
      useEffect(() => {
        if (isListening) startAudio();
        else stopAudio();
        return () => stopAudio();
      }, [isListening]);

      // Re-run analysis if sensitivity/threshold changes while listening
      useEffect(() => {
        if (isListening && !rafId.current) analyze();
      }, [sensitivity, threshold]);

      const startAudio = async () => {
        if (audioContextRef.current) return;
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          audioContextRef.current = audioCtx;
          const analyser = audioCtx.createAnalyser();
          analyserRef.current = analyser;
          const source = audioCtx.createMediaStreamSource(stream);
          source.connect(analyser);
          analyser.fftSize = 256;
          const bufferLength = analyser.frequencyBinCount;
          dataArrayRef.current = new Uint8Array(bufferLength);
          analyze();
        } catch (e) {
          console.error('Mic Error: ' + e.message);
          alert('Mic Error: ' + e.message);
          updateData(widget.id, { isListening: false });
        }
      };

      const stopAudio = () => {
        if (rafId.current) cancelAnimationFrame(rafId.current);
        rafId.current = null;
        if (audioContextRef.current) {
          audioContextRef.current.close();
          audioContextRef.current = null;
        }
      };

      const analyze = () => {
        if (!analyserRef.current || !dataArrayRef.current) return;
        analyserRef.current.getByteFrequencyData(dataArrayRef.current);

        let sum = 0;
        const data = dataArrayRef.current;
        for (let i = 0; i < data.length; i++) sum += data[i];
        const avg = sum / data.length;

        // Apply sensitivity (1-100) -> Multiplier (0.5 - 3.0)
        // Sensitivity 50 = 1.0x
        const multiplier = 0.5 + (sensitivity / 50);
        const volume = Math.min(avg * multiplier, 255);

        // Threshold (1-100) -> Cutoff (0-255)
        const limit = (threshold / 100) * 255;

        // Determine Light
        let newLight = 'green';
        if (volume > limit) {
          newLight = 'red';
        } else if (volume > limit * 0.7) {
          newLight = 'yellow';
        }

        // Only update if changed to avoid React render thrashing, but need to be responsive
        // We can just update locally or throttle updates? 
        // For this app, updateData triggers re-render of this widget only usually. 
        // Let's debounce slightly or just check if diff.
        if (newLight !== activeLight) {
          updateData(widget.id, { activeLight: newLight });
        }

        rafId.current = requestAnimationFrame(analyze);
      };

      if (showSettings) {
        return (
          <div className="h-full flex flex-col p-4 bg-white rounded-2xl border border-gray-200 shadow-xl overflow-hidden relative">
            <div className="flex justify-between items-center mb-4 text-gray-700">
              <h3 className="font-bold text-sm uppercase tracking-wider">Settings</h3>
              <button onClick={() => updateData(widget.id, { showSettings: false })} className="text-gray-400 hover:text-gray-700"><X size={18} /></button>
            </div>
            <div className="space-y-4 flex-1">
              <div>
                <label className="text-[10px] font-bold text-gray-400 uppercase block mb-1">Sensitivity ({sensitivity}%)</label>
                <input type="range" min="1" max="100" value={sensitivity} onChange={e => updateData(widget.id, { sensitivity: Number(e.target.value) })} className="w-full accent-blue-500 h-1 bg-gray-200 rounded-lg appearance-none" />
              </div>
              <div>
                <label className="text-[10px] font-bold text-gray-400 uppercase block mb-1">Max Volume ({threshold}%)</label>
                <input type="range" min="1" max="100" value={threshold} onChange={e => updateData(widget.id, { threshold: Number(e.target.value) })} className="w-full accent-red-500 h-1 bg-gray-200 rounded-lg appearance-none" />
              </div>
              <div className="text-[10px] text-gray-500 italic mt-2">
                Higher sensitivity = detects quieter sounds.<br />
                Lower Max Volume = Red light triggers sooner.
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="h-full flex flex-col items-center justify-center gap-3 p-4 bg-white rounded-2xl border border-gray-200 shadow-xl relative group" style={{ transform: `scale(${fontSize / 16})`, transformOrigin: 'center' }}>
          <div className="absolute top-2 right-2 flex flex-col gap-2 opacity-0 group-hover:opacity-100 transition-opacity z-10">
            <button
              onClick={() => updateData(widget.id, { showSettings: true })}
              className="p-1.5 bg-gray-100 text-gray-400 hover:text-blue-600 rounded-full hover:bg-blue-50 transition-colors"
              title="Settings"
            >
              <Settings size={14} />
            </button>
            <button
              onClick={() => updateData(widget.id, { isListening: !isListening })}
              className={`p-1.5 rounded-full transition-colors ${isListening ? 'bg-red-500 text-white animate-pulse' : 'bg-gray-100 text-gray-400 hover:text-red-500 hover:bg-red-50'}`}
              title={isListening ? "Stop Auto-Listen" : "Start Auto-Listen"}
            >
              {isListening ? <Mic size={14} /> : <Mic size={14} className="opacity-50" />}
            </button>
          </div>

          {['red', 'yellow', 'green'].map(color => (
            <div
              key={color}
              // Only allow manual click if NOT listening
              onClick={() => !isListening && updateData(widget.id, { activeLight: activeLight === color ? null : color })}
              className={`w-20 h-20 rounded-full transition-all duration-200 
                ${activeLight === color ? (
                  color === 'red' ? 'bg-red-500 shadow-[0_0_30px_rgba(239,68,68,0.8)] scale-105' :
                    color === 'yellow' ? 'bg-yellow-400 shadow-[0_0_30px_rgba(250,204,21,0.8)] scale-105' :
                      'bg-green-500 shadow-[0_0_30px_rgba(34,197,94,0.8)] scale-105'
                ) : 'bg-gray-100 scale-100'}
                ${!isListening ? 'cursor-pointer hover:opacity-80' : ''}
              `}
            />
          ))}
        </div>
      );
    };

    const QRCodeWidget = ({ widget, updateData }) => {
      const { url = '' } = widget.data;
      return (
        <div className="h-full flex flex-col p-4 bg-white relative group">
          <h3 className="text-center font-bold text-slate-700 mb-2 flex items-center justify-center gap-2"><QrCode size={16} /> QR Code</h3>
          <input
            className="w-full border rounded p-2 mb-2 text-xs"
            placeholder="https://..."
            value={url}
            onChange={(e) => updateData(widget.id, { url: e.target.value })}
          />
          <div className="flex-1 flex items-center justify-center bg-gray-50 rounded-lg p-4 overflow-hidden">
            {url ? (
              <img src={`https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(url)}`} alt="QR Code" className="w-full h-full object-contain mix-blend-multiply" />
            ) : (
              <div className="text-gray-400 text-[10px] text-center italic">Paste a URL above</div>
            )}
          </div>
        </div>
      );
    };

    const GRID_SIZE = 20;
    const HEADER_HEIGHT = 40;
    const WIDGET_TYPE_LABELS = { TIMER: 'Timers', RANDOMIZER: 'Random', GROUP_MAKER: 'Groups', SEAT_PICKER: 'Seats', TEXT: 'Notes', WEBCAM: 'Cam', DICE: 'Dice', TRAFFIC: 'Noise', QR: 'QR Code', VOTE: 'Poll', DRAWING: 'Drawing', SCHEDULE: 'Schedule', YOUTUBE: 'Embed', CLOCK: 'Clock' };

    // --- UTILS ---
    const DraggableResizable = ({ id, position, size, zIndex, isSelected, isMinimized = false, isSpotlighted = false, isGridEnabled = false, widgetType, onUpdate, onSelect, onRemove, onFontSizeChange, onMinimizeToggle, onSpotlight, onSettings, children, chromeless = false, isGlassy = false, onToggleGlass }) => {
      const [isDragging, setIsDragging] = useState(false);
      const [isResizing, setIsResizing] = useState(false);
      const [resizeDirection, setResizeDirection] = useState(null);

      const startMousePos = useRef({ x: 0, y: 0 });
      const startWidgetPos = useRef({ x: 0, y: 0 });
      const startWidgetSize = useRef({ width: 0, height: 0 });

      const onUpdateRef = useRef(onUpdate);
      const positionRef = useRef(position);
      const sizeRef = useRef(size);

      useEffect(() => {
        onUpdateRef.current = onUpdate;
        positionRef.current = position;
        sizeRef.current = size;
      }, [onUpdate, position, size]);

      const handleMouseDown = (e) => {
        if (e.target.closest('button, input, textarea, select, .no-drag')) return;
        if (e.target.closest('[contenteditable="true"]') && !e.defaultPrevented) return;

        e.stopPropagation();
        onSelect(id);
        setIsDragging(true);
        startMousePos.current = { x: e.clientX, y: e.clientY };
        startWidgetPos.current = { ...position };
      };

      const handleResizeStart = (e, direction) => {
        if (isMinimized) return;
        e.stopPropagation();
        e.preventDefault();
        onSelect(id);
        setIsResizing(true);
        setResizeDirection(direction);
        startMousePos.current = { x: e.clientX, y: e.clientY };
        startWidgetPos.current = { ...position };
        startWidgetSize.current = { ...size };
      };

      useEffect(() => {
        if (!isDragging && !isResizing) return;

        const handleMouseMove = (e) => {
          e.preventDefault();
          const dx = e.clientX - startMousePos.current.x;
          const dy = e.clientY - startMousePos.current.y;

          if (isDragging) {
            let newX = startWidgetPos.current.x + dx;
            let newY = startWidgetPos.current.y + dy;

            if (isGridEnabled) {
              newX = Math.round(newX / GRID_SIZE) * GRID_SIZE;
              newY = Math.round(newY / GRID_SIZE) * GRID_SIZE;
            }
            onUpdateRef.current(id, { x: newX, y: newY }, sizeRef.current);
          } else if (isResizing) {
            let newWidth = startWidgetSize.current.width;
            let newHeight = startWidgetSize.current.height;
            let newX = startWidgetPos.current.x;
            let newY = startWidgetPos.current.y;

            const dir = resizeDirection;

            const minW = chromeless ? 40 : 200;
            const minH = chromeless ? 20 : 100;

            if (dir.includes('e')) {
              newWidth = Math.max(minW, startWidgetSize.current.width + dx);
            }
            if (dir.includes('w')) {
              newWidth = Math.max(minW, startWidgetSize.current.width - dx);
              newX = startWidgetPos.current.x + dx;
              if (newWidth === minW) newX = startWidgetPos.current.x + startWidgetSize.current.width - minW;
            }
            if (dir.includes('s')) {
              newHeight = Math.max(minH, startWidgetSize.current.height + dy);
            }
            if (dir.includes('n')) {
              newHeight = Math.max(minH, startWidgetSize.current.height - dy);
              newY = startWidgetPos.current.y + dy;
              if (newHeight === minH) newY = startWidgetPos.current.y + startWidgetSize.current.height - minH;
            }

            if (isGridEnabled) {
              newWidth = Math.round(newWidth / GRID_SIZE) * GRID_SIZE;
              newHeight = Math.round(newHeight / GRID_SIZE) * GRID_SIZE;
            }

            onUpdateRef.current(id, { x: newX, y: newY }, { width: newWidth, height: newHeight });
          }
        };

        const handleMouseUp = () => {
          if (isDragging) {
            const snappedX = Math.round(positionRef.current.x / GRID_SIZE) * GRID_SIZE;
            const snappedY = Math.round(positionRef.current.y / GRID_SIZE) * GRID_SIZE;
            onUpdateRef.current(id, { x: snappedX, y: snappedY }, sizeRef.current);
          }
          if (isResizing && isGridEnabled) {
            const snappedW = Math.round(sizeRef.current.width / GRID_SIZE) * GRID_SIZE;
            const snappedH = Math.round(sizeRef.current.height / GRID_SIZE) * GRID_SIZE;
            const minW = chromeless ? 40 : 200;
            const minH = chromeless ? 20 : 100;
            onUpdateRef.current(id, positionRef.current, { width: Math.max(minW, snappedW), height: Math.max(minH, snappedH) });
          }
          setIsDragging(false);
          setIsResizing(false);
          setResizeDirection(null);
        };

        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);

        return () => {
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('mouseup', handleMouseUp);
        };
      }, [isDragging, isResizing, id, isGridEnabled, resizeDirection]);

      const displayHeight = isMinimized ? HEADER_HEIGHT : size.height;
      const widgetLabel = WIDGET_TYPE_LABELS[widgetType] || widgetType || '';
      const computedZIndex = isSpotlighted ? 10000 : (isSelected ? 9997 : (zIndex + 100));
      const containerStyle = {
        transitionProperty: (isDragging || isResizing) ? 'none' : 'left, top, width, height, transform, box-shadow, opacity, filter',
        transitionDuration: (isDragging || isResizing) ? '0ms' : '200ms',
        transitionTimingFunction: 'cubic-bezier(0.4, 0, 0.2, 1)',
        willChange: (isDragging || isResizing) ? 'left, top, width, height, transform' : 'auto'
      };
      const contentStyle = chromeless ? { overflow: 'visible' } : {};

      const getWidgetStyleClass = () => {
        let base = 'rounded-2xl ';
        if (isGlassy === 'glass') return base + 'bg-white/40 backdrop-blur-xl border-white/20 shadow-xl';
        if (isGlassy === 'clear') return base + 'bg-transparent border-0 shadow-none';
        if (isGlassy === 'solid') return base + 'bg-white shadow-xl border-gray-100';

        if (chromeless) return base + 'bg-transparent border-0 shadow-none transition-colors duration-200';
        return base + 'bg-white shadow-xl border-gray-100'; // default solid
      };

      const borderClass = (isSelected)
        ? 'ring-2 ring-blue-500 shadow-2xl z-[10001]'
        : (chromeless && (isGlassy === 'clear' || isGlassy === 'glass' || !isGlassy))
          ? 'border-2 border-transparent hover:border-blue-400/30 hover:bg-blue-400/5 transition-all'
          : 'border-2 border-gray-100';

      return (<div className={`absolute flex flex-col ${getWidgetStyleClass()} ${chromeless ? 'overflow-visible' : 'overflow-hidden'} pointer-events-auto ${isDragging || isResizing ? '' : 'transition-all shadow-transition'} ${borderClass} ${isSpotlighted ? 'scale-[1.05] shadow-[0_0_150px_rgba(255,255,255,0.6),0_0_40px_rgba(255,255,255,0.4)] ring-4 ring-white/50 z-[10000] brightness-[1.02]' : ''}`}
        style={{ left: position.x, top: position.y, width: size.width, height: displayHeight, zIndex: computedZIndex, touchAction: 'none', cursor: chromeless ? 'grab' : 'default', ...containerStyle }}
        onMouseDown={(e) => { e.stopPropagation(); if (!isSelected) onSelect(id); if (chromeless) handleMouseDown(e); }}>
        {!chromeless && <div className={`h-10 bg-gray-50 flex items-center justify-between px-2 cursor-move border-b border-gray-100 group select-none flex-shrink-0 relative ${isMinimized ? 'rounded-2xl' : 'rounded-t-2xl'}`} onMouseDown={handleMouseDown}>
          <div className="flex items-center gap-1 z-10">
            {onFontSizeChange && (<><button onClick={(e) => { e.stopPropagation(); onFontSizeChange?.(-2); }} className="p-1 text-gray-400 hover:text-blue-600 hover:bg-blue-100 rounded transition-colors"><Minus size={14} strokeWidth={3} /></button> <button onClick={(e) => { e.stopPropagation(); onFontSizeChange?.(2); }} className="p-1 text-gray-400 hover:text-blue-600 hover:bg-blue-100 rounded transition-colors"><Plus size={14} strokeWidth={3} /></button></>)}
          </div>
          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">{isMinimized ? <span className="text-xs font-bold text-gray-500 uppercase tracking-wider">{widgetLabel}</span> : <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-12 h-1.5 bg-gray-300 rounded-full group-hover:bg-blue-400 transition-colors pointer-events-auto" />}</div>
          <div className="flex items-center gap-1 z-10">
            {onSpotlight && (<button onClick={(e) => { e.stopPropagation(); onSpotlight(id); }} className={`p-1 rounded transition-colors ${isSpotlighted ? 'text-yellow-500 bg-yellow-100' : 'text-gray-400 hover:text-yellow-500 hover:bg-yellow-50'}`} title="Spotlight"> <Lightbulb size={14} /> </button>)}
            {onMinimizeToggle && (<button onClick={(e) => { e.stopPropagation(); onMinimizeToggle(id); }} className="p-1 text-gray-400 hover:text-blue-600 hover:bg-blue-100 rounded transition-colors" title={isMinimized ? "Restore" : "Minimize"}> <span className="font-bold text-sm leading-none">{isMinimized ? '+' : 'âˆ’'}</span> </button>)}
            <button onClick={(e) => { e.stopPropagation(); onRemove(id); }} className="p-1 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded transition-colors"> <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> </button>
          </div>
        </div>}


        {/* Resize Handles - Always on top */}
        {isSelected && !isMinimized && (
          <>
            <div className="absolute top-0 left-0 w-4 h-4 cursor-nw-resize z-[10005]" onMouseDown={(e) => handleResizeStart(e, 'nw')} />
            <div className="absolute top-0 right-0 w-4 h-4 cursor-ne-resize z-[10005]" onMouseDown={(e) => handleResizeStart(e, 'ne')} />
            <div className="absolute bottom-0 left-0 w-4 h-4 cursor-sw-resize z-[10005]" onMouseDown={(e) => handleResizeStart(e, 'sw')} />
            <div className="absolute bottom-0 right-0 w-4 h-4 cursor-se-resize z-[10005]" onMouseDown={(e) => handleResizeStart(e, 'se')} />
            <div className="absolute top-0 left-4 right-4 h-1 cursor-n-resize z-[10005]" onMouseDown={(e) => handleResizeStart(e, 'n')} />
            <div className="absolute bottom-0 left-4 right-4 h-1 cursor-s-resize z-[10005]" onMouseDown={(e) => handleResizeStart(e, 's')} />
            <div className="absolute left-0 top-4 bottom-4 w-1 cursor-w-resize z-[10005]" onMouseDown={(e) => handleResizeStart(e, 'w')} />
            <div className="absolute right-0 top-4 bottom-4 w-1 cursor-e-resize z-[10005]" onMouseDown={(e) => handleResizeStart(e, 'e')} />
          </>
        )}

        <div className={`flex-1 relative flex flex-col custom-scrollbar ${chromeless && widgetType === 'OVERLAY_TEXT' ? 'overflow-visible' : `overflow-hidden ${chromeless ? 'rounded-2xl' : 'rounded-b-2xl'}`}`} style={contentStyle}>{children}</div>

        {!isMinimized && isSelected && (
          <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200">
            {/* Corner handles - dots (Larger hit area with p-1 bg-clip-content) */}
            <div className="absolute top-0 left-0 w-4 h-4 bg-blue-500 rounded-full cursor-nwse-resize z-20 p-1 bg-clip-content" onMouseDown={(e) => handleResizeStart(e, 'nw')} style={{ transform: 'translate(-50%, -50%)' }} />
            <div className="absolute top-0 right-0 w-4 h-4 bg-blue-500 rounded-full cursor-nesw-resize z-20 p-1 bg-clip-content" onMouseDown={(e) => handleResizeStart(e, 'ne')} style={{ transform: 'translate(50%, -50%)' }} />
            <div className="absolute bottom-0 left-0 w-4 h-4 bg-blue-500 rounded-full cursor-nesw-resize z-20 p-1 bg-clip-content" onMouseDown={(e) => handleResizeStart(e, 'sw')} style={{ transform: 'translate(-50%, 50%)' }} />
            <div className="absolute bottom-0 right-0 w-4 h-4 bg-blue-500 rounded-full cursor-nwse-resize z-20 p-1 bg-clip-content" onMouseDown={(e) => handleResizeStart(e, 'se')} style={{ transform: 'translate(50%, 50%)' }} />

            {/* Edge handles - dashes (Larger hit area) */}
            <div className="absolute top-0 left-1/2 w-8 h-4 bg-blue-500 rounded-sm cursor-ns-resize z-20 p-1 bg-clip-content" onMouseDown={(e) => handleResizeStart(e, 'n')} style={{ transform: 'translate(-50%, -50%)' }} />
            <div className="absolute bottom-0 left-1/2 w-8 h-4 bg-blue-500 rounded-sm cursor-ns-resize z-20 p-1 bg-clip-content" onMouseDown={(e) => handleResizeStart(e, 's')} style={{ transform: 'translate(-50%, 50%)' }} />
            <div className="absolute top-1/2 left-0 w-4 h-8 bg-blue-500 rounded-sm cursor-ew-resize z-20 p-1 bg-clip-content" onMouseDown={(e) => handleResizeStart(e, 'w')} style={{ transform: 'translate(-50%, -50%)' }} />
            <div className="absolute top-1/2 right-0 w-4 h-8 bg-blue-500 rounded-sm cursor-ew-resize z-20 p-1 bg-clip-content" onMouseDown={(e) => handleResizeStart(e, 'e')} style={{ transform: 'translate(50%, -50%)' }} />
          </div>
        )}

        {chromeless && isSelected && (
          <div className="absolute top-2 right-2 flex gap-1 z-[10006]">
            {widgetType === 'CLOCK' && (
              <button
                onMouseDown={(e) => e.stopPropagation()}
                onClick={(e) => { e.stopPropagation(); onSettings?.(id); }}
                className="p-1.5 bg-white/90 shadow-md rounded-lg text-slate-500 hover:text-indigo-600 hover:bg-white transition-all border border-slate-200 pointer-events-auto"
                title="Clock Settings"
              >
                <Settings size={14} />
              </button>
            )}
            {onToggleGlass && (
              <button
                onMouseDown={(e) => e.stopPropagation()}
                onClick={(e) => { e.stopPropagation(); onToggleGlass(); }}
                className={`p-1.5 shadow-md rounded-lg transition-all border pointer-events-auto ${isGlassy && isGlassy !== 'solid' ? 'bg-indigo-600 text-white border-indigo-700' : 'bg-white/90 text-slate-500 hover:text-indigo-600 border-slate-200'}`}
                title="Toggle Transparency State"
              >
                <WindowIcon size={14} />
              </button>
            )}
            <button
              onMouseDown={(e) => e.stopPropagation()}
              onClick={(e) => { e.stopPropagation(); onRemove(id); }}
              className="p-1.5 bg-white/90 shadow-md rounded-lg text-slate-400 hover:text-red-600 hover:bg-white transition-all border border-slate-200 pointer-events-auto"
              title="Delete"
            >
              <X size={14} />
            </button>
          </div>
        )}
      </div>);
    };

    const SimpleTextWidget = ({ widget, updateData, isGlassy, isSelected }) => {
      const { content = '', fontFamily = 'Poppins', fontScale = 1, hasShadow = false } = widget.data || {};
      const [isHovered, setIsHovered] = useState(false);
      const [showFontColorMenu, setShowFontColorMenu] = useState(false);
      const [showFontMenu, setShowFontMenu] = useState(false);
      const editorRef = useRef(null);
      const [isFocused, setIsFocused] = useState(false);
      const [toolbarPos, setToolbarPos] = useState(null);
      const [formats, setFormats] = useState({ bold: false, italic: false, underline: false });

      const updateFormats = useCallback(() => {
        setFormats({
          bold: document.queryCommandState('bold'),
          italic: document.queryCommandState('italic'),
          underline: document.queryCommandState('underline')
        });

        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0 && !selection.isCollapsed && editorRef.current?.contains(selection.anchorNode)) {
          const range = selection.getRangeAt(0);
          const rect = range.getBoundingClientRect();
          setToolbarPos({ top: rect.top, left: rect.left + rect.width / 2 });
        } else {
          setToolbarPos(null);
        }
      }, []);

      const fontSize = (widget.data.fontSize || 16) * (fontScale || 1);

      const exec = (command, value = null) => {
        editorRef.current?.focus();
        document.execCommand(command, false, value);
        updateFormats();
        if (editorRef.current) updateData(widget.id, { content: editorRef.current.innerHTML });
      };

      const handleBlur = (e) => {
        setIsFocused(false);
        updateData(widget.id, { content: e.target.innerHTML });
      };

      useEffect(() => {
        if (editorRef.current && !isFocused) {
          if (editorRef.current.innerHTML !== (content || '')) {
            editorRef.current.innerHTML = content || '';
          }
        }
      }, [content, isFocused]);

      return (
        <div className='w-full h-full relative group flex flex-col items-center justify-center p-2' onMouseEnter={() => setIsHovered(true)} onMouseLeave={() => { setIsHovered(false); setShowFontColorMenu(false); setShowFontMenu(false); }} onClick={() => setIsHovered(true)}>
          <div className="relative w-full h-full flex flex-col">
            {/* Drag Handle - Visible on Hover/Selection - SHIFTED HIGHER Z-INDEX TO BE ABOVE RESIZE HANDLES */}
            {(isHovered || isSelected) && (
              <div
                className="absolute -top-4 left-1/2 -translate-x-1/2 bg-blue-600 text-white rounded-full p-1.5 shadow-lg cursor-grab active:cursor-grabbing z-[10010] transition-all hover:scale-125 hover:bg-blue-700"
                onMouseDown={(e) => {
                  // Explicitly allow propagation to DraggableResizable for moving
                  // But prevent it from focusing the editor
                  e.preventDefault();
                  // bubbling happens automatically to parent DraggableResizable
                }}
              >
                <GripHorizontal size={14} />
              </div>
            )}

            {/* Content Clipper - Ensures text doesn't spill out */}
            <div className="relative w-full h-full overflow-hidden rounded-lg">
              <div
                ref={editorRef}
                contentEditable
                suppressContentEditableWarning
                onFocus={() => setIsFocused(true)}
                onBlur={handleBlur}
                onInput={(e) => updateData(widget.id, { content: e.target.innerHTML })}
                onKeyUp={updateFormats}
                onMouseUp={updateFormats}
                onKeyDown={(e) => { e.stopPropagation(); if (e.key === 'Escape') editorRef.current?.blur(); }}
                onDoubleClick={(e) => {
                  e.stopPropagation();
                  setIsFocused(true);
                  if (editorRef.current) {
                    editorRef.current.focus();
                  }
                }}
                onMouseDown={(e) => {
                  // Interaction Logic:
                  // 1. If already focusing, let clicks pass to text (stop propagation).
                  // 2. If NOT focusing, prevent default focus so we can drag the window (bubble to parent).
                  if (isFocused) {
                    e.stopPropagation();
                  } else {
                    e.preventDefault(); // Stop focus
                    // Bubble to DraggableResizable to start drag
                  }
                  setToolbarPos(null);
                }}
                className='w-full h-full outline-none overflow-auto custom-scrollbar leading-relaxed p-3'
                style={{
                  fontSize: fontSize + 'px',
                  fontFamily: `${fontFamily}, sans-serif`,
                  color: 'inherit',
                  textShadow: hasShadow ? '0 0 15px rgba(255,255,255,0.8), 0 0 5px rgba(255,255,255,0.9), 2px 2px 4px rgba(0,0,0,0.3)' : 'none',
                  cursor: isFocused ? 'text' : 'grab',
                  transition: (widget.isResizing || widget.isDragging) ? 'none' : 'font-size 0.2s cubic-bezier(0.4, 0, 0.2, 1)',
                  wordWrap: 'break-word',
                  overflowWrap: 'break-word',
                  whiteSpace: 'pre-wrap',
                  wordBreak: 'break-word'
                }}
              />
            </div>
          </div>

          <FloatingFormattingToolbar
            pos={toolbarPos}
            formats={formats}
            exec={exec}
            onClose={() => setToolbarPos(null)}
            updateData={updateData}
            widgetId={widget.id}
            hasShadow={hasShadow}
            fontScale={fontScale}
            fontFamily={fontFamily}
            showFontColorMenu={showFontColorMenu}
            setShowFontColorMenu={setShowFontColorMenu}
            showFontMenu={showFontMenu}
            setShowFontMenu={setShowFontMenu}
          />
        </div>
      );
    };

    // --- CLOCK SUB-COMPONENTS ---
    const FlipUnit = ({ value, label }) => {
      const [current, setCurrent] = useState(value);
      const [next, setNext] = useState(value);
      const [isAnimating, setIsAnimating] = useState(false);
      useEffect(() => {
        if (value !== next) {
          setNext(value);
          setIsAnimating(true);
          const timer = setTimeout(() => { setCurrent(value); setIsAnimating(false); }, 600);
          return () => clearTimeout(timer);
        }
      }, [value, next]);

      const renderHalf = (val, part) => (
        <div className={`absolute inset-x-0 ${part === 'top' ? 'top-0 h-1/2 rounded-t-xl' : 'bottom-0 h-1/2 rounded-b-xl'} overflow-hidden bg-[#222]`}>
          <div className={`absolute inset-0 ${part === 'top' ? 'bg-gradient-to-b from-[#333] to-[#222]' : 'bg-gradient-to-b from-[#222] to-[#111]'}`} />
          <div className="absolute inset-0 flex items-center justify-center overflow-hidden">
            <span className={`font-mono font-bold text-white tracking-tighter tabular-nums leading-none`}
              style={{ fontSize: '12rem', transform: part === 'top' ? 'translateY(50%)' : 'translateY(-50%)', textShadow: '0 2px 4px rgba(0,0,0,0.5)' }}>{val}</span>
          </div>
          {part === 'top' && <div className="absolute inset-0 bg-gradient-to-b from-white/10 to-transparent pointer-events-none" />}
          {part === 'bottom' && <div className="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent pointer-events-none" />}
          <div className={`absolute inset-0 border-[0.5px] border-white/10 ${part === 'top' ? 'rounded-t-xl border-b-0' : 'rounded-b-xl border-t-0'}`} />
        </div>
      );
      return (
        <div className="flex flex-col items-center gap-3">
          <div className="relative w-40 h-56 bg-[#111] rounded-xl shadow-2xl perspective-1000 group">
            <div className="absolute inset-0 flex flex-col rounded-xl overflow-hidden">
              <div className="relative h-1/2 w-full">{renderHalf(next, 'top')}</div>
              <div className="relative h-1/2 w-full">{renderHalf(next, 'bottom')}</div>
            </div>
            {!isAnimating && (
              <div className="absolute inset-0 flex flex-col rounded-xl overflow-hidden z-10">
                <div className="relative h-1/2 w-full">{renderHalf(current, 'top')}</div>
                <div className="relative h-1/2 w-full">{renderHalf(current, 'bottom')}</div>
              </div>
            )}
            {isAnimating && (
              <div className="absolute inset-x-0 top-0 h-1/2 z-20 origin-bottom flip-animate" style={{ transformStyle: 'preserve-3d' }}>
                {renderHalf(current, 'top')}
                <div className="absolute inset-0 bg-black/50 animate-in fade-in duration-300 transform-gpu" />
              </div>
            )}
            <div className="absolute top-1/2 left-0 right-0 h-[2px] bg-black z-30 shadow-sm" />
            <div className="absolute inset-0 rounded-xl ring-1 ring-white/5 pointer-events-none z-40" />
          </div>
          <span className="text-xs font-bold tracking-[0.3em] text-slate-400 uppercase">{label}</span>
        </div>
      );
    };

    const ClockWidget = ({ widget, extraProps }) => {
      const { clockStyle, setClockStyle } = extraProps || {};
      const { fontSize = 16, showDate: initialShowDate } = widget.data || {};
      const { isGlassy, onOpenSettings, showDate: globalShowDate, textColor } = extraProps || {};
      const showDate = initialShowDate !== undefined ? initialShowDate : (globalShowDate || false);
      const [time, setTime] = useState(new Date());

      useEffect(() => {
        const timer = setInterval(() => setTime(new Date()), 1000);
        return () => clearInterval(timer);
      }, []);

      const preventSelectClass = "select-none cursor-default";

      const hours = time.getHours();
      const minutes = time.getMinutes();
      const seconds = time.getSeconds();
      const displayHours = hours % 12 || 12;
      const timeString = time.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      const dateString = time.toLocaleDateString([], { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });

      const renderAnalog = () => (
        <div className={`flex flex-col items-center justify-center gap-[2cqmin] w-full h-full`}>
          <div className={`relative rounded-full border-[0.5cqmin] backdrop-blur-md shadow-lg flex items-center justify-center ${isGlassy === 'clear' ? 'bg-transparent border-transparent shadow-none' : (textColor === 'text-white' ? 'border-white/50 bg-white/10' : 'border-slate-800/20 bg-white/60')}`}
            style={{ width: 'min(60cqw, 60cqh)', height: 'min(60cqw, 60cqh)' }}>
            {[...Array(12)].map((_, i) => (
              <div key={i} className={`absolute w-[1cqmin] h-[3cqmin] ${textColor === 'text-white' ? 'bg-white/60' : 'bg-slate-800/60'}`} style={{ transform: `rotate(${i * 30}deg) translateY(-25cqmin)` }} />
            ))}
            <div className={`absolute w-[1.5cqmin] h-[15cqmin] rounded-full origin-bottom left-1/2 bottom-1/2 -ml-[0.75cqmin] ${textColor === 'text-white' ? 'bg-white' : 'bg-slate-800'}`} style={{ transform: `rotate(${hours % 12 * 30 + minutes / 2}deg)` }} />
            <div className={`absolute w-[1cqmin] h-[20cqmin] rounded-full origin-bottom left-1/2 bottom-1/2 -ml-[0.5cqmin] ${textColor === 'text-white' ? 'bg-white/80' : 'bg-slate-800/80'}`} style={{ transform: `rotate(${minutes * 6}deg)` }} />
            <div className="absolute w-[0.5cqmin] h-[22cqmin] bg-red-400 rounded-full origin-bottom left-1/2 bottom-1/2 -ml-[0.25cqmin]" style={{ transform: `rotate(${seconds * 6}deg)` }} />
            <div className={`absolute w-[3cqmin] h-[3cqmin] rounded-full z-10 shadow-sm ${textColor === 'text-white' ? 'bg-white' : 'bg-slate-800'}`} />
          </div>
          {showDate && <div className={`font-medium opacity-90 whitespace-nowrap ${textColor} drop-shadow-md text-center`} style={{ fontSize: 'min(5cqw, 10cqh)' }}>{dateString}</div>}
        </div>
      );

      const renderBigHour = () => (
        <div className="flex flex-col items-center justify-center w-full h-full">
          <div className="flex items-center justify-center gap-[2cqw]">
            <div className={`font-black tracking-tighter ${textColor} opacity-90 drop-shadow-lg leading-none`} style={{ fontSize: 'min(35cqw, 70cqh)' }}>{displayHours}</div>
            <div className="flex flex-col items-start justify-center gap-0">
              <div className={`font-bold tracking-tight ${textColor} opacity-80 drop-shadow-md leading-none`} style={{ fontSize: 'min(15cqw, 30cqh)' }}>{minutes.toString().padStart(2, '0')}</div>
              <div className={`font-medium opacity-70 ${textColor} drop-shadow-md leading-none`} style={{ fontSize: 'min(8cqw, 16cqh)' }}>{seconds.toString().padStart(2, '0')}</div>
            </div>
          </div>
          {showDate && <div className={`font-medium uppercase tracking-widest opacity-80 mt-[1cqh] ${textColor}`} style={{ fontSize: 'min(4cqw, 8cqh)' }}>{dateString}</div>}
        </div>
      );

      const renderModern = () => (
        <div className="flex flex-col items-center gap-0 w-full h-full justify-center">
          <div className={`font-thin tracking-widest ${textColor} drop-shadow-sm`} style={{ fontVariantNumeric: 'tabular-nums', fontSize: 'min(20cqw, 45cqh)' }}>{timeString.split(' ')[0]}</div>
          {showDate && <div className={`font-light tracking-wide uppercase opacity-80 ${textColor}`} style={{ fontSize: 'min(4cqw, 10cqh)' }}>{dateString}</div>}
        </div>
      );

      const renderStandard = () => (
        <div className="flex flex-col items-center gap-0 w-full h-full justify-center">
          <div className={`font-bold tracking-tight ${textColor} drop-shadow-md`} style={{ fontVariantNumeric: 'tabular-nums', lineHeight: 0.9, fontSize: 'min(22cqw, 55cqh)' }}>{timeString}</div>
          {showDate && <div className={`font-medium tracking-wide uppercase opacity-90 mt-[2cqh] ${textColor}`} style={{ fontSize: 'min(5cqw, 12cqh)' }}>{dateString}</div>}
        </div>
      );

      const renderRetro = () => {
        const glowColor = 'rgba(56, 255, 56, 0.6)';
        const digitColor = 'text-[#38ff38]';
        const isTransparent = isGlassy === 'clear';
        return (
          <div className={`flex flex-col items-center justify-center p-4 relative overflow-hidden group/clock w-full h-full transition-all ${isTransparent ? 'bg-transparent border-0' : (isGlassy === 'glass' ? 'bg-black/40 backdrop-blur-md rounded-2xl' : 'bg-[#0a0a0a] shadow-[inset_0_0_20px_rgba(0,0,0,1)] border-[6px] border-[#1a1a1a] rounded-2xl')}`}
            style={{ containerType: 'size' }}>
            {!isTransparent && <div className="absolute inset-0 bg-gradient-to-br from-white/10 to-transparent pointer-events-none rounded-sm z-20" />}
            <div className={`absolute inset-0 bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.25)_50%),linear-gradient(90deg,rgba(255,0,0,0.06),rgba(0,255,0,0.02),rgba(0,0,255,0.06))] z-10 bg-[length:100%_4px,6px_100%] pointer-events-none ${isTransparent ? 'opacity-40' : 'opacity-20'}`} />
            <div className={`relative z-10 flex items-center justify-center gap-2 font-['VT323'] leading-none ${digitColor}`}
              style={{ textShadow: `0 0 10px ${glowColor}, 0 0 20px ${glowColor}`, fontSize: 'min(28cqw, 55cqh)' }}>
              <div className="tracking-widest tabular-nums whitespace-nowrap">{timeString}</div>
            </div>
          </div>
        );
      };

      const renderModernAnalog = () => {
        const markerColor = textColor === 'text-white' ? 'bg-white/40' : 'bg-slate-400/20';
        const accentColor = textColor === 'text-white' ? '#ffffff' : '#1e293b';

        return (
          <div className="flex flex-col items-center justify-center w-full h-full p-[2cqw] gap-[5cqh]">
            {/* Minimalist Square Clock Face */}
            <div className={`relative flex items-center justify-center transition-all duration-500 ${isGlassy === 'clear' ? (textColor === 'text-white' ? 'bg-white/10 border border-white/20' : 'bg-slate-800/5 border border-slate-800/10') : (textColor === 'text-white' ? 'bg-white/20 backdrop-blur-xl border border-white/20 shadow-2xl' : 'bg-white/95 border-slate-100 shadow-[0_15px_35px_rgba(0,0,0,0.1)]')}`}
              style={{
                width: 'min(75cqw, 75cqh)',
                height: 'min(75cqw, 75cqh)',
                borderRadius: '24%'
              }}>

              {/* Dial Ticks (Hours & Minutes) */}
              {[...Array(60)].map((_, i) => {
                const isHour = i % 5 === 0;
                const isQuarter = i % 15 === 0;
                return (
                  <div key={i}
                    className={`absolute left-1/2 top-1/2 ${isHour ? markerColor.replace('20', '80') : markerColor}`}
                    style={{
                      width: isQuarter ? '1.2cqmin' : (isHour ? '0.8cqmin' : '0.4cqmin'),
                      height: isQuarter ? '4.5cqmin' : (isHour ? '3.5cqmin' : '1.5cqmin'),
                      borderRadius: '1px',
                      transform: `translate(-50%, -50%) rotate(${i * 6}deg) translateY(-32cqmin)`
                    }}
                  />
                );
              })}

              {/* Hands (Radiating from the center 'middle dot') */}
              <div className="absolute inset-0 flex items-center justify-center">
                {/* Hour Hand */}
                <div className="absolute w-[2.2cqmin] h-[18cqmin] rounded-t-full origin-bottom"
                  style={{
                    transform: `translate(0, -18cqmin) rotate(${hours * 30 + minutes / 2}deg)`,
                    backgroundColor: accentColor,
                    top: '50%', left: '50%',
                    marginLeft: '-1.1cqmin'
                  }} />

                {/* Minute Hand */}
                <div className="absolute w-[1.4cqmin] h-[26cqmin] rounded-t-full origin-bottom opacity-70"
                  style={{
                    transform: `translate(0, -26cqmin) rotate(${minutes * 6}deg)`,
                    backgroundColor: accentColor,
                    top: '50%', left: '50%',
                    marginLeft: '-0.7cqmin'
                  }} />

                {/* Second Hand - Precise Needle */}
                <div className="absolute w-[0.6cqmin] h-[30cqmin] bg-red-500/90 rounded-t-full origin-bottom"
                  style={{
                    transform: `translate(0, -30cqmin) rotate(${seconds * 6}deg)`,
                    top: '50%', left: '50%',
                    marginLeft: '-0.3cqmin'
                  }} />

                {/* Center Middle Dot - Everything radiates from here */}
                <div className="absolute w-[2.8cqmin] h-[2.8cqmin] bg-white border-[0.7cqmin] border-red-500 rounded-full z-20 shadow-sm" />
              </div>
            </div>

            {/* Date positioned clearly below */}
            {showDate && (
              <div className={`text-center font-bold uppercase tracking-[0.4em] ${textColor} pointer-events-none transition-opacity`}
                style={{ fontSize: 'min(3cqw, 6cqh)', opacity: 0.4 }}>{dateString}</div>
            )}
          </div>
        );
      };

      return (
        <div className={`w-full h-full flex items-center justify-center relative group ${preventSelectClass}`}>
          <div className={`w-full h-full flex flex-col items-center justify-center transition-all ${isGlassy ? 'scale-100' : ''}`} style={{ containerType: 'size' }}>
            {clockStyle === 'analog' && renderAnalog()}
            {clockStyle === 'modern-analog' && renderModernAnalog()}
            {clockStyle === 'bighour' && renderBigHour()}
            {clockStyle === 'modern' && renderModern()}
            {clockStyle === 'retro' && renderRetro()}
            {(clockStyle === 'standard' || !clockStyle) && renderStandard()}
          </div>
        </div>
      );
    };



    const TimerWidget = ({ widget, updateData }) => {
      const data = widget.data || {};
      const { timeLeft = 120, isRunning = false, isMuted = false, mode = 'visual', color = 'blue', fontSize = 16, elapsed = 0 } = data;
      const [customTime, setCustomTime] = useState("");
      const [showColorMenu, setShowColorMenu] = useState(false);
      const intervalRef = useRef(null);
      const isDraggingRef = useRef(false);
      const timerRef = useRef(null);

      // Colors
      const COLORS = {
        blue: { stroke: '#3b82f6', handle: '#2563eb', bg: 'bg-blue-500' },
        red: { stroke: '#ef4444', handle: '#dc2626', bg: 'bg-red-500' },
        green: { stroke: '#22c55e', handle: '#16a34a', bg: 'bg-green-500' },
        orange: { stroke: '#f97316', handle: '#ea580c', bg: 'bg-orange-500' },
        purple: { stroke: '#a855f7', handle: '#9333ea', bg: 'bg-purple-500' }
      };
      const theme = (color && COLORS[color]) ? COLORS[color] : COLORS.blue;

      const playAlarm = () => {
        if (isMuted) return;
        try {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          const ctx = new AudioContext();
          if (ctx.state === 'suspended') ctx.resume();

          const frequencies = [1046.50, 1174.66, 1318.51, 1567.98, 1760.00, 2093.00, 2349.32]; // C6 Pentatonic + high F

          frequencies.forEach((freq, i) => {
            const delay = Math.random() * 0.3 + (i * 0.1);
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);

            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, ctx.currentTime + delay);

            // Envelope
            gain.gain.setValueAtTime(0, ctx.currentTime + delay);
            gain.gain.linearRampToValueAtTime(0.15, ctx.currentTime + delay + 0.05); // Attack
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + delay + 2.5); // Long decay

            osc.start(ctx.currentTime + delay);
            osc.stop(ctx.currentTime + delay + 2.5);
          });
        } catch (e) {
          console.error("Audio error", e);
          // Fallback
          const audio = new Audio('https://cdn.freesound.org/previews/352/352097_6403606-lq.mp3');
          audio.volume = 0.5;
          audio.play().catch(e => console.error("Audio play failed", e));
        }
      };

      useEffect(() => {
        if (isRunning) {
          if (mode === 'stopwatch') {
            const start = performance.now() - (data.elapsed || 0);
            const loop = () => {
              const now = performance.now();
              updateData(widget.id, { elapsed: now - start });
              intervalRef.current = requestAnimationFrame(loop);
            };
            intervalRef.current = requestAnimationFrame(loop);
          } else {
            // Standard Countdown
            if (timeLeft > 0) {
              intervalRef.current = window.setInterval(() => {
                updateData(widget.id, { timeLeft: Math.max(0, timeLeft - 1) });
              }, 1000);
            } else if (timeLeft === 0) {
              updateData(widget.id, { isRunning: false });
              playAlarm();
            }
          }
        }
        return () => {
          if (intervalRef.current) {
            if (mode === 'stopwatch') cancelAnimationFrame(intervalRef.current);
            else clearInterval(intervalRef.current);
          }
        };
      }, [isRunning, timeLeft, widget.id, updateData, mode]); // Added mode dependency

      const calculateTimeFromMouseEvent = (e) => {
        if (!timerRef.current) return;
        const rect = timerRef.current.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const x = e.clientX - cx;
        const y = e.clientY - cy;

        let angleRad = Math.atan2(y, x);
        let angle = angleRad + Math.PI / 2;
        if (angle < 0) angle += 2 * Math.PI;

        const totalMins = (angle / (2 * Math.PI)) * 60;
        const newSeconds = Math.max(0, Math.min(3600, Math.round(totalMins) * 60));

        return newSeconds;
      };

      const handleMouseDown = (e) => {
        if (isRunning) return;
        e.stopPropagation();
        e.preventDefault();
        isDraggingRef.current = true;

        const newTime = calculateTimeFromMouseEvent(e);
        if (newTime !== undefined) updateData(widget.id, { timeLeft: newTime });

        const handleGlobalMove = (ev) => {
          if (!isDraggingRef.current) return;
          ev.preventDefault();
          const t = calculateTimeFromMouseEvent(ev);
          if (t !== undefined) updateData(widget.id, { timeLeft: t });
        };

        const handleGlobalUp = () => {
          isDraggingRef.current = false;
          window.removeEventListener('mousemove', handleGlobalMove);
          window.removeEventListener('mouseup', handleGlobalUp);
        };

        window.addEventListener('mousemove', handleGlobalMove);
        window.addEventListener('mouseup', handleGlobalUp);
      };

      const toggleTimer = () => updateData(widget.id, { isRunning: !isRunning });
      const resetTimer = () => {
        if (mode === 'stopwatch') updateData(widget.id, { isRunning: false, elapsed: 0 });
        else updateData(widget.id, { isRunning: false, timeLeft: 120 });
      };
      const adjustTime = (delta) => updateData(widget.id, { timeLeft: Math.max(0, timeLeft + delta) });
      const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;

      const formatStopwatch = (ms) => {
        if (!ms) return "00:00.00";
        const totalSec = Math.floor(ms / 1000);
        const m = Math.floor(totalSec / 60);
        const s = totalSec % 60;
        const centi = Math.floor((ms % 1000) / 10); // 2 digits
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${centi.toString().padStart(2, '0')}`;
      };

      const progress = timeLeft / 3600;
      const circum = 2 * Math.PI * 45; // Based on r=45?
      // Wait, we want the handle to be in the MIDDLE of the stroke.
      // Stroke width = 45.
      // Stroke is centered at r=22.5?
      // Inner radius = 0. Outer radius = 45.
      // So visual timer fills the whole circle.
      // The handle should be at r=22.5 to be in the middle of the "pie slice"?
      // Or at r=40 near the edge?
      // User said "lines up with the edge of the blue area".
      // If the blue area ends at r=45 (outer edge), and the handle is at r=45, it matches the outer edge.
      // If the user meant the flat "leading edge" of the time sector...
      // The handle IS at the leading edge.
      // But maybe the handle needs to be slightly inward to look good?
      // Let's try r=35.

      const angle = progress * 2 * Math.PI;
      // Handle Position
      const handleR = 38; // Slightly inside outer edge (45)
      const handleX = 50 + handleR * Math.cos(angle);
      const handleY = 50 + handleR * Math.sin(angle);

      return (
        <div className="flex flex-col items-center justify-between h-full p-2 relative bg-white select-none group">
          <div className="absolute top-2 left-2 z-20 opacity-0 group-hover:opacity-100 transition-opacity">
            {mode === 'visual' && (
              <>
                <button
                  onClick={() => setShowColorMenu(!showColorMenu)}
                  className={`w-6 h-6 rounded-full ${theme.bg} ring-2 ring-white shadow-sm hover:scale-110 transition-transform`}
                  title="Change Color"
                />
                {showColorMenu && (
                  <div className="absolute top-full left-0 mt-2 bg-white rounded-xl shadow-xl border border-gray-100 p-2 flex flex-col gap-2 z-50 animate-in fade-in slide-in-from-top-2">
                    {Object.keys(COLORS).map(c => (
                      <button
                        key={c}
                        onClick={() => { updateData(widget.id, { color: c }); setShowColorMenu(false); }}
                        className={`w-5 h-5 rounded-full ${COLORS[c].bg} ${color === c ? 'ring-2 ring-slate-400' : ''} hover:scale-110 transition-transform`}
                      />
                    ))}
                  </div>
                )}
              </>
            )}
          </div>
          {/* Mode Switcher - New 3 Buttons Design */}
          <div className="absolute top-2 right-2 flex bg-gray-100 rounded-lg p-0.5 gap-0.5 z-20 opacity-0 group-hover:opacity-100 transition-opacity">
            <button onClick={() => updateData(widget.id, { mode: 'visual' })} className={`p-1 rounded-md transition-all ${mode === 'visual' ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-400 hover:text-gray-600'}`} title="Visual Timer"><PieChart size={12} /></button>
            <button onClick={() => updateData(widget.id, { mode: 'digital' })} className={`p-1 rounded-md transition-all ${mode === 'digital' ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-400 hover:text-gray-600'}`} title="Digital Timer"><Hash size={12} /></button>
            <button onClick={() => updateData(widget.id, { mode: 'stopwatch', isRunning: false })} className={`p-1 rounded-md transition-all ${mode === 'stopwatch' ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-400 hover:text-gray-600'}`} title="Stopwatch"><TimerIcon size={12} /></button>
          </div>

          <div className="flex-1 w-full flex items-center justify-center p-2 min-h-0">
            {mode === 'visual' ? (
              <div className="relative w-full h-full max-h-[90%] aspect-square flex items-center justify-center">
                <svg ref={timerRef} className="transform -rotate-90 w-full h-full overflow-visible" viewBox="0 0 100 100" onMouseDown={handleMouseDown} style={{ cursor: isRunning ? 'default' : 'grab' }}>
                  {/* Ticks */}
                  {Array.from({ length: 60 }).map((_, i) => {
                    const isMajor = i % 5 === 0;
                    const deg = i * 6;
                    const rad = deg * Math.PI / 180;
                    const rInner = isMajor ? 36 : 40;
                    const rOuter = 44;
                    const x1 = 50 + rInner * Math.cos(rad);
                    const y1 = 50 + rInner * Math.sin(rad);
                    const x2 = 50 + rOuter * Math.cos(rad);
                    const y2 = 50 + rOuter * Math.sin(rad);
                    return (
                      <line
                        key={i}
                        x1={x1} y1={y1}
                        x2={x2} y2={y2}
                        stroke={isMajor ? "#cbd5e1" : "#e2e8f0"}
                        strokeWidth={isMajor ? 1.5 : 1}
                        style={{ pointerEvents: 'none' }}
                      />
                    );
                  })}
                  {/* Track */}
                  <circle cx="50" cy="50" r="45" stroke="#f3f4f6" strokeWidth="10" fill="white" className="opacity-10" />

                  {/* colored slice - r=22.5, width=45 covers 0-45 radius (full pie) */}
                  {timeLeft > 0 && (
                    <circle cx="50" cy="50" r="22.5" stroke={theme.stroke} strokeWidth="45" fill="none"
                      strokeDasharray={`${2 * Math.PI * 22.5} ${2 * Math.PI * 22.5}`}
                      strokeDashoffset={2 * Math.PI * 22.5 * (1 - progress)}
                      className="transition-all duration-75 ease-linear pointer-events-none"
                    />
                  )}

                  {/* Border */}
                  <circle cx="50" cy="50" r="45" stroke="#e5e7eb" strokeWidth="1" fill="none" pointerEvents="none" />

                  {/* Handle */}
                  {!isRunning && (
                    <g transform={`translate(${handleX}, ${handleY})`}>
                      <circle r="5" fill="white" stroke={theme.handle} strokeWidth="2" className="shadow-sm cursor-grab active:cursor-grabbing" />
                    </g>
                  )}
                </svg>
                <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                  <span className="font-bold text-slate-700 bg-white/80 px-2 rounded-lg backdrop-blur-sm shadow-sm" style={{ fontSize: (fontSize * 1.5) + 'px' }}>{formatTime(timeLeft)}</span>
                </div>
              </div>
            ) : mode === 'digital' ? (
              <div className="flex flex-col items-center">
                <div className={`font-black text-slate-800 tracking-widest mb-4 font-sans`} style={{ fontSize: (fontSize * 4) + 'px' }}>{formatTime(timeLeft)}</div>
                {!isRunning && (
                  <div className="flex flex-col items-center gap-2">
                    <div className="flex gap-2 items-center mt-2">
                      <input
                        type="text"
                        placeholder="00:00"
                        className="w-20 text-center border rounded p-1 text-sm font-bold text-gray-600"
                        value={customTime}
                        onChange={(e) => setCustomTime(e.target.value)}
                        onKeyDown={(e) => {
                          if (e.key === 'Enter') {
                            const parts = customTime.split(':').map(Number);
                            let seconds = 0;
                            // Improved parsing
                            if (parts.length === 2) seconds = parts[0] * 60 + parts[1];
                            else if (parts.length === 1 && !isNaN(parts[0])) seconds = parts[0] * 60;

                            if (seconds > 0) {
                              updateData(widget.id, { timeLeft: seconds });
                              setCustomTime("");
                            }
                          }
                        }}
                      />
                      <button onClick={() => {
                        const parts = customTime.split(':').map(Number);
                        let seconds = 0;
                        if (parts.length === 2) seconds = parts[0] * 60 + parts[1];
                        else if (parts.length === 1 && !isNaN(parts[0])) seconds = parts[0] * 60;
                        if (seconds > 0) {
                          updateData(widget.id, { timeLeft: seconds });
                          setCustomTime("");
                        }
                      }} className="bg-slate-200 hover:bg-slate-300 text-slate-600 px-2 py-1 rounded text-xs font-bold">Set</button>
                    </div>
                  </div>
                )}
              </div>
            ) : (
              /* Stopwatch Mode */
              <div className="flex flex-col items-center">
                <div className="font-black text-slate-800 tracking-widest font-mono" style={{ fontSize: (fontSize * 3) + 'px' }}>
                  {formatStopwatch(elapsed)}
                </div>
                <div className="text-xs font-bold text-slate-400 uppercase tracking-widest mt-2">Stopwatch</div>
              </div>
            )}
          </div>

          <div className="flex gap-4 items-center z-10 py-2">
            <button onClick={() => updateData(widget.id, { isMuted: !isMuted })} className={`p-2 rounded-full transition-colors ${isMuted ? 'text-red-400 bg-red-50' : 'text-slate-400 hover:bg-slate-100 hover:text-slate-600'}`} title={isMuted ? "Unmute" : "Mute"}>
              {isMuted ? <VolumeX size={18} /> : <Volume2 size={18} />}
            </button>
            <button onClick={toggleTimer} className={`p-4 rounded-full text-white shadow-lg transition-transform active:scale-95 flex items-center justify-center ${isRunning ? 'bg-orange-500 hover:bg-orange-600' : 'bg-green-500 hover:bg-green-600'}`}>
              {isRunning ? <Pause size={24} fill="currentColor" /> : <Play size={24} fill="currentColor" className="ml-1" />}
            </button>
            <button onClick={resetTimer} className="p-3 hover:bg-slate-100 rounded-full text-slate-500 transition-colors" title="Reset"><RotateCcw size={20} /></button>
          </div>
        </div >
      );
    };

    const RandomizerWidget = ({ widget, updateData, roster }) => {
      const { currentName, isAnimating, fontSize = 16, pickedStudents = [], bgColor = '#e0e7ff' } = widget.data;
      const [showSettings, setShowSettings] = useState(false);
      const steps = useRef(0);
      const intervalRef = useRef(null);
      const activeStudents = roster.filter(s => s.active);
      const unpickedStudents = activeStudents.filter(s => !pickedStudents.includes(s.name));

      useEffect(() => {
        if (isAnimating) {
          let availableStudents = unpickedStudents.length > 0 ? unpickedStudents : activeStudents;
          if (availableStudents.length === 0) { updateData(widget.id, { isAnimating: false }); return; }

          intervalRef.current = window.setInterval(() => {
            const randomName = availableStudents[Math.floor(Math.random() * availableStudents.length)].name;
            updateData(widget.id, { currentName: randomName });
            steps.current++;
            if (steps.current >= 20) {
              if (intervalRef.current) clearInterval(intervalRef.current);
              const finalName = widget.data.currentName || randomName;
              const newPickedList = unpickedStudents.length > 0 ? [...pickedStudents, finalName] : [finalName];
              updateData(widget.id, { isAnimating: false, pickedStudents: newPickedList });
              steps.current = 0;
            }
          }, 100);
        }
        return () => { if (intervalRef.current) clearInterval(intervalRef.current); };
      }, [isAnimating, widget.id, activeStudents.length]);

      const resetPicked = () => updateData(widget.id, { pickedStudents: [], currentName: null });
      const removePicked = (name) => updateData(widget.id, { pickedStudents: pickedStudents.filter(n => n !== name) });
      const scaledFS = (fontSize / 16) * 30;
      const pickedCount = pickedStudents.length;
      const totalCount = activeStudents.length;

      if (showSettings) {
        return (
          <div className="flex flex-col h-full bg-white p-3 relative animate-in fade-in slide-in-from-right-4 duration-200">
            <div className="flex justify-between items-center mb-2 border-b pb-2">
              <h3 className="font-bold text-gray-700 text-sm">Settings</h3>
              <button onClick={() => setShowSettings(false)} className="p-1 hover:bg-gray-100 rounded-full"><X size={16} /></button>
            </div>
            <div className="flex-1 overflow-y-auto custom-scrollbar space-y-4">
              <div>
                <label className="block text-[10px] font-bold text-gray-400 uppercase mb-1">Background Color</label>
                <div className="flex gap-2 flex-wrap">
                  {['#e0e7ff', '#fee2e2', '#dcfce7', '#fef9c3', '#f3e8ff', '#ffffff'].map(c => (
                    <button key={c} onClick={() => updateData(widget.id, { bgColor: c })} className={`w-6 h-6 rounded-full border shadow-sm ${bgColor === c ? 'ring-2 ring-gray-400' : ''}`} style={{ backgroundColor: c }} />
                  ))}
                </div>
              </div>
              <div>
                <div className="flex justify-between items-center mb-1">
                  <label className="text-[10px] font-bold text-gray-400 uppercase">Picked History ({pickedCount})</label>
                  <button onClick={resetPicked} className="text-[10px] text-red-500 font-bold hover:underline">Reset All</button>
                </div>
                <div className="flex flex-wrap gap-1">
                  {pickedStudents.map(name => (
                    <div key={name} className="flex items-center gap-1 bg-gray-100 px-2 py-1 rounded-md text-xs border">
                      <span className="truncate max-w-[80px]">{name}</span>
                      <button onClick={() => removePicked(name)} className="text-gray-400 hover:text-red-500"><X size={12} /></button>
                    </div>
                  ))}
                  {pickedStudents.length === 0 && <span className="text-xs text-gray-300 italic">No history yet</span>}
                </div>
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="flex flex-col items-center justify-center h-full p-4 relative group transition-colors duration-300" style={{ backgroundColor: bgColor }}>
          <button onClick={() => setShowSettings(true)} className="absolute top-2 right-2 p-2 text-gray-400 hover:text-gray-600 rounded-full hover:bg-black/5 opacity-0 group-hover:opacity-100 transition-opacity z-20">
            <Settings size={16} />
          </button>

          <div className="absolute top-2 left-2 text-[10px] font-bold text-black/40 uppercase tracking-wider">
            {pickedCount}/{totalCount}
          </div>

          <div className="flex-1 flex items-center justify-center w-full">
            <h2 className="font-bold text-center break-words text-indigo-900 leading-tight" style={{ fontSize: scaledFS + 'px' }}>{currentName || <span className="opacity-20">?</span>}</h2>
          </div>
          <button onClick={() => { steps.current = 0; updateData(widget.id, { isAnimating: true }); }} disabled={isAnimating || activeStudents.length === 0} className="bg-indigo-600 text-white px-8 py-3 rounded-full flex gap-2 items-center font-bold shadow-lg transition-all active:scale-95 hover:bg-indigo-700">
            <Shuffle size={18} /> Pick Random
          </button>
          {unpickedStudents.length === 0 && activeStudents.length > 0 && <div className="absolute bottom-16 text-xs text-green-600 font-bold">All picked! Cycle complete.</div>}
        </div>
      );
    };

    const GroupMakerWidget = ({ widget, updateData, roster }) => {
      const { groups = [], fontSize = 16, groupCount = 4 } = widget.data;
      const containerRef = useRef(null);
      const [columns, setColumns] = useState(4);
      const dragItem = useRef(null);
      const dragSourceGroup = useRef(null);

      const activeStudents = roster.filter(s => s.active);
      const count = activeStudents.length;
      const scaledFS = (fontSize / 16) * 14;

      // Responsive column calculation with Debounce
      useEffect(() => {
        if (!containerRef.current) return;

        let timeoutId;
        const observer = new ResizeObserver((entries) => {
          for (let entry of entries) {
            // Debounce the column update to prevent rapid flickering
            if (timeoutId) clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
              const width = entry.contentRect.width;
              // Adjusted: 160px min width for better spacing, max 8 columns
              const newCols = Math.max(1, Math.min(8, Math.floor(width / 160)));
              setColumns(newCols);
            }, 50);
          }
        });
        observer.observe(containerRef.current);
        return () => {
          observer.disconnect();
          if (timeoutId) clearTimeout(timeoutId);
        };
      }, []);

      const createGroups = (countNeeded) => {
        const shuffled = [...activeStudents].sort(() => Math.random() - 0.5);
        const newG = Array.from({ length: countNeeded }, () => []);
        shuffled.forEach((s, i) => newG[i % countNeeded].push(s));
        updateData(widget.id, { groups: newG, groupCount: countNeeded });
      };

      const handleDragStart = (e, studentId, groupIndex) => {
        dragItem.current = studentId;
        dragSourceGroup.current = groupIndex;
        e.dataTransfer.effectAllowed = 'move';
        // Transparent drag image or default? Default is fine.
      };

      const handleDragOver = (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      };

      const handleDrop = (e, targetGroupIndex, targetInfo = {}) => {
        e.preventDefault();
        e.stopPropagation();
        const studentId = dragItem.current;
        const sourceIndex = dragSourceGroup.current;

        if (studentId === null || sourceIndex === null) return;

        // Don't drop on self
        if (sourceIndex === targetGroupIndex && studentId === targetInfo.studentId) return;

        // Deep copy
        const newGroups = groups.map(g => [...g]);

        // Find student in source
        const sourceGroup = newGroups[sourceIndex];
        const sourceStudentIndex = sourceGroup.findIndex(s => s.id === studentId);
        if (sourceStudentIndex === -1) return;

        // Remove from source
        const [student] = sourceGroup.splice(sourceStudentIndex, 1);

        // Determine Insert Index
        let insertIndex = newGroups[targetGroupIndex].length;
        if (targetInfo.studentId) {
          const targetStudentIndex = newGroups[targetGroupIndex].findIndex(s => s.id === targetInfo.studentId);
          if (targetStudentIndex !== -1) {
            // If moving within same group downwards, insert AFTER
            if (sourceIndex === targetGroupIndex && sourceStudentIndex < targetStudentIndex) {
              insertIndex = targetStudentIndex + 1;
            } else {
              insertIndex = targetStudentIndex;
            }
          }
        }

        newGroups[targetGroupIndex].splice(insertIndex, 0, student);

        updateData(widget.id, { groups: newGroups });
        dragItem.current = null;
        dragSourceGroup.current = null;
      };

      // Calculate grid template based on dynamic columns
      const gridStyle = {
        display: 'grid',
        gridTemplateColumns: `repeat(${columns}, minmax(0, 1fr))`,
        gap: '0.5rem'
      };

      // Setup View (If no groups generated yet)
      if (groups.length === 0) {
        return (
          <div className="flex flex-col h-full bg-white relative p-6 items-center justify-center text-center">
            <div className="w-16 h-16 bg-blue-50 text-blue-500 rounded-2xl flex items-center justify-center mb-4">
              <Users size={32} />
            </div>
            <h3 className="font-bold text-lg text-slate-800 mb-2">Group Maker</h3>
            <p className="text-slate-500 text-xs max-w-[200px] mb-6">Instantly split {count} students into random groups.</p>

            <div className="w-full max-w-[240px] bg-slate-50 p-3 rounded-xl border border-slate-100 mb-4">
              <div className="flex justify-between items-center mb-2">
                <span className="text-xs font-bold text-slate-500 uppercase">Groups</span>
                <span className="text-sm font-black text-slate-700">{groupCount}</span>
              </div>
              <input
                type="range" min="2" max="20" value={groupCount}
                onChange={e => updateData(widget.id, { groupCount: Number(e.target.value) })}
                className="w-full accent-blue-600 h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer"
              />
              <div className="text-[10px] text-slate-400 mt-2 text-right">
                ~{Math.ceil(count / groupCount)} students per group
              </div>
            </div>

            <button
              onClick={() => createGroups(groupCount)}
              disabled={count === 0}
              className="w-full max-w-[240px] py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-lg shadow-blue-200 transition-all active:scale-95 flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <Shuffle size={18} /> Generate Groups
            </button>
          </div>
        );
      }

      return (
        <div className="flex flex-col h-full bg-slate-50 relative p-4">
          <div className="flex flex-col gap-2 flex-1 min-h-0">
            <div className="flex justify-between items-center mb-1 shrink-0">
              <div className="bg-white border border-gray-200 px-2 py-0.5 rounded-md shadow-sm">
                <span className="text-[10px] uppercase font-bold text-gray-400 tracking-wider">Present: </span>
                <span className="text-xs font-bold text-blue-600">{count}</span>
              </div>
              <button onClick={() => updateData(widget.id, { groups: [] })} className="text-[10px] font-bold text-slate-400 hover:text-red-500 underline transition-colors">
                Reset
              </button>
            </div>

            <div ref={containerRef} className="overflow-y-auto content-start custom-scrollbar flex-1" style={gridStyle}>
              {groups.map((g, i) => (
                <div
                  key={i}
                  onDragOver={handleDragOver}
                  onDrop={(e) => handleDrop(e, i)}
                  className="bg-white p-2 rounded-xl shadow-sm border border-gray-100 min-h-[80px] flex flex-col transition-colors hover:bg-blue-50/30 group"
                >
                  <div className="flex justify-between items-center mb-1">
                    <div className="font-bold text-[10px] uppercase text-gray-400 tracking-wider">Group {i + 1}</div>
                    <div className="text-[9px] font-bold text-gray-300 bg-gray-50 px-1 rounded">{g.length}</div>
                  </div>
                  <div className="flex-1 space-y-1 min-h-[1.5rem]">
                    {g.map(s => (
                      <div
                        key={s.id}
                        draggable
                        onDragStart={(e) => handleDragStart(e, s.id, i)}
                        onDrop={(e) => handleDrop(e, i, { studentId: s.id })}
                        onDragOver={handleDragOver}
                        className="px-1.5 py-1 bg-gray-50 hover:bg-blue-100 rounded flex items-center text-gray-700 font-medium cursor-grab active:cursor-grabbing border border-transparent hover:border-blue-200 transition-colors"
                        style={{ fontSize: scaledFS + 'px', overflow: 'hidden' }}
                      >
                        <span className="truncate w-full">{s.name}</span>
                      </div>
                    ))}
                  </div>
                </div>
              ))}
            </div>

            <div className="bg-white p-2 rounded-xl border border-gray-200 shadow-sm mt-auto shrink-0">
              <div className="flex justify-between items-center mb-1">
                <span className="text-xs font-bold text-slate-600">Groups: {groupCount}</span>
                <span className="text-[10px] text-slate-400">~{Math.ceil(count / groupCount)} students/group</span>
              </div>
              <input
                type="range" min="2" max="20" value={groupCount}
                onChange={e => {
                  const c = Number(e.target.value);
                  updateData(widget.id, { groupCount: c });
                  createGroups(c);
                }}
                className="w-full accent-blue-600 h-2 bg-slate-100 rounded-lg appearance-none cursor-pointer mb-2"
              />
              <button onClick={() => createGroups(groupCount)} className="w-full py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold rounded-lg transition-colors flex items-center justify-center gap-1">
                <Shuffle size={14} /> Shuffle Groups
              </button>
            </div>
          </div>
        </div>
      );
    };

    const WebcamWidget = ({ widget, updateData }) => {
      const { isMirrored = true, isActive = true } = widget.data;
      const videoRef = useRef(null);
      const streamRef = useRef(null);

      const takePhoto = () => {
        if (videoRef.current) {
          const canvas = document.createElement('canvas');
          canvas.width = videoRef.current.videoWidth;
          canvas.height = videoRef.current.videoHeight;
          const ctx = canvas.getContext('2d');
          if (isMirrored) {
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
          }
          ctx.drawImage(videoRef.current, 0, 0);
          const link = document.createElement('a');
          link.download = `photo-${Date.now()}.png`;
          link.href = canvas.toDataURL('image/png');
          link.click();
        }
      };

      useEffect(() => {
        const startCamera = async () => {
          if (isActive) {
            try {
              const stream = await navigator.mediaDevices.getUserMedia({ video: true });
              streamRef.current = stream;
              if (videoRef.current) {
                videoRef.current.srcObject = stream;
              }
            } catch (e) {
              console.error("Camera Error:", e);
              updateData(widget.id, { isActive: false });
            }
          } else {
            stopCamera();
          }
        };
        startCamera();
        return () => {
          stopCamera();
        };
      }, [isActive]);

      const stopCamera = () => {
        if (streamRef.current) {
          streamRef.current.getTracks().forEach(track => track.stop());
          streamRef.current = null;
        }
        if (videoRef.current) {
          videoRef.current.srcObject = null;
        }
      };

      return (
        <div className="w-full h-full bg-black relative flex flex-col group overflow-hidden">
          <div className="flex-1 relative bg-gray-900 flex items-center justify-center">
            {isActive ? (
              <video ref={videoRef} autoPlay playsInline muted className={`w-full h-full object-cover pointer-events-none ${isMirrored ? 'scale-x-[-1]' : ''}`} />
            ) : (
              <div className="text-white/50 text-center flex flex-col items-center">
                <CameraOff size={48} className="mb-2 opacity-50" />
                <span className="text-sm font-medium">Camera Off</span>
              </div>
            )}
          </div>

          {/* Gradient Overlay */}
          <div className="absolute bottom-0 left-0 right-0 h-32 bg-gradient-to-t from-black/90 via-black/50 to-transparent pointer-events-none" />

          {/* Controls */}
          <div className="absolute bottom-0 left-0 right-0 p-4 text-white z-10">
            <div className="flex justify-center gap-3 opacity-0 group-hover:opacity-100 transition-opacity">
              <button onClick={() => updateData(widget.id, { isActive: !isActive })} className="p-3 bg-white/20 backdrop-blur-md hover:bg-white/30 rounded-full text-white">
                {isActive ? <CameraOff size={20} /> : <Camera size={20} />}
              </button>
              <button onClick={takePhoto} className="p-3 bg-white/20 backdrop-blur-md hover:bg-white/30 rounded-full text-white">
                <Camera size={20} />
              </button>
              {isActive && (
                <button onClick={() => updateData(widget.id, { isMirrored: !isMirrored })} className="p-3 bg-white/20 backdrop-blur-md hover:bg-white/30 rounded-full text-white">
                  {isMirrored ? <FlipHorizontal size={16} /> : <FlipHorizontal size={16} className="text-gray-400" />}
                </button>
              )}
            </div>
          </div>
        </div>
      );
    };

    // ============================================================
    // ENHANCED DRAWING WIDGET - With speed-sensitive pen, text, emojis
    // ============================================================
    const DRAWING_EMOJIS = ['â­', 'â¤ï¸', 'âœ…', 'âŒ', 'ðŸ‘', 'ðŸ‘Ž', 'ðŸŽ¯', 'ðŸ†', 'ðŸ”¥', 'ðŸ’¡', 'ðŸ“Œ', 'ðŸŽ¨', 'ðŸ“', 'ðŸŒŸ', 'âœ¨', 'ðŸŽ‰', 'ðŸ’¯', 'ðŸ‘€', 'ðŸ¤”', 'ðŸ’ª', 'ðŸŒˆ', 'âš¡', 'ðŸŽ', 'ðŸ˜Š', 'ðŸ™Œ', 'ðŸŽµ', 'ðŸŒ¸', 'ðŸŽ', 'ðŸš€', 'ðŸ’Ž'];

    const DrawingWidget = ({ widget, updateData }) => {
      const { color = '#000000', brushSize = 8, tool = 'pen', textItems = [], emojiItems = [] } = widget.data;
      const canvasRef = useRef(null);
      const ctxRef = useRef(null);
      const isDrawing = useRef(false);
      const lastPoint = useRef(null);
      const lastTime = useRef(null);
      const [showColorPicker, setShowColorPicker] = useState(false);
      const [showEmojiPicker, setShowEmojiPicker] = useState(false);
      const [selectedItem, setSelectedItem] = useState(null);
      const [history, setHistory] = useState([]);
      const [historyIndex, setHistoryIndex] = useState(-1);
      const resizeTimeout = useRef(null);

      // Initialize canvas
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Load existing canvas data if present
        if (widget.data.canvasData) {
          const img = new Image();
          img.onload = () => {
            ctx.drawImage(img, 0, 0);
            saveToHistory(); // Save the restored state as the first history point
          };
          img.src = widget.data.canvasData;
        } else {
          saveToHistory(); // Save the initial blank state
        }

        ctxRef.current = ctx;
      }, []);

      // Debounced resize - only resize when dimensions actually change
      const lastDimensions = useRef({ width: 0, height: 0 });
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const handleResize = () => {
          clearTimeout(resizeTimeout.current);
          resizeTimeout.current = setTimeout(() => {
            const rect = canvas.parentElement.getBoundingClientRect();
            // Only resize if dimensions actually changed by more than 5px
            if (Math.abs(rect.width - lastDimensions.current.width) < 5 &&
              Math.abs(rect.height - lastDimensions.current.height) < 5) {
              return;
            }
            lastDimensions.current = { width: rect.width, height: rect.height };
            const imageData = canvas.toDataURL();
            canvas.width = rect.width;
            canvas.height = rect.height;
            const img = new Image();
            img.onload = () => {
              ctxRef.current.fillStyle = '#ffffff';
              ctxRef.current.fillRect(0, 0, canvas.width, canvas.height);
              ctxRef.current.drawImage(img, 0, 0);
            };
            img.src = imageData;
          }, 50); // Much shorter debounce for responsiveness
        };
        const observer = new ResizeObserver(handleResize);
        observer.observe(canvas.parentElement);
        return () => { observer.disconnect(); clearTimeout(resizeTimeout.current); };
      }, []);

      const saveToHistory = () => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const imageData = canvas.toDataURL();
        setHistory(prev => [...prev.slice(0, historyIndex + 1), imageData]);
        setHistoryIndex(prev => prev + 1);
        // Sync to global state for persistence
        updateData(widget.id, { canvasData: imageData });
      };

      const undo = () => {
        if (historyIndex <= 0) return;
        const newIndex = historyIndex - 1;
        setHistoryIndex(newIndex);
        const img = new Image();
        img.onload = () => {
          ctxRef.current.fillStyle = '#ffffff';
          ctxRef.current.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
          ctxRef.current.drawImage(img, 0, 0);
        };
        img.src = history[newIndex];
      };

      const redo = () => {
        if (historyIndex >= history.length - 1) return;
        const newIndex = historyIndex + 1;
        setHistoryIndex(newIndex);
        const img = new Image();
        img.onload = () => {
          ctxRef.current.fillStyle = '#ffffff';
          ctxRef.current.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
          ctxRef.current.drawImage(img, 0, 0);
        };
        img.src = history[newIndex];
      };

      const getPos = (e) => {
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
        const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
        return { x, y, time: performance.now() };
      };

      // Smooth drawing variables
      const points = useRef([]);
      const smoothedVelocity = useRef(0);
      const currentWidth = useRef(null);

      const startDrawing = (e) => {
        if (tool !== 'pen' && tool !== 'eraser') return;
        e.preventDefault();
        e.stopPropagation();
        isDrawing.current = true;
        const pos = getPos(e);
        lastPoint.current = pos;
        lastTime.current = pos.time;
        points.current = [pos];
        smoothedVelocity.current = 0;
        currentWidth.current = brushSize;

        const ctx = ctxRef.current;
        ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : color;
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        // Draw a dot for single clicks
        ctx.lineTo(pos.x + 0.1, pos.y + 0.1);
        ctx.stroke();
      };

      const draw = (e) => {
        if (!isDrawing.current || !lastPoint.current) return;
        e.preventDefault();
        const pos = getPos(e);
        const ctx = ctxRef.current;

        // Calculate instant velocity
        const dx = pos.x - lastPoint.current.x;
        const dy = pos.y - lastPoint.current.y;
        const dt = Math.max(pos.time - lastTime.current, 1);
        const distance = Math.sqrt(dx * dx + dy * dy);
        const velocity = distance / dt;

        // Smooth the velocity with exponential moving average
        smoothedVelocity.current = smoothedVelocity.current * 0.6 + velocity * 0.4;

        // Speed sensitivity: slower = thicker, faster = thinner
        // velocity ~0 (stopped) = 1.8x size, velocity ~10+ (fast) = 0.5x size
        const speedFactor = tool === 'eraser' ? 3 : Math.max(0.5, Math.min(1.8, 1.6 - smoothedVelocity.current * 0.1));
        const targetWidth = brushSize * speedFactor;

        // Smooth the width transitions
        const prevWidth = currentWidth.current || brushSize;
        currentWidth.current = prevWidth * 0.7 + targetWidth * 0.3;

        // Draw filled circles along the path for smooth, continuous variable-width strokes
        ctx.fillStyle = tool === 'eraser' ? '#ffffff' : color;

        // Interpolate from last point to current point
        const steps = Math.max(1, Math.ceil(distance / 2)); // Draw a circle every 2 pixels
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = lastPoint.current.x + dx * t;
          const y = lastPoint.current.y + dy * t;
          const w = prevWidth + (currentWidth.current - prevWidth) * t;

          ctx.beginPath();
          ctx.arc(x, y, w / 2, 0, Math.PI * 2);
          ctx.fill();
        }

        lastPoint.current = pos;
        lastTime.current = pos.time;
      };

      const stopDrawing = () => {
        if (isDrawing.current) {
          isDrawing.current = false;
          ctxRef.current.closePath();
          saveToHistory();
        }
      };

      const handleCanvasClick = (e) => {
        if (tool === 'text') {
          const pos = getPos(e);
          const newText = { id: Date.now().toString(), x: pos.x, y: pos.y, text: 'Text', scale: 1, rotation: 0, color };
          updateData(widget.id, { textItems: [...textItems, newText], tool: 'select' });
          setSelectedItem({ type: 'text', id: newText.id });
        } else if (tool === 'select') {
          setSelectedItem(null);
        }
      };

      const addEmoji = (emoji) => {
        const canvas = canvasRef.current;
        const newEmoji = { id: Date.now().toString(), x: canvas.width / 2, y: canvas.height / 2, emoji, scale: 1, rotation: 0 };
        updateData(widget.id, { emojiItems: [...emojiItems, newEmoji], tool: 'select' });
        setShowEmojiPicker(false);
        setSelectedItem({ type: 'emoji', id: newEmoji.id });
      };

      const updateTextContent = (id, text) => {
        updateData(widget.id, { textItems: textItems.map(t => t.id === id ? { ...t, text } : t) });
      };

      const deleteSelected = () => {
        if (!selectedItem) return;
        if (selectedItem.type === 'text') {
          updateData(widget.id, { textItems: textItems.filter(t => t.id !== selectedItem.id) });
        } else if (selectedItem.type === 'emoji') {
          updateData(widget.id, { emojiItems: emojiItems.filter(e => e.id !== selectedItem.id) });
        }
        setSelectedItem(null);
      };

      const clearCanvas = () => {
        if (!confirm('Clear the entire canvas?')) return;
        const ctx = ctxRef.current;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
        updateData(widget.id, { textItems: [], emojiItems: [] });
        setSelectedItem(null);
        saveToHistory();
      };

      const downloadPNG = () => {
        const canvas = canvasRef.current;
        const link = document.createElement('a');
        link.download = 'drawing.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      };

      // Drag/Scale/Rotate handlers for items
      const handleItemMouseDown = (e, type, id, mode = 'move') => {
        if (tool !== 'select') return;
        e.stopPropagation();
        e.preventDefault(); // Prevent text selection and glitchy behavior
        setSelectedItem({ type, id });

        const items = type === 'text' ? textItems : emojiItems;
        const item = items.find(i => i.id === id);
        if (!item) return;

        const startX = e.clientX;
        const startY = e.clientY;
        const startItemX = item.x;
        const startItemY = item.y;
        const startScale = item.scale;
        const startRotation = item.rotation;

        const onMove = (me) => {
          const dx = me.clientX - startX;
          const dy = me.clientY - startY;

          if (mode === 'move') {
            const listKey = type + 'Items';
            const list = type === 'text' ? textItems : emojiItems;
            updateData(widget.id, { [listKey]: list.map(i => i.id === id ? { ...i, x: startItemX + dx, y: startItemY + dy } : i) });
          } else if (mode === 'scale') {
            const dist = Math.sqrt(dx * dx + dy * dy);
            const factor = 1 + (dx > 0 ? dist / 200 : -dist / 200);
            const newScale = Math.max(0.2, Math.min(5, startScale * factor));
            const listKey = type + 'Items';
            const list = type === 'text' ? textItems : emojiItems;
            updateData(widget.id, { [listKey]: list.map(i => i.id === id ? { ...i, scale: newScale } : i) });
          } else if (mode === 'rotate') {
            const rect = me.currentTarget.parentElement?.getBoundingClientRect() || { left: 0, top: 0, width: 0, height: 0 };
            const centerX = item.x;
            const centerY = item.y;
            // Get mouse position relative to canvas
            const canvasRect = canvasRef.current.getBoundingClientRect();
            const mouseX = me.clientX - canvasRect.left;
            const mouseY = me.clientY - canvasRect.top;

            const angle = Math.atan2(mouseY - centerY, mouseX - centerX) * (180 / Math.PI);
            const listKey = type + 'Items';
            const list = type === 'text' ? textItems : emojiItems;
            updateData(widget.id, { [listKey]: list.map(i => i.id === id ? { ...i, rotation: angle + 90 } : i) });
          }
        };

        const onUp = () => {
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', onUp);
        };

        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
      };

      const COLORS = ['#000000', '#ef4444', '#f59e0b', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899', '#ffffff'];

      // INITIAL IMAGE / PASTE HANDLER
      useEffect(() => {
        const initialImage = widget.data.initialImage;
        const pastedImage = widget.data.pastedImage;
        const imgToLoad = pastedImage || initialImage;

        if (imgToLoad && ctxRef.current) {
          const img = new Image();
          img.onload = () => {
            const canvas = canvasRef.current;
            const ctx = ctxRef.current;

            // Center scale to fit
            const scale = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.9;
            const w = img.width * scale;
            const h = img.height * scale;
            const x = (canvas.width - w) / 2;
            const y = (canvas.height - h) / 2;

            // No clear canvas here, just draw on top (or we could clear if it's initial)
            ctx.drawImage(img, x, y, w, h);
            saveToHistory();

            // Clear the flag so it doesn't redraw on every render
            const updates = {};
            if (widget.data.initialImage) updates.initialImage = null;
            if (widget.data.pastedImage) updates.pastedImage = null;
            if (Object.keys(updates).length > 0) updateData(widget.id, updates);

          };
          img.src = imgToLoad;

        }

      }, [widget.data.initialImage, widget.data.pastedImage]);

      return (
        <div className="h-full bg-white flex flex-col relative no-drag">
          {/* Toolbar */}
          <div className="bg-gray-50 p-2 border-b flex items-center gap-1 shrink-0 z-20 flex-wrap">
            {/* Color */}
            <div className="relative">
              <button onClick={() => setShowColorPicker(!showColorPicker)} className="w-7 h-7 rounded-full border-2 border-white shadow-md" style={{ backgroundColor: color }} />
              {showColorPicker && (
                <div className="absolute top-full left-0 mt-2 bg-white p-2 rounded-xl shadow-xl flex gap-1 z-50 border">
                  {COLORS.map(c => (
                    <button key={c} onClick={() => { updateData(widget.id, { color: c }); setShowColorPicker(false); }} className="w-5 h-5 rounded-full border hover:scale-110 transition-transform" style={{ backgroundColor: c, borderColor: c === '#ffffff' ? '#ddd' : c }} />
                  ))}
                </div>
              )}
            </div>
            <div className="w-px h-5 bg-gray-200" />
            {/* Tools */}
            <button onClick={() => updateData(widget.id, { tool: 'select' })} className={`p-1.5 rounded-lg transition-all ${tool === 'select' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-500'}`} title="Select"><MousePointer2 size={16} /></button>
            <button onClick={() => updateData(widget.id, { tool: 'pen' })} className={`p-1.5 rounded-lg transition-all ${tool === 'pen' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-500'}`} title="Pen"><Pencil size={16} /></button>
            <button onClick={() => updateData(widget.id, { tool: 'eraser' })} className={`p-1.5 rounded-lg transition-all ${tool === 'eraser' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-500'}`} title="Eraser"><Eraser size={16} /></button>
            <button onClick={() => updateData(widget.id, { tool: 'text' })} className={`p-1.5 rounded-lg transition-all ${tool === 'text' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-500'}`} title="Text"><Type size={16} /></button>
            <button onClick={() => setShowEmojiPicker(!showEmojiPicker)} className={`p-1.5 rounded-lg transition-all ${showEmojiPicker ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-500'}`} title="Emoji"><Smile size={16} /></button>
            <div className="w-px h-5 bg-gray-200" />
            {/* Size */}
            <input type="range" min="2" max="40" value={brushSize} onChange={(e) => updateData(widget.id, { brushSize: Number(e.target.value) })} className="w-16 h-1 accent-blue-500" title={`Size: ${brushSize}`} />
            <div className="w-px h-5 bg-gray-200" />
            {/* Undo/Redo */}
            <button onClick={undo} disabled={historyIndex <= 0} className="p-1.5 rounded-lg hover:bg-gray-100 text-gray-500 disabled:opacity-30" title="Undo"><Undo2 size={16} /></button>
            <button onClick={redo} disabled={historyIndex >= history.length - 1} className="p-1.5 rounded-lg hover:bg-gray-100 text-gray-500 disabled:opacity-30" title="Redo"><Redo2 size={16} /></button>
            {/* Delete selected */}
            {selectedItem && <button onClick={deleteSelected} className="p-1.5 rounded-lg bg-red-50 text-red-500 hover:bg-red-100" title="Delete"><Trash2 size={16} /></button>}
            {/* Actions */}
            <div className="flex gap-1 ml-auto">
              <button onClick={downloadPNG} className="p-1.5 rounded-lg hover:bg-gray-100 text-gray-500 hover:text-green-600" title="Download"><Download size={16} /></button>
              <button onClick={clearCanvas} className="p-1.5 rounded-lg hover:bg-gray-100 text-gray-500 hover:text-red-500" title="Clear"><RotateCcw size={16} /></button>
            </div>
          </div>

          {/* Emoji Picker Popup */}
          {showEmojiPicker && (
            <div className="absolute top-14 left-2 z-50 bg-white rounded-xl shadow-2xl border p-3 w-64 max-h-48 overflow-y-auto" onClick={e => e.stopPropagation()}>
              <div className="grid grid-cols-6 gap-1">
                {DRAWING_EMOJIS.map((em, i) => (
                  <button key={i} onClick={() => addEmoji(em)} className="text-xl p-1 rounded hover:bg-blue-50 hover:scale-110 transition-transform">{em}</button>
                ))}
              </div>
            </div>
          )}

          {/* Canvas + Overlays */}
          <div className="flex-1 relative overflow-hidden bg-white">
            <canvas
              ref={canvasRef}
              className={`absolute inset-0 w-full h-full touch-none ${tool === 'pen' || tool === 'eraser' ? 'cursor-crosshair' : tool === 'text' ? 'cursor-text' : 'cursor-default'}`}
              onMouseDown={startDrawing}
              onMouseMove={draw}
              onMouseUp={stopDrawing}
              onMouseLeave={stopDrawing}
              onClick={handleCanvasClick}
              onTouchStart={startDrawing}
              onTouchMove={draw}
              onTouchEnd={stopDrawing}
            />

            {/* Text Items */}
            {textItems.map(t => {
              const textScale = t.scale || 1;
              const baseHeight = 32; // Adjusted base height
              const baseWidth = Math.max(60, (t.text?.length || 0) * 11 + 20); // More precise width
              return (
                <div key={t.id} className="absolute" style={{ left: t.x, top: t.y, zIndex: selectedItem?.id === t.id ? 10 : 1 }}>
                  {/* Selection box - Positioned relative to center */}
                  {selectedItem?.id === t.id && (
                    <div className="absolute border-2 border-blue-500 rounded pointer-events-none"
                      style={{
                        width: baseWidth * textScale + 4,
                        height: baseHeight * textScale + 4,
                        top: -(baseHeight * textScale) / 2 - 2,
                        left: -(baseWidth * textScale) / 2 - 2,
                        transform: `rotate(${t.rotation}deg)`
                      }} />
                  )}
                  {/* Text content - scaled */}
                  <div
                    className="cursor-move select-none"
                    style={{
                      transform: `translate(-50%, -50%) rotate(${t.rotation}deg) scale(${textScale})`,
                      transformOrigin: 'center',
                      pointerEvents: tool === 'select' ? 'auto' : 'none'
                    }}
                    onMouseDown={(e) => handleItemMouseDown(e, 'text', t.id, 'move')}
                  >
                    <input
                      type="text"
                      value={t.text}
                      autoFocus={selectedItem?.id === t.id && !t.text}
                      onChange={(e) => updateTextContent(t.id, e.target.value)}
                      className="bg-transparent border-none outline-none text-center font-bold text-xl px-2 py-0 min-w-[40px] leading-tight"
                      style={{ color: t.color, cursor: tool === 'select' ? 'text' : 'inherit' }}
                      onClick={(e) => e.stopPropagation()}
                    />
                  </div>
                  {/* Controls - Positioned relative to rotated selection */}
                  {selectedItem?.id === t.id && (
                    <div style={{ transform: `rotate(${t.rotation}deg)`, position: 'absolute', top: 0, left: 0, width: 0, height: 0 }}>
                      <div className="absolute w-5 h-5 bg-white border-2 border-blue-500 rounded-full cursor-grab shadow z-20 flex items-center justify-center"
                        style={{ top: -(baseHeight * textScale) / 2 - 12, left: -10 }}
                        onMouseDown={(e) => handleItemMouseDown(e, 'text', t.id, 'rotate')} title="Rotate">
                        <RotateCw size={10} className="text-blue-500" />
                      </div>
                      <div className="absolute w-5 h-5 bg-white border-2 border-blue-500 rounded-full cursor-nwse-resize shadow z-20"
                        style={{ top: (baseHeight * textScale) / 2 - 10, left: (baseWidth * textScale) / 2 - 10 }}
                        onMouseDown={(e) => handleItemMouseDown(e, 'text', t.id, 'scale')} title="Scale" />
                    </div>
                  )}
                </div>
              );
            })}

            {/* Emoji Items */}
            {emojiItems.map(em => {
              const emojiScale = em.scale || 1;
              const emojiSize = 30 * emojiScale; // text-3xl is roughly 30px
              // Use same box dimensions as text for consistency
              const boxSize = emojiSize + 8;
              return (
                <div key={em.id} className="absolute" style={{ left: em.x, top: em.y, zIndex: selectedItem?.id === em.id ? 10 : 1 }}>
                  {/* Selection box - Square like text */}
                  {selectedItem?.id === em.id && (
                    <div className="absolute border-2 border-blue-500 rounded pointer-events-none"
                      style={{
                        width: boxSize + 4,
                        height: boxSize + 4,
                        top: -boxSize / 2 - 2,
                        left: -boxSize / 2 - 2,
                        transform: `rotate(${em.rotation}deg)`
                      }} />
                  )}
                  {/* Emoji content - scaled */}
                  <div
                    className="cursor-move select-none text-3xl"
                    style={{
                      transform: `translate(-50%, -50%) rotate(${em.rotation}deg) scale(${emojiScale})`,
                      transformOrigin: 'center',
                      pointerEvents: tool === 'select' ? 'auto' : 'none',
                      userSelect: 'none'
                    }}
                    onMouseDown={(e) => handleItemMouseDown(e, 'emoji', em.id, 'move')}
                  >
                    {em.emoji}
                  </div>
                  {/* Controls - Positioned like text items */}
                  {selectedItem?.id === em.id && (
                    <div style={{ transform: `rotate(${em.rotation}deg)`, position: 'absolute', top: 0, left: 0, width: 0, height: 0 }}>
                      <div className="absolute w-5 h-5 bg-white border-2 border-blue-500 rounded-full cursor-grab shadow z-20 flex items-center justify-center"
                        style={{ top: -boxSize / 2 - 12, left: -10 }}
                        onMouseDown={(e) => handleItemMouseDown(e, 'emoji', em.id, 'rotate')} title="Rotate">
                        <RotateCw size={10} className="text-blue-500" />
                      </div>
                      <div className="absolute w-5 h-5 bg-white border-2 border-blue-500 rounded-full cursor-nwse-resize shadow z-20"
                        style={{ top: boxSize / 2 - 10, left: boxSize / 2 - 10 }}
                        onMouseDown={(e) => handleItemMouseDown(e, 'emoji', em.id, 'scale')} title="Scale" />
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        </div>
      );
    };






    const SCHEDULE_EMOJIS = ['ðŸ“š', 'ðŸŽ¨', 'ðŸƒ', 'ðŸŽµ', 'ðŸ’»', 'ðŸ¥ª', 'ðŸ“', 'ðŸ”¬', 'ðŸ—£ï¸', 'ðŸ›‘', 'ðŸšŒ', 'ðŸ ', 'ðŸ“…', 'â­', 'ðŸ””'];

    const ScheduleWidget = ({ widget, updateData, onOpenSettings, selectedDate, scheduleTemplate, setScheduleTemplate }) => {
      const { fontSize = 14 } = widget.data;
      const [dragIndex, setDragIndex] = useState(null);
      const [emojiPickerIndex, setEmojiPickerIndex] = useState(null);
      const [timePickerState, setTimePickerState] = useState({ index: null, triggerRef: null });

      const dayName = DAYS_OF_WEEK[selectedDate ? selectedDate.getDay() : new Date().getDay()];
      const items = (scheduleTemplate && scheduleTemplate[dayName]) ? scheduleTemplate[dayName] : [];

      useEffect(() => {
        const handleClickOutside = () => { setEmojiPickerIndex(null); setTimePickerState({ index: null, triggerRef: null }); };
        if (emojiPickerIndex !== null || timePickerState.index !== null) { document.addEventListener('click', handleClickOutside); return () => document.removeEventListener('click', handleClickOutside); }
      }, [emojiPickerIndex, timePickerState.index]);

      const now = new Date();
      const currentMinutes = now.getHours() * 60 + now.getMinutes();
      const parseTimeToMinutes = (time) => { if (!time) return 0; const [h, m] = time.split(':').map(Number); return h * 60 + m; };

      const isCurrentItem = (item, index) => {
        // Only show current indicator if viewing TODAY
        if (dayName !== DAYS_OF_WEEK[now.getDay()]) return false;

        const itemMinutes = parseTimeToMinutes(item.time);
        const nextItem = items[index + 1];
        const nextMinutes = nextItem ? parseTimeToMinutes(nextItem.time) : 24 * 60;
        return currentMinutes >= itemMinutes && currentMinutes < nextMinutes;
      };

      const saveScheduleData = (newItems) => {
        if (setScheduleTemplate) {
          setScheduleTemplate(prev => ({ ...prev, [dayName]: newItems }));
        }
      };

      const updateItem = (index, field, value) => { const newItems = [...items]; newItems[index] = { ...newItems[index], [field]: value }; saveScheduleData(newItems); };
      const addItem = () => { const newItem = { id: Date.now().toString(), time: '09:00', emoji: 'ðŸ“š', title: 'New Activity', description: '' }; const newItems = [...items, newItem].sort((a, b) => parseTimeToMinutes(a.time) - parseTimeToMinutes(b.time)); saveScheduleData(newItems); };
      const removeItem = (index) => { const newItems = items.filter((_, i) => i !== index); saveScheduleData(newItems); };

      const handleDragStart = (index) => { setDragIndex(index); };
      const handleDragOver = (e) => { e.preventDefault(); };
      const handleDrop = (targetIndex) => { if (dragIndex === null || dragIndex === targetIndex) return; const newItems = [...items]; const [moved] = newItems.splice(dragIndex, 1); newItems.splice(targetIndex, 0, moved); saveScheduleData(newItems); setDragIndex(null); };
      const selectEmoji = (index, emoji) => { updateItem(index, 'emoji', emoji); setEmojiPickerIndex(null); };

      return (
        <div className="flex flex-col h-full bg-gradient-to-br from-indigo-50 to-purple-50">
          <div className="h-10 bg-white/80 backdrop-blur border-b flex items-center justify-between px-3 shrink-0">
            <h3 className="font-bold text-indigo-800 text-sm flex items-center gap-2"><Calendar size={16} /> {dayName}'s Schedule</h3>
            <div className="flex gap-1">
              <button onClick={addItem} className="p-1.5 text-indigo-600 hover:bg-indigo-100 rounded-lg transition-colors" title="Add activity"><Plus size={16} /></button>
              <button onClick={onOpenSettings} className="p-1.5 text-gray-400 hover:bg-gray-100 rounded-lg transition-colors" title="Schedule settings"><Settings size={16} /></button>
            </div>
          </div>
          <div className="flex-1 overflow-y-auto p-2 flex flex-col gap-1 custom-scrollbar">
            {items.length === 0 ? (
              <div className="flex flex-col items-center justify-center h-full text-center p-4">
                <Calendar size={40} className="text-indigo-200 mb-3" />
                <p className="text-indigo-400 text-sm font-medium mb-2">No items for {dayName}</p>
                <button onClick={addItem} className="px-3 py-1.5 bg-indigo-600 text-white text-xs font-bold rounded-lg hover:bg-indigo-700 flex items-center gap-1"><Plus size={14} /> Add Activity</button>
              </div>
            ) : (
              items.map((item, index) => {
                const isCurrent = isCurrentItem(item, index);
                return (
                  <div key={item.id} draggable onDragStart={() => handleDragStart(index)} onDragOver={handleDragOver} onDrop={() => handleDrop(index)} className={`relative group flex gap-2 p-2 rounded-lg border transition-all cursor-move w-full min-h-[4rem] ${isCurrent ? 'bg-indigo-100 border-indigo-400 ring-2 ring-indigo-300' : 'bg-white border-gray-200 hover:border-indigo-200'}`} style={{ zIndex: emojiPickerIndex === index ? 50 : 0 }}>
                    {isCurrent && <div className="absolute -left-1 top-1/2 -translate-y-1/2 w-2 h-2 bg-indigo-500 rounded-full animate-pulse" />}

                    <div className="flex flex-col items-center shrink-0 w-20 relative">
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          setTimePickerState(timePickerState.index === index ? { index: null, triggerRef: null } : { index, triggerRef: { current: e.currentTarget } });
                        }}
                        className="w-full text-sm font-bold text-indigo-600 bg-white/50 border border-indigo-100 px-2 py-1 rounded hover:bg-indigo-50"
                      >
                        {(() => {
                          const [h, m] = (item.time || '09:00').split(':');
                          const hours = parseInt(h);
                          const ampm = hours >= 12 ? 'PM' : 'AM';
                          const displayH = hours % 12 || 12;
                          return `${displayH}:${m} ${ampm}`;
                        })()}
                      </button>
                      {timePickerState.index === index && (
                        <TimePicker
                          time={item.time || '09:00'}
                          onChange={(t) => updateItem(index, 'time', t)}
                          onClose={() => setTimePickerState({ index: null, triggerRef: null })}
                          triggerRef={timePickerState.triggerRef}
                        />
                      )}
                    </div>

                    <div className="relative flex items-center text-xl shrink-0">
                      <div className="cursor-pointer hover:scale-110 transition-transform p-1 rounded hover:bg-indigo-100" onClick={(e) => { e.stopPropagation(); setEmojiPickerIndex(emojiPickerIndex === index ? null : index); }}>
                        {item.emoji || 'ðŸ“š'}
                      </div>
                      {emojiPickerIndex === index && (
                        <div className="absolute left-0 top-full mt-1 z-50 bg-white rounded-xl shadow-xl border border-gray-200 p-2 w-48 max-h-40 overflow-y-auto custom-scrollbar" onClick={(e) => e.stopPropagation()}>
                          <div className="grid grid-cols-5 gap-1"> {SCHEDULE_EMOJIS.map((emoji, i) => (<button key={i} onClick={() => selectEmoji(index, emoji)} className={`text-xl p-1.5 rounded-lg hover:bg-indigo-100 transition-colors ${item.emoji === emoji ? 'bg-indigo-200 ring-2 ring-indigo-400' : ''}`}>{emoji}</button>))} </div>
                        </div>
                      )}
                    </div>
                    <div className="flex-1 min-w-0">
                      <input type="text" value={item.title || ''} onChange={(e) => updateItem(index, 'title', e.target.value)} className="w-full font-bold text-gray-800 bg-transparent border-none outline-none truncate" style={{ fontSize: fontSize + 'px' }} placeholder="Activity name" />
                      <input type="text" value={item.description || ''} onChange={(e) => updateItem(index, 'description', e.target.value)} className="w-full text-xs text-gray-500 bg-transparent border-none outline-none truncate" placeholder="Description (optional)" />
                    </div>
                    <button onClick={() => removeItem(index)} className="p-1 text-red-400 hover:text-red-600 opacity-0 group-hover:opacity-100 transition-opacity self-center"><X size={14} /></button>
                  </div>
                );
              })
            )}
          </div>
        </div>
      );
    };

    const EmbedWidget = ({ widget, updateData }) => {
      const { url = "", youtubeUrl = "" } = widget.data;
      const currentUrl = url || youtubeUrl;
      const [input, setInput] = useState(currentUrl);

      const getEmbedSrc = (link) => {
        if (!link) return null;
        let processedLink = link.trim();
        // Auto-add protocol if missing (and not an iframe tag)
        if (!processedLink.startsWith('http://') && !processedLink.startsWith('https://') && !processedLink.startsWith('<iframe')) {
          processedLink = 'https://' + processedLink;
        }

        if (processedLink.includes("youtube.com") || processedLink.includes("youtu.be")) {
          const id = processedLink.match(/(?:youtu\.be\/|youtube\.com\/watch\?v=|youtube\.com\/embed\/)([\w-]{11})/)?.[1];
          // User requested yout-ube.com for ad-free experience
          return id ? `https://www.yout-ube.com/watch?v=${id}` : null;
        }
        if (processedLink.includes("vimeo.com")) {
          const id = processedLink.match(/vimeo\.com\/(\d+)/)?.[1];
          return id ? `https://player.vimeo.com/video/${id}` : null;
        }
        if (processedLink.includes("<iframe")) {
          const src = processedLink.match(/src="([^"]+)"/)?.[1];
          return src || null;
        }
        return processedLink;
      };

      const embedSrc = getEmbedSrc(currentUrl);

      return (
        <div className="h-full flex flex-col bg-white border border-slate-200 shadow-xl rounded-2xl relative group overflow-hidden">
          {!embedSrc ? (
            <div className="flex-1 flex flex-col items-center justify-center p-6 text-slate-600 gap-4">
              <div className="p-4 bg-red-50 rounded-full text-red-500"><Youtube size={32} /></div>
              <div className="text-center space-y-3 w-full">
                <div className="font-bold text-lg text-slate-800">Embed Content</div>
                <p className="text-slate-400 text-xs text-center max-w-[200px] mx-auto">Paste a link (YouTube, Google Slides, website) or embed code.</p>
                <div className="flex gap-2">
                  <input
                    className="flex-1 bg-slate-50 border border-slate-200 rounded-lg p-2 text-sm text-slate-800 placeholder-slate-400 focus:border-blue-500 outline-none transition-all"
                    placeholder="Paste link here..."
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={(e) => e.key === 'Enter' && updateData(widget.id, { url: input })}
                  />
                  <button onClick={() => updateData(widget.id, { url: input })} className="bg-blue-600 text-white px-3 py-2 rounded-lg font-bold hover:bg-blue-700 transition-colors shadow-sm"><Check size={18} /></button>
                </div>
              </div>
            </div>
          ) : (
            <>
              <iframe src={embedSrc} className="w-full h-full bg-white" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />
              <button
                onClick={() => updateData(widget.id, { url: "", youtubeUrl: "" })}
                className="absolute top-2 right-2 bg-white/90 hover:bg-red-50 text-slate-400 hover:text-red-500 p-2 rounded-full opacity-0 group-hover:opacity-100 transition-all z-10 shadow-sm border border-slate-100"
                title="Remove Embed"
              >
                <X size={16} />
              </button>
            </>
          )}
        </div>
      );
    };
    const YouTubeWidget = EmbedWidget;

    // --- MISSING COMPONENTS (Restored) ---
    // (Onboarding now works with object roster)
    const OnboardingModal = ({ onComplete, onSaveRoster }) => {
      const [text, setText] = useState(DEFAULT_NAMES.join('\n'));
      const handleSave = () => {
        const names = text.split('\n').map(n => n.trim()).filter(n => n);
        if (names.length > 0) {
          const roster = names.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true }));
          saveRoster(roster);
          if (onSaveRoster) onSaveRoster(roster);
        }
        onComplete();
      };
      return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-in fade-in duration-300">
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg flex flex-col overflow-hidden">
            <div className="p-6 bg-gradient-to-r from-blue-600 to-indigo-600 text-white">
              <h2 className="text-2xl font-bold mb-2">Welcome to HomeRoom! ðŸŽ</h2>
              <p className="opacity-90 text-sm">Let's set up your class roster. You can change this anytime.</p>
            </div>
            <div className="p-6">
              <label className="block text-sm font-bold text-gray-700 mb-2">Student Names (one per line)</label>
              <textarea
                value={text}
                onChange={(e) => setText(e.target.value)}
                className="w-full h-32 border-2 border-gray-200 rounded-xl p-4 text-sm focus:border-blue-500 focus:ring-4 focus:ring-blue-50 outline-none transition-all custom-scrollbar resize-none font-sans"
                placeholder="Paste names here..."
              />
            </div>
            <div className="p-4 border-t bg-gray-50 flex justify-end">
              <button
                onClick={handleSave}
                className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl shadow-lg shadow-blue-200 transition-all active:scale-95 flex items-center gap-2"
              >
                <Save size={18} /> Save & Get Started
              </button>
            </div>
          </div>
        </div>
      );
    };

    const AppearanceSettings = ({ currentBg, onSelect, isGridEnabled, onToggleGrid, myBackgrounds, onAddCustom, onDeleteCustom, clockStyle, setClockStyle, showDate, setShowDate, isGlassy, setIsGlassy }) => {
      const [customUrl, setCustomUrl] = useState('');
      const [dragActive, setDragActive] = useState(false);
      const [applyToAll, setApplyToAll] = useState(true);
      const fileInputRef = useRef(null);

      const handleDrag = (e) => {
        e.preventDefault(); e.stopPropagation();
        if (e.type === "dragenter" || e.type === "dragover") setDragActive(true);
        else if (e.type === "dragleave") setDragActive(false);
      };

      const handleDrop = (e) => {
        e.preventDefault(); e.stopPropagation();
        setDragActive(false);
        if (e.dataTransfer.files && e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
      };

      const resizeImage = (file, callback) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const MAX_WIDTH = 1024; // Apps optimized
            const MAX_HEIGHT = 1024;
            let width = img.width;
            let height = img.height;
            if (width > height) { if (width > MAX_WIDTH) { height *= MAX_WIDTH / width; width = MAX_WIDTH; } }
            else { if (height > MAX_HEIGHT) { width *= MAX_HEIGHT / height; height = MAX_HEIGHT; } }
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
            callback(canvas.toDataURL('image/jpeg', 0.7)); // Optimized quality
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      };

      const handleFile = useCallback((file) => {
        if (!file.type.startsWith('image/')) return;
        resizeImage(file, (dataUrl) => {
          const newBg = { id: 'custom-' + Date.now(), name: file.name, type: 'image', src: dataUrl, textColor: 'text-white' };
          onAddCustom(newBg);
          onSelect(newBg, applyToAll ? 'all' : 'single');
        });
      }, [applyToAll, onSelect, onAddCustom]);

      useEffect(() => {
        const handleWindowPaste = (e) => {
          const items = e.clipboardData?.items;
          if (items) {
            for (let i = 0; i < items.length; i++) {
              if (items[i].type.indexOf('image') !== -1) {
                e.preventDefault();
                e.stopImmediatePropagation(); // Prevent App from handling it
                handleFile(items[i].getAsFile());
                break;
              }
            }
          }
        };
        window.addEventListener('paste', handleWindowPaste, true); // Capture phase
        return () => window.removeEventListener('paste', handleWindowPaste, true);
      }, [handleFile]);

      const onDeleteCustomClick = (e, id) => {
        e.stopPropagation();
        if (window.confirm('Delete this background?')) {
          onDeleteCustom(id);
          // Ensure it's deselected if current
          if (currentBg && currentBg.id === id) {
            onSelect(BACKGROUNDS[0], 'all');
          }
        }
      };

      return (
        <div className="flex flex-col h-full overflow-y-auto custom-scrollbar p-4">
          <div className="mb-6 space-y-3">
            <div className="p-3 bg-gray-50 rounded-xl">
              <div className="flex items-center gap-2 mb-2">
                <div className="p-2 bg-indigo-100 text-indigo-600 rounded-lg"><Clock size={18} /></div>
                <div className="font-bold text-xs text-gray-800">Clock Style</div>
              </div>

              <div className="flex items-center gap-3 mb-4">
                <div className="flex items-center gap-2">
                  {/* Dark/Light Mode */}
                  <div className="flex gap-1 bg-gray-100 p-1 rounded-lg">
                    <button
                      onClick={() => onSelect({ ...currentBg, textColor: 'text-slate-800' }, 'all')}
                      className={`p-1.5 rounded-md transition-all ${(!currentBg?.textColor || currentBg?.textColor === 'text-slate-800') ? 'bg-white shadow text-orange-500' : 'text-gray-400 hover:text-gray-600'}`}
                      title="Dark Text"
                    >
                      <Moon size={14} />
                    </button>
                    <button
                      onClick={() => onSelect({ ...currentBg, textColor: 'text-white' }, 'all')}
                      className={`p-1.5 rounded-md transition-all ${currentBg?.textColor === 'text-white' ? 'bg-slate-700 shadow text-yellow-300' : 'text-gray-400 hover:text-gray-600'}`}
                      title="Light Text"
                    >
                      <Sun size={14} />
                    </button>
                  </div>
                </div>

                <div className="w-px h-6 bg-gray-200 mx-1" />

                <div className="flex items-center gap-2 cursor-pointer bg-gray-100 px-3 py-1.5 rounded-lg transition-colors hover:bg-gray-200" onClick={() => setShowDate(!showDate)}>
                  <span className="text-[10px] font-bold text-gray-600">Show Date</span>
                  <div className={`w-8 h-4 rounded-full p-0.5 transition-colors ${showDate ? 'bg-blue-500' : 'bg-gray-300'}`}>
                    <div className={`w-3 h-3 bg-white rounded-full shadow-sm transition-transform ${showDate ? 'translate-x-4' : ''}`} />
                  </div>
                </div>


                <div className="w-px h-6 bg-gray-200 mx-1" />

                {/* Transparency Toggles */}
                <div className="flex bg-gray-100 p-1 rounded-lg gap-1 relative">
                  <div
                    className="absolute bg-white shadow-sm rounded-md transition-all duration-300 ease-out z-0"
                    style={{
                      width: 'calc(33.33% - 4px)',
                      height: 'calc(100% - 8px)',
                      top: '4px',
                      left: isGlassy === 'solid' ? '4px' : (isGlassy === 'glass' ? 'calc(33.33% + 2px)' : 'calc(66.66%)')
                    }}
                  />
                  <button onClick={() => setIsGlassy && setIsGlassy('solid')} className={`text-[10px] font-bold px-2 py-1 rounded transition-all relative z-10 w-full ${isGlassy === 'solid' ? 'text-slate-800' : 'text-slate-400 hover:text-slate-600'}`}>Solid</button>
                  <button onClick={() => setIsGlassy && setIsGlassy('glass')} className={`text-[10px] font-bold px-2 py-1 rounded transition-all relative z-10 w-full ${isGlassy === 'glass' ? 'text-slate-800' : 'text-slate-400 hover:text-slate-600'}`}>Glass</button>
                  <button onClick={() => setIsGlassy && setIsGlassy('clear')} className={`text-[10px] font-bold px-2 py-1 rounded transition-all relative z-10 w-full ${isGlassy === 'clear' || !isGlassy ? 'text-slate-800' : 'text-slate-400 hover:text-slate-600'}`}>Clear</button>
                </div>
              </div>

              <div className="grid grid-cols-3 gap-3">
                {CLOCK_STYLES.map(style => (
                  <div
                    key={style.id}
                    onClick={() => setClockStyle(style.id)}
                    className={`cursor-pointer rounded-xl border-2 p-2 flex flex-col items-center justify-center gap-2 transition-all hover:bg-white
                               ${clockStyle === style.id ? 'border-blue-600 bg-blue-50/30' : 'border-slate-200 text-slate-500 hover:border-slate-300'}
                           `}
                  >
                    <div className="w-16 h-16 flex items-center justify-center pointer-events-none transform scale-90">
                      <ClockPreview style={style.id} />
                    </div>
                    <span className="text-[9px] font-bold uppercase tracking-wider truncate w-full text-center text-slate-600">{style.name}</span>
                  </div>
                ))}
              </div>
            </div>


          </div>

          <div className="p-1">
            {/* Custom / My Backgrounds */}
            {myBackgrounds.length > 0 && (
              <>
                <div className="text-xs font-bold text-gray-500 uppercase mb-2">My Backgrounds</div>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                  {myBackgrounds.map(bg => (
                    <button key={bg.id} onClick={() => { onSelect(bg, applyToAll ? 'all' : 'single'); }} className={`relative group rounded-xl overflow-hidden aspect-video border-2 transition-all active:scale-95 shadow-sm hover:shadow-md ${currentBg?.id === bg.id ? 'border-purple-600 ring-2 ring-purple-100' : 'border-transparent hover:border-gray-200'}`}>
                      <img src={bg.src} alt={bg.name} className="w-full h-full object-cover" />
                      <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                        <span className="text-white font-bold tracking-wide shadow-sm truncate px-2">{bg.name}</span>
                      </div>
                      {currentBg?.id === bg.id && <div className="absolute top-2 left-2 bg-purple-600 text-white p-1 rounded-full shadow-lg"><Check size={12} /></div>}
                      <div onClick={(e) => onDeleteCustomClick(e, bg.id)} className="absolute top-1 right-1 bg-white/90 text-red-500 p-1.5 rounded-full opacity-0 group-hover:opacity-100 hover:bg-red-50 transition-all shadow-md border border-red-100 z-20" title="Delete"><Trash2 size={14} /></div>
                    </button>
                  ))}
                </div>
              </>
            )}

            <div className="text-xs font-bold text-gray-500 uppercase mb-2 flex items-center justify-between">
              <span>Background Presets</span>
              <div className="flex items-center gap-2 cursor-pointer bg-gray-50 hover:bg-gray-100 px-2 py-1 rounded-lg transition-colors border border-gray-200" onClick={() => onToggleGrid(!isGridEnabled)}>
                <span className="text-[10px] font-bold text-gray-600">Snap to Grid</span>
                <div className={`w-7 h-3.5 rounded-full p-0.5 transition-colors ${isGridEnabled ? 'bg-indigo-500' : 'bg-gray-300'}`}>
                  <div className={`w-2.5 h-2.5 bg-white rounded-full shadow-sm transition-transform ${isGridEnabled ? 'translate-x-3.5' : ''}`} />
                </div>
              </div>
            </div>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
              {BACKGROUNDS.map(bg => (
                <button key={bg.id} onClick={() => { onSelect(bg, applyToAll ? 'all' : 'single'); }} className={`relative group rounded-xl overflow-hidden aspect-video border-2 transition-all active:scale-95 shadow-sm hover:shadow-md ${currentBg?.id === bg.id ? 'border-purple-600 ring-2 ring-purple-100' : 'border-transparent hover:border-gray-200'}`}>
                  {bg.id === 'default' ? (
                    <div className="w-full h-full">
                      <svg className="w-full h-full" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                          <linearGradient id="thumbGradOrange" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style={{ stopColor: "#fb923c", stopOpacity: 1 }} /><stop offset="100%" style={{ stopColor: "#ea580c", stopOpacity: 1 }} /></linearGradient>
                          <linearGradient id="thumbGradBlue" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style={{ stopColor: "#3b82f6", stopOpacity: 1 }} /><stop offset="100%" style={{ stopColor: "#60a5fa", stopOpacity: 1 }} /></linearGradient>
                        </defs>
                        <rect width="100%" height="100%" fill="#dbeafe" />
                        <path d="M1920 0V900C1400 900 1000 400 500 0H1920Z" fill="url(#thumbGradOrange)" />
                        <path d="M1920 0V700C1600 700 1300 300 900 0H1920Z" fill="#fed7aa" />
                        <path d="M0 1080V300C500 300 900 800 1600 1080H0Z" fill="url(#thumbGradBlue)" />
                        <path d="M0 1080V500C300 500 700 900 1200 1080H0Z" fill="#93c5fd" />
                      </svg>
                    </div>
                  ) : bg.type === 'preset' ? (
                    <div className={`w-full h-full ${bg.preview}`}></div>
                  ) : (
                    <img src={bg.src} alt={bg.name} className="w-full h-full object-cover" />
                  )}
                  <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                    <span className="text-white font-bold tracking-wide shadow-sm">{bg.name}</span>
                  </div>
                  {currentBg?.id === bg.id && <div className="absolute top-2 right-2 bg-purple-600 text-white p-1 rounded-full shadow-lg"><Check size={12} /></div>}
                </button>
              ))}
            </div>

            <div className="text-xs font-bold text-gray-500 uppercase mb-2">Upload Custom Background</div>
            <div
              className={`relative border-2 border-dashed rounded-xl p-4 transition-all flex items-center justify-between gap-3 cursor-pointer group hover:border-blue-400 hover:bg-blue-50 ${dragActive ? 'border-blue-500 bg-blue-50 scale-[1.02]' : 'border-gray-300 bg-gray-50'}`}
              onDragEnter={handleDrag}
              onDragLeave={handleDrag}
              onDragOver={handleDrag}
              onDrop={handleDrop}
              onClick={() => fileInputRef.current?.click()}
            >
              <input ref={fileInputRef} type="file" accept="image/*" className="hidden" onChange={(e) => e.target.files && handleFile(e.target.files[0])} />
              <div className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors shrink-0 ${dragActive ? 'bg-blue-500 text-white' : 'bg-white text-blue-500 shadow-sm group-hover:scale-110'}`}>
                {dragActive ? <Download size={20} className="animate-bounce" /> : <UploadCloud size={20} />}
              </div>
              <div className="flex-1 text-left">
                <p className="text-gray-700 font-bold mb-1">
                  <span className="text-blue-600 hover:underline">Click to upload</span> or drag and drop
                </p>
                <p className="text-xs text-gray-400">SVG, PNG, JPG or GIF</p>
              </div>
              <div className="absolute top-2 right-2 flex gap-1">
                <div className="bg-white/80 backdrop-blur px-2 py-1 rounded text-[10px] font-bold text-gray-400 uppercase border border-gray-200">Paste Supported</div>
              </div>
            </div>

            <div className="mt-6 flex items-center justify-between bg-gray-50 p-3 rounded-xl border border-gray-100">
              <div className="flex items-center gap-2">
                <div className={`w-10 h-6 rounded-full p-1 cursor-pointer transition-colors ${applyToAll ? 'bg-blue-500' : 'bg-gray-300'}`} onClick={() => setApplyToAll(!applyToAll)}>
                  <div className={`w-4 h-4 bg-white rounded-full shadow-sm transition-transform ${applyToAll ? 'translate-x-4' : ''}`} />
                </div>
                <div className="flex flex-col">
                  <span className="text-sm font-bold text-gray-700">Apply to all slides</span>
                  <span className="text-[10px] text-gray-400">If unchecked, background only applies to current slide</span>
                </div>
              </div>
              {/* Fallback URL Input */}
              <div className="flex items-center gap-2">
                <span className="text-xs font-bold text-gray-400 uppercase">OR URL:</span>
                <input
                  type="text"
                  placeholder="Paste URL..."
                  className="border border-gray-300 rounded-lg px-2 py-1 text-xs w-32 outline-none focus:border-blue-500"
                  value={customUrl}
                  onChange={(e) => setCustomUrl(e.target.value)}
                  onClick={(e) => e.stopPropagation()}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && customUrl) {
                      const newBg = { id: 'custom-url-' + Date.now(), name: 'Custom URL', type: 'image', src: customUrl, textColor: 'text-white' };
                      onAddCustom(newBg);
                      onSelect(newBg, applyToAll ? 'all' : 'single');
                    }
                  }}
                />
                {customUrl && (
                  <button onClick={() => {
                    const newBg = { id: 'custom-url-' + Date.now(), name: 'Custom URL', type: 'image', src: customUrl, textColor: 'text-white' };
                    onAddCustom(newBg);
                    onSelect(newBg, applyToAll ? 'all' : 'single');
                  }} className="p-1 bg-blue-500 text-white rounded hover:bg-blue-600"><Check size={14} /></button>
                )}
              </div>
            </div>
          </div>
        </div >
      );
    };

    const SettingsModal = ({ onClose, onSave, downloadData, roster, allRosters, activeRosterId, onSetActiveRoster, onAddRoster, onDeleteRoster, onRenameRoster, fileInputRef, initialTab = 'appearance', isGridEnabled, onToggleGrid, currentBg, onBgSelect, myBackgrounds, onAddCustomBg, onDeleteCustomBg, clockStyle, setClockStyle, showClockDate, setShowClockDate, isClockGlassy, setIsClockGlassy, backupEnabled, setBackupEnabled, backupInterval, setBackupInterval }) => {
      const [activeTab, setActiveTab] = useState(initialTab);
      const [mode, setMode] = useState('list');

      const [localRoster, setLocalRoster] = useState(roster || []);
      const [bulkText, setBulkText] = useState((roster || []).map(s => s.name).join('\n'));

      // Roster Management State
      const [isAddingRoster, setIsAddingRoster] = useState(false);
      const [newRosterName, setNewRosterName] = useState('');
      const [newRosterBulk, setNewRosterBulk] = useState('');
      const [editingRosterId, setEditingRosterId] = useState(null);
      const [editRosterName, setEditRosterName] = useState('');
      const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);

      // Feedback form state
      const [feedbackName, setFeedbackName] = useState('');
      const [feedbackEmail, setFeedbackEmail] = useState('');
      const [feedbackMessage, setFeedbackMessage] = useState('');
      const [feedbackCopied, setFeedbackCopied] = useState(false);

      const toggleActive = (id) => {
        setLocalRoster(prev => prev.map(s => s.id === id ? { ...s, active: !s.active } : s));
      };

      const handleBulkSave = () => {
        const lines = bulkText.split('\n').map(n => n.trim()).filter(n => n);
        const newRoster = lines.map(name => {
          const existing = roster.find(s => s.name === name);
          return existing ? existing : { id: Math.random().toString(36).substr(2, 9), name: name, active: true };
        });
        setLocalRoster(newRoster);
        setMode('list');
      };

      const handleSaveAll = () => {
        if (activeTab === 'roster' && mode === 'bulk') {
          const lines = bulkText.split('\n').map(n => n.trim()).filter(n => n);
          const newRoster = lines.map(name => {
            const existing = roster.find(s => s.name === name);
            return existing ? existing : { id: Math.random().toString(36).substr(2, 9), name: name, active: true };
          });
          onSave(newRoster);
        } else {
          onSave(localRoster);
        }
        onClose();
      };

      const [feedbackStatus, setFeedbackStatus] = useState('');

      const handleFeedbackSubmit = () => {
        const subject = encodeURIComponent('HomeRoom Feedback');
        const body = encodeURIComponent(`Name: ${feedbackName}\nEmail: ${feedbackEmail}\n\nMessage:\n${feedbackMessage}`);
        window.location.href = `mailto:jeffhennigar@gmail.com?subject=${subject}&body=${body}`;
        setFeedbackName(''); setFeedbackEmail(''); setFeedbackMessage('');
        setFeedbackStatus('Opening email client...');
        setTimeout(() => setFeedbackStatus(''), 3000);
      };

      const handleGmailSubmit = () => {
        const subject = encodeURIComponent(`Feedback from ${feedbackName || 'User'}`);
        const body = encodeURIComponent(`${feedbackMessage}\n\nFrom: ${feedbackName}\nEmail: ${feedbackEmail}`);
        const gmailUrl = `https://mail.google.com/mail/?view=cm&fs=1&to=jeffhennigar@gmail.com&su=${subject}&body=${body}`;
        window.open(gmailUrl, '_blank');
        setFeedbackName(''); setFeedbackEmail(''); setFeedbackMessage('');
        setFeedbackStatus('Opening Gmail...');
        setTimeout(() => setFeedbackStatus(''), 3000);
      };

      const handleCopyFeedback = () => {
        const text = `To: jeffhennigar@gmail.com\nSubject: HomeRoom Feedback\n\nName: ${feedbackName}\nEmail: ${feedbackEmail}\n\nMessage:\n${feedbackMessage}`;
        navigator.clipboard.writeText(text).then(() => {
          setFeedbackCopied(true);
          setFeedbackStatus('Copied to clipboard!');
          setTimeout(() => { setFeedbackCopied(false); setFeedbackStatus(''); }, 3000);
        });
      };

      // Schedule template state
      const [scheduleTemplate, setScheduleTemplate] = useState(getScheduleTemplate());
      const [selectedDay, setSelectedDay] = useState('Monday');
      const [settingsEmojiPickerIndex, setSettingsEmojiPickerIndex] = useState(null);
      const [showCopyMenu, setShowCopyMenu] = useState(false);
      const [copyStatus, setCopyStatus] = useState('');
      const [copyTargetDays, setCopyTargetDays] = useState([]);

      const [showRosterMenu, setShowRosterMenu] = useState(false); // Item 13 Custom Dropdown State
      const [settingsTimePickerState, setSettingsTimePickerState] = useState({ index: null, triggerRef: null });

      const copyScheduleDays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].filter(d => d !== selectedDay);

      const handleBatchCopy = () => {
        if (copyTargetDays.length === 0) return;
        setScheduleTemplate(prev => {
          const next = { ...prev };
          const sourceItems = prev[selectedDay] || [];
          copyTargetDays.forEach(day => {
            next[day] = JSON.parse(JSON.stringify(sourceItems));
          });
          return next;
        });
        setCopyStatus(`Copied to ${copyTargetDays.length} days!`);
        setTimeout(() => setCopyStatus(''), 2000);
        setShowCopyMenu(false);
        setCopyTargetDays([]);
      };

      const toggleCopyDay = (day) => {
        setCopyTargetDays(prev => prev.includes(day) ? prev.filter(d => d !== day) : [...prev, day]);
      };

      const addScheduleItem = (day) => {
        const newItem = { id: Date.now().toString(), time: '09:00', emoji: 'ðŸ“š', title: 'New Activity', description: '' };
        setScheduleTemplate(prev => ({ ...prev, [day]: [...(prev[day] || []), newItem] }));
      };

      const updateScheduleItem = (day, index, field, value) => {
        setScheduleTemplate(prev => {
          const items = [...(prev[day] || [])];
          items[index] = { ...items[index], [field]: value };
          return { ...prev, [day]: items };
        });
      };

      const removeScheduleItem = (day, index) => {
        setScheduleTemplate(prev => ({ ...prev, [day]: prev[day].filter((_, i) => i !== index) }));
      };

      // Auto-save Schedule Template
      useEffect(() => {
        saveScheduleTemplate(scheduleTemplate);
      }, [scheduleTemplate]);

      // Sync local roster when active roster changes
      useEffect(() => {
        setLocalRoster(roster || []);
        setBulkText((roster || []).map(s => s.name).join('\n'));
      }, [roster]);

      const tabs = [
        { id: 'appearance', label: 'Appearance', icon: <ImageIcon size={16} /> },
        { id: 'roster', label: 'Rosters', icon: <User size={16} /> },
        { id: 'schedule', label: 'Schedule', icon: <Calendar size={16} /> },
        { id: 'data', label: 'Data', icon: <Download size={16} /> },
        { id: 'about', label: 'About', icon: <Info size={16} /> },
        { id: 'feedback', label: 'Feedback', icon: <Mail size={16} /> }
      ];

      return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
          <div className="bg-white rounded-2xl shadow-2xl w-[600px] h-[600px] flex flex-col overflow-hidden relative">
            {/* Header with Tabs */}
            <div className="border-b">
              <div className="p-4 flex justify-between items-center">
                <h3 className="font-bold text-gray-800 flex items-center gap-2"><Settings size={20} /> Settings</h3>
                <button onClick={onClose} className="p-2 hover:bg-gray-200 rounded-full text-gray-500"><X size={20} /></button>
              </div>
              <div className="flex px-2 pb-0">
                {tabs.map(tab => (
                  <button
                    key={tab.id}
                    onClick={() => setActiveTab(tab.id)}
                    className={`flex items-center gap-1.5 px-3 py-2 text-xs font-bold transition-all border-b-2 ${activeTab === tab.id ? 'text-blue-600 border-blue-600' : 'text-gray-500 border-transparent hover:text-gray-700 hover:bg-gray-50'}`}
                  >
                    {tab.icon} {tab.label}
                  </button>
                ))}
              </div>
            </div>

            {/* Tab Content */}
            <div className="flex-1 overflow-y-auto custom-scrollbar">
              {/* GENERAL TAB */}


              {/* ROSTER TAB */}
              {activeTab === 'roster' && (
                <div className="p-4">
                  <div className="mb-6 space-y-4">
                    <div className="flex-1">
                      <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Active Roster</label>
                      <div className="flex gap-2">
                        {/* Custom Dropdown (Item 13) */}
                        <div className="relative flex-1">
                          <button onClick={() => setShowRosterMenu(!showRosterMenu)} className="w-full flex justify-between items-center border border-gray-200 rounded-lg px-3 py-2 text-sm bg-white hover:bg-gray-50 transition-colors focus:ring-2 focus:ring-purple-500 shadow-sm">
                            <span className="font-bold text-gray-700 truncate mr-2">{allRosters.find(r => r.id === activeRosterId)?.name || 'Select Class'}</span>
                            <ChevronDown size={16} className={`text-gray-400 transition-transform ${showRosterMenu ? 'rotate-180' : ''}`} />
                          </button>
                          {showRosterMenu && (
                            <div className="absolute top-full left-0 right-0 mt-1 bg-white border border-gray-100 rounded-xl shadow-xl py-1 z-50 animate-in fade-in zoom-in-95 duration-200 max-h-48 overflow-y-auto custom-scrollbar">
                              {allRosters.map(r => (
                                <button key={r.id} onClick={() => { onSetActiveRoster(r.id); setShowRosterMenu(false); }} className={`w-full text-left px-4 py-2 text-sm font-bold hover:bg-purple-50 transition-colors flex justify-between items-center ${activeRosterId === r.id ? 'text-purple-700 bg-purple-50' : 'text-gray-600'}`}>
                                  <span className="truncate">{r.name}</span>
                                  {activeRosterId === r.id && <Check size={14} className="flex-shrink-0 ml-2" />}
                                </button>
                              ))}
                            </div>
                          )}
                        </div>
                        <button onClick={() => { setIsAddingRoster(true); setNewRosterName(''); setNewRosterBulk(''); }} className="p-2 bg-purple-100 text-purple-600 rounded-lg hover:bg-purple-200" title="Add New Roster"><Plus size={18} /></button>
                        <button onClick={() => {
                          const r = allRosters.find(r => r.id === activeRosterId);
                          setEditingRosterId(activeRosterId);
                          setEditRosterName(r?.name || '');
                        }} className="p-2 border border-gray-200 text-gray-400 rounded-lg hover:bg-gray-50" title="Rename Roster"><Edit3 size={16} /></button>
                        {allRosters.length > 1 && (
                          <button onClick={(e) => {
                            e.stopPropagation();
                            setShowDeleteConfirm(true);
                          }} className="p-2 border border-red-100 text-red-500 rounded-lg hover:bg-red-50" title="Delete Roster"><Trash2 size={16} /></button>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* Add Roster Modal Overlay */}
                  {isAddingRoster && (
                    <div className="absolute inset-0 bg-white/95 z-10 flex flex-col p-6 animate-in fade-in zoom-in-95 duration-200">
                      <h3 className="text-lg font-bold text-gray-800 mb-4">Create New Class</h3>
                      <div className="space-y-4 flex-1">
                        <div>
                          <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Class Name</label>
                          <input autoFocus type="text" value={newRosterName} onChange={e => setNewRosterName(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-purple-500 font-bold text-gray-700" placeholder="e.g., Period 2 - Science" />
                        </div>
                        <div className="flex-1 flex flex-col">
                          <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Students (Paste list)</label>
                          <textarea value={newRosterBulk} onChange={e => setNewRosterBulk(e.target.value)} className="flex-1 border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-purple-500 resize-none custom-scrollbar" placeholder="Paste names here..." style={{ minHeight: '200px' }} />
                        </div>
                        <div className="flex gap-2 justify-end pt-2">
                          <button onClick={() => setIsAddingRoster(false)} className="px-4 py-2 text-gray-500 font-bold hover:bg-gray-100 rounded-lg">Cancel</button>
                          <button disabled={!newRosterName.trim()} onClick={() => {
                            onAddRoster(newRosterName, newRosterBulk);
                            setIsAddingRoster(false);
                          }} className="px-6 py-2 bg-purple-600 text-white font-bold rounded-lg hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed">Create Class</button>
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Rename Roster Overlay */}
                  {editingRosterId && (
                    <div className="absolute inset-0 bg-white/95 z-10 flex flex-col p-6 animate-in fade-in zoom-in-95 duration-200 justify-center items-center">
                      <div className="w-full max-w-sm space-y-4">
                        <h3 className="text-lg font-bold text-gray-800 text-center">Rename Class</h3>
                        <input autoFocus type="text" value={editRosterName} onChange={e => setEditRosterName(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-blue-500 font-bold text-gray-700 text-center" />
                        <div className="flex gap-2 justify-center">
                          <button onClick={() => setEditingRosterId(null)} className="px-4 py-2 text-gray-500 font-bold hover:bg-gray-100 rounded-lg">Cancel</button>
                          <button onClick={() => {
                            onRenameRoster(editingRosterId, editRosterName);
                            setEditingRosterId(null);
                          }} className="px-6 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700">Save Name</button>
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Delete Roster Confirmation Modal */}
                  {showDeleteConfirm && (
                    <div className="absolute inset-0 bg-black/50 z-20 flex items-center justify-center animate-in fade-in duration-200">
                      <div className="bg-white rounded-2xl p-6 shadow-2xl max-w-sm mx-4 animate-in zoom-in-95 duration-200">
                        <div className="text-center mb-4">
                          <div className="w-12 h-12 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-3">
                            <Trash2 size={24} className="text-red-500" />
                          </div>
                          <h3 className="text-lg font-bold text-gray-800">Delete Roster?</h3>
                          <p className="text-gray-500 text-sm mt-1">This will permanently delete "{allRosters.find(r => r.id === activeRosterId)?.name}" and all its students.</p>
                        </div>
                        <div className="flex gap-3">
                          <button onClick={() => setShowDeleteConfirm(false)} className="flex-1 px-4 py-2 text-gray-600 font-bold hover:bg-gray-100 rounded-lg transition-colors">Cancel</button>
                          <button onClick={() => {
                            onDeleteRoster(activeRosterId);
                            setShowDeleteConfirm(false);
                          }} className="flex-1 px-4 py-2 bg-red-500 text-white font-bold rounded-lg hover:bg-red-600 transition-colors">Delete</button>
                        </div>
                      </div>
                    </div>
                  )}

                  <div className="flex items-center justify-between mb-4 bg-gray-50 p-2 rounded-xl">
                    <div className="text-sm font-bold text-gray-700 px-2">{localRoster.length} Students</div>
                    <div className="flex gap-1">
                      <button onClick={() => {
                        const lines = bulkText.split('\n').map(n => n.trim()).filter(n => n);
                        const newRoster = lines.map(name => {
                          const existing = (roster || []).find(s => s.name === name);
                          return existing ? existing : { id: Math.random().toString(36).substr(2, 9), name: name, active: true };
                        });
                        setLocalRoster(newRoster);
                        setMode('list');
                      }} className={`px-2.5 py-1.5 rounded-lg text-xs font-bold transition-all ${mode === 'list' ? 'bg-white shadow text-purple-600' : 'text-gray-500'}`}>List</button>
                      <button onClick={() => {
                        setBulkText(localRoster.map(s => s.name).join('\n'));
                        setMode('bulk');
                      }} className={`px-2.5 py-1.5 rounded-lg text-xs font-bold transition-all ${mode === 'bulk' ? 'bg-white shadow text-purple-600' : 'text-gray-500'}`}>Bulk Add</button>
                    </div>
                  </div>

                  <>
                    {mode === 'list' ? (
                      <div className="p-4">
                        <div className="space-y-1">
                          {localRoster.map(s => (
                            <div key={s.id} className={`flex items-center justify-between p-2 rounded border group ${s.active ? 'bg-white border-gray-100 hover:border-blue-300' : 'bg-gray-50 border-transparent opacity-60'}`}>
                              <div className="flex items-center gap-3 cursor-pointer flex-1" onClick={() => toggleActive(s.id)}>
                                <div className={`w-4 h-4 rounded border flex items-center justify-center ${s.active ? 'bg-blue-500 border-blue-500' : 'border-gray-400 bg-white'}`}>
                                  {s.active && <Check size={12} className="text-white" />}
                                </div>
                                <span className={`font-medium ${s.active ? 'text-gray-900' : 'text-gray-500 line-through'}`}>{s.name}</span>
                              </div>
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  if (window.confirm(`Delete ${s.name} from the roster?`)) {
                                    const newRoster = localRoster.filter(student => student.id !== s.id);
                                    setLocalRoster(newRoster);
                                    // Also sync back to bulk text if in that mode
                                    if (mode === 'bulk') setBulkText(newRoster.map(sn => sn.name).join('\n'));
                                  }
                                }}
                                className="p-1.5 text-red-400 hover:text-red-600 rounded-lg hover:bg-red-50 opacity-0 group-hover:opacity-100 transition-all"
                                title="Delete Student"
                              >
                                <Trash2 size={14} />
                              </button>
                            </div>
                          ))}
                          {localRoster.length === 0 && <div className="text-center text-gray-400 py-8 px-4 bg-gray-50 rounded-xl my-4 border border-dashed border-gray-200">No students yet. Click Bulk Add to add your class.</div>}
                        </div>
                      </div>
                    ) : (
                      <div className="p-4 flex flex-col">
                        <label className="text-xs font-bold text-gray-500 uppercase mb-2">Edit Names (One per line)</label>
                        <textarea
                          className="border-2 border-gray-200 rounded-xl p-4 outline-none focus:border-blue-500 focus:ring-4 focus:ring-blue-50 transition-all custom-scrollbar resize-none font-medium text-slate-700"
                          rows={7}
                          autoFocus
                          value={bulkText}
                          onChange={e => setBulkText(e.target.value)}
                        />
                        {/* Update button removed per user request - handled by Save All */}
                      </div>
                    )}
                  </>
                </div>
              )}

              {/* APPEARANCE TAB */}
              {activeTab === 'appearance' && (
                <AppearanceSettings
                  currentBg={currentBg}
                  onSelect={onBgSelect}
                  isGridEnabled={isGridEnabled}
                  onToggleGrid={onToggleGrid}
                  myBackgrounds={myBackgrounds}
                  onAddCustom={onAddCustomBg}
                  onDeleteCustom={onDeleteCustomBg}
                  clockStyle={clockStyle}
                  setClockStyle={setClockStyle}
                  showDate={showClockDate}
                  setShowDate={setShowClockDate}
                  isGlassy={isClockGlassy}
                  setIsGlassy={setIsClockGlassy}
                />
              )}

              {/* SCHEDULE TAB */}
              {activeTab === 'schedule' && (
                <div className="p-4">
                  <p className="text-gray-600 text-sm mb-4">Set up your weekly schedule template. Each day's activities will load automatically when you open the Schedule widget.</p>

                  {/* Day Selector */}
                  <div className="flex gap-2 mb-4 items-start">
                    <div className="flex-1 flex gap-1 overflow-x-auto pb-2 custom-scrollbar">
                      {['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].map(day => (
                        <button
                          key={day}
                          onClick={() => setSelectedDay(day)}
                          className={`px-3 py-1.5 text-xs font-bold rounded-lg transition-colors whitespace-nowrap ${selectedDay === day ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                        >
                          {day.slice(0, 3)}
                        </button>
                      ))}
                    </div>
                    <div className="relative shrink-0 pt-0.5">
                      <button onClick={() => setShowCopyMenu(!showCopyMenu)} className="px-3 py-1.5 text-xs font-bold rounded-lg bg-blue-100 text-blue-600 hover:bg-blue-200 flex items-center gap-1"><Copy size={12} /> Copy...</button>
                      {showCopyMenu && (
                        <div className="absolute top-full right-0 mt-1 bg-white rounded-lg shadow-xl border border-gray-200 z-50 w-48 overflow-hidden flex flex-col">
                          <div className="px-3 py-2 text-[10px] font-bold text-gray-400 uppercase bg-gray-50 border-b">Copy {selectedDay} to:</div>
                          <div className="max-h-48 overflow-y-auto custom-scrollbar p-1">
                            {copyScheduleDays.map(d => (
                              <label key={d} className="flex items-center gap-2 w-full text-left px-2 py-1.5 text-xs hover:bg-blue-50 text-gray-700 font-medium rounded cursor-pointer">
                                <input
                                  type="checkbox"
                                  checked={copyTargetDays.includes(d)}
                                  onChange={() => toggleCopyDay(d)}
                                  className="w-3.5 h-3.5 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                                />
                                {d}
                              </label>
                            ))}
                          </div>
                          <div className="p-2 border-t bg-gray-50">
                            <button
                              onClick={handleBatchCopy}
                              disabled={copyTargetDays.length === 0}
                              className="w-full bg-blue-600 text-white rounded py-1 text-xs font-bold hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                              Copy ({copyTargetDays.length})
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                  {copyStatus && <span className="text-xs text-green-600 font-bold block mb-2 animate-pulse">{copyStatus}</span>}

                  {/* Activities for selected day */}
                  <div className="space-y-2 max-h-60 overflow-y-auto custom-scrollbar">
                    {(scheduleTemplate[selectedDay] || []).map((item, index) => (
                      <div key={item.id} className="relative flex gap-2 p-2 bg-gray-50 rounded-lg border border-gray-200" style={{ zIndex: (settingsEmojiPickerIndex === index || settingsTimePickerState.index === index) ? 50 : 0 }}>
                        <div className="flex flex-col items-center shrink-0 w-20 relative">
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              setSettingsTimePickerState(settingsTimePickerState.index === index ? { index: null, triggerRef: null } : { index, triggerRef: { current: e.currentTarget } });
                            }}
                            className="w-full text-xs font-bold text-indigo-600 bg-white border border-indigo-100 px-1 py-1 rounded hover:bg-indigo-50"
                          >
                            {(() => {
                              const [h, m] = (item.time || '09:00').split(':');
                              const hours = parseInt(h);
                              const ampm = hours >= 12 ? 'PM' : 'AM';
                              const displayH = hours % 12 || 12;
                              return `${displayH}:${m} ${ampm}`;
                            })()}
                          </button>
                          {settingsTimePickerState.index === index && (
                            <TimePicker
                              time={item.time || '09:00'}
                              onChange={(t) => updateScheduleItem(selectedDay, index, 'time', t)}
                              onClose={() => setSettingsTimePickerState({ index: null, triggerRef: null })}
                              triggerRef={settingsTimePickerState.triggerRef}
                            />
                          )}
                        </div>
                        <div className="relative">
                          <div
                            className="text-lg cursor-pointer hover:scale-110 transition-transform p-1 rounded hover:bg-gray-200 emoji"
                            onClick={() => setSettingsEmojiPickerIndex(settingsEmojiPickerIndex === index ? null : index)}
                          >
                            {item.emoji || 'ðŸ“š'}
                          </div>
                          {settingsEmojiPickerIndex === index && (
                            <div className="absolute left-0 top-full mt-1 z-50 bg-white rounded-xl shadow-xl border border-gray-200 p-2 w-48 max-h-40 overflow-y-auto custom-scrollbar">
                              <div className="grid grid-cols-5 gap-1">
                                {SCHEDULE_EMOJIS.map((emoji, i) => (
                                  <button
                                    key={i}
                                    onClick={() => { updateScheduleItem(selectedDay, index, 'emoji', emoji); setSettingsEmojiPickerIndex(null); }}
                                    className={`text-xl p-1.5 rounded-lg hover:bg-indigo-100 transition-colors emoji ${item.emoji === emoji ? 'bg-indigo-200 ring-2 ring-indigo-400' : ''}`}
                                  >
                                    {emoji}
                                  </button>
                                ))}
                              </div>
                            </div>
                          )}
                        </div>
                        <div className="flex-1 min-w-0">
                          <input
                            type="text"
                            value={item.title || ''}
                            onChange={(e) => updateScheduleItem(selectedDay, index, 'title', e.target.value)}
                            className="w-full text-sm font-bold bg-transparent border-none outline-none"
                            placeholder="Activity name"
                          />
                          <input
                            type="text"
                            value={item.description || ''}
                            onChange={(e) => updateScheduleItem(selectedDay, index, 'description', e.target.value)}
                            className="w-full text-xs text-gray-500 bg-transparent border-none outline-none"
                            placeholder="Description (optional)"
                          />
                        </div>
                        <button onClick={() => removeScheduleItem(selectedDay, index)} className="p-1 text-red-400 hover:text-red-600 self-center"><X size={14} /></button>
                      </div>
                    ))}
                    {(scheduleTemplate[selectedDay] || []).length === 0 && (
                      <div className="text-center py-4 text-gray-400 text-sm">No activities for {selectedDay}</div>
                    )}
                  </div>

                  <div className="flex gap-2 mt-3">
                    <button onClick={() => addScheduleItem(selectedDay)} className="flex-1 py-2 bg-indigo-100 text-indigo-700 font-bold text-sm rounded-lg hover:bg-indigo-200 flex items-center justify-center gap-1">
                      <Plus size={16} /> Add Activity
                    </button>
                  </div>


                </div>
              )}

              {/* ABOUT TAB */}
              {activeTab === 'about' && (
                <div className="p-6">
                  <div className="flex flex-col items-center mb-6">
                    <img src="https://raw.githubusercontent.com/jeffhennigar/homeroom/main/effortless_edtech_logo.png" alt="Effortless EdTech" className="w-24 h-24 rounded-full bg-white p-1 shadow-lg mb-3 object-contain" />
                    <h2 className="text-lg font-bold text-gray-800">HomeRoom</h2>
                    <div className="px-2 py-0.5 bg-blue-100 text-blue-700 text-[10px] font-bold rounded-full mb-2 tracking-widest uppercase">Version 1.0</div>
                    <p className="text-gray-500 text-sm text-center">A classroom management tool by <span className="font-semibold text-teal-600">Effortless EdTech</span></p>
                  </div>
                  <div className="space-y-2">
                    <a href="mailto:jeffhennigar@gmail.com" className="flex items-center gap-3 p-3 bg-gray-50 hover:bg-blue-50 rounded-xl transition-colors group">
                      <div className="p-2 bg-blue-100 rounded-lg text-blue-600"><Mail size={16} /></div>
                      <div><div className="text-xs text-gray-400">Contact</div><div className="text-sm font-semibold text-gray-700 group-hover:text-blue-600">jeffhennigar@gmail.com</div></div>
                    </a>
                    <a href="https://www.teacherspayteachers.com/store/effortless-edtech" target="_blank" rel="noopener noreferrer" className="flex items-center gap-3 p-3 bg-gray-50 hover:bg-green-50 rounded-xl transition-colors group">
                      <div className="p-2 bg-green-100 rounded-lg text-green-600"><ExternalLink size={16} /></div>
                      <div><div className="text-xs text-gray-400">Teachers Pay Teachers</div><div className="text-sm font-semibold text-gray-700 group-hover:text-green-600">Visit Store &rarr;</div></div>
                    </a>
                    <a href="https://www.etsy.com/shop/EffortlessEdtech" target="_blank" rel="noopener noreferrer" className="flex items-center gap-3 p-3 bg-gray-50 hover:bg-orange-50 rounded-xl transition-colors group">
                      <div className="p-2 bg-orange-100 rounded-lg text-orange-600"><ExternalLink size={16} /></div>
                      <div><div className="text-xs text-gray-400">Etsy Shop</div><div className="text-sm font-semibold text-gray-700 group-hover:text-orange-600">Visit Store &rarr;</div></div>
                    </a>
                  </div>
                </div>
              )}

              {/* DATA TAB */}
              {activeTab === 'data' && (
                <div className="p-6">
                  <div className="mb-6 p-4 bg-blue-50 border border-blue-100 rounded-xl flex gap-3">
                    <div className="shrink-0 text-blue-500"><Info size={20} /></div>
                    <div className="text-sm text-blue-900">
                      <p className="font-bold mb-1">Your Data is Private & Local</p>
                      <p className="opacity-80 leading-relaxed">HomeRoom stores all your data directly on this computer's browser. Nothing is sent to the cloud. Please <strong>backup your data regularly</strong> to keep it safe!</p>
                    </div>
                  </div>
                  <div className="space-y-3">
                    <button onClick={downloadData} className="w-full flex items-center gap-3 p-4 bg-green-50 hover:bg-green-100 rounded-xl transition-colors group border border-green-200">
                      <div className="p-3 bg-green-500 rounded-xl text-white"><Download size={20} /></div>
                      <div className="text-left">
                        <div className="font-bold text-gray-800">Export Data</div>
                        <div className="text-xs text-gray-500">Download roster, widgets, and settings</div>
                      </div>
                    </button>
                    <button onClick={() => fileInputRef.current.click()} className="w-full flex items-center gap-3 p-4 bg-blue-50 hover:bg-blue-100 rounded-xl transition-colors group border border-blue-200">
                      <div className="p-3 bg-blue-500 rounded-xl text-white"><Upload size={20} /></div>
                      <div className="text-left">
                        <div className="font-bold text-gray-800">Import Data</div>
                        <div className="text-xs text-gray-500">Restore from a backup file</div>
                      </div>
                    </button>
                  </div>

                  {/* Backup Settings */}
                  <div className="mt-6 border-t pt-6">
                    <h4 className="text-sm font-bold text-gray-700 mb-3 uppercase tracking-wide">Backup Reminders</h4>
                    <div className="flex flex-col gap-3">
                      <div className="flex items-center justify-between p-3 bg-gray-50 rounded-xl border border-gray-100">
                        <div className="flex items-center gap-2">
                          <div className={`p-2 rounded-lg ${backupEnabled ? 'bg-indigo-100 text-indigo-600' : 'bg-gray-200 text-gray-500'}`}><Bell size={18} /></div>
                          <div>
                            <div className="font-bold text-sm text-gray-800">Backup Reminders</div>
                            <div className="text-[10px] text-gray-500">Show a prompt to backup your data</div>
                          </div>
                        </div>
                        <button
                          onClick={() => setBackupEnabled(!backupEnabled)}
                          className={`relative w-12 h-7 rounded-full transition-colors ${backupEnabled ? 'bg-indigo-500' : 'bg-gray-300'}`}
                        >
                          <div className={`absolute top-1 w-5 h-5 rounded-full bg-white shadow-sm transition-transform ${backupEnabled ? 'translate-x-6' : 'translate-x-1'}`} />
                        </button>
                      </div>

                      {backupEnabled && (
                        <div className="flex items-center justify-between p-3 bg-gray-50 rounded-xl border border-gray-100">
                          <div className="flex items-center gap-2">
                            <div className="p-2 bg-blue-100 text-blue-600 rounded-lg"><Clock size={18} /></div>
                            <div>
                              <div className="font-bold text-sm text-gray-800">Reminder Frequency</div>
                              <div className="text-[10px] text-gray-500">How often to remind you</div>
                            </div>
                          </div>
                          <div className="flex items-center gap-2">
                            <input
                              type="number"
                              min="1"
                              max="365"
                              value={backupInterval}
                              onChange={(e) => setBackupInterval(Math.max(1, parseInt(e.target.value) || 1))}
                              className="w-16 p-2 text-center font-bold border rounded-lg outline-none focus:border-indigo-500 border-gray-300"
                            />
                            <span className="text-sm font-bold text-gray-500">days</span>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              )}

              {/* FEEDBACK TAB */}
              {activeTab === 'feedback' && (
                <div className="p-6">
                  <p className="text-gray-600 text-sm mb-4">Have feedback or questions? Fill out this form and we'll get back to you!</p>
                  <div className="space-y-3">
                    <div>
                      <label className="text-xs font-bold text-gray-500 uppercase mb-1 block">Your Name</label>
                      <input type="text" value={feedbackName} onChange={e => setFeedbackName(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-blue-500 transition-colors" placeholder="Your name" />
                    </div>
                    <div>
                      <label className="text-xs font-bold text-gray-500 uppercase mb-1 block">Email</label>
                      <input type="email" value={feedbackEmail} onChange={e => setFeedbackEmail(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-blue-500 transition-colors" placeholder="you@school.edu" />
                    </div>
                    <div>
                      <label className="text-xs font-bold text-gray-500 uppercase mb-1 block">Message</label>
                      <textarea value={feedbackMessage} onChange={e => setFeedbackMessage(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-blue-500 transition-colors resize-none" rows={4} placeholder="Your feedback or question..." />
                    </div>

                    <div className="flex flex-col gap-2">
                      <button onClick={handleFeedbackSubmit} disabled={!feedbackMessage.trim()} className="w-full py-3 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-300 text-white font-bold rounded-xl transition-colors flex items-center justify-center gap-2">
                        <Mail size={18} /> Send via Email App
                      </button>

                      <div className="flex gap-2">
                        <button onClick={handleGmailSubmit} disabled={!feedbackMessage.trim()} className="flex-1 py-3 bg-red-100 hover:bg-red-200 disabled:bg-gray-100 disabled:text-gray-400 text-red-700 font-bold rounded-xl transition-colors flex items-center justify-center gap-2">
                          <Mail size={18} /> Send via Gmail
                        </button>
                        <button onClick={handleCopyFeedback} disabled={!feedbackMessage.trim()} className="flex-1 py-3 bg-gray-100 hover:bg-gray-200 disabled:bg-gray-50 disabled:text-gray-300 text-gray-700 font-bold rounded-xl transition-colors flex items-center justify-center gap-2">
                          {feedbackCopied ? <Check size={18} className="text-green-600" /> : <List size={18} />} {feedbackCopied ? 'Copied!' : 'Copy Text'}
                        </button>
                      </div>
                    </div>
                    <p className="text-[10px] text-gray-400 text-center mt-2">
                      If "Send" doesn't work, use "Copy Text" and paste it into your email manually to <b>jeffhennigar@gmail.com</b>
                    </p>
                    {feedbackStatus && <div className="text-center text-sm font-bold text-green-600 mt-2 bg-green-50 p-2 rounded-lg animate-in fade-in slide-in-from-bottom-2">{feedbackStatus}</div>}
                  </div>
                </div>
              )}
            </div>

            {/* Footer - only show save for roster tab */}
            {activeTab === 'roster' && (
              <div className="p-4 border-t bg-gray-50 flex justify-end gap-2">
                <button onClick={onClose} className="px-4 py-2 text-slate-500 font-bold hover:bg-slate-100 rounded-lg transition-colors">Cancel</button>
                <button onClick={handleSaveAll} className="px-6 py-2 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow transition-all active:scale-95 flex items-center gap-2">
                  <Save size={18} /> Save
                </button>
              </div>
            )}
          </div >
        </div >
      );
    };



    const CalendarWidget = ({ widget, updateData, selectedDate, onSelectDate, isGlassy }) => {
      const { width, height } = widget.size;
      const [viewDate, setViewDate] = useState(new Date());

      // Update view if selectedDate changes significantly (optional, maybe user wants to browse)
      // For now, let's keep view independent unless explicitly linked

      const onDayClick = (day) => {
        const newDate = new Date(viewDate.getFullYear(), viewDate.getMonth(), day);
        if (onSelectDate) onSelectDate(newDate);
      };

      const isSelected = (day) => {
        if (!selectedDate) return false;
        return day === selectedDate.getDate() &&
          viewDate.getMonth() === selectedDate.getMonth() &&
          viewDate.getFullYear() === selectedDate.getFullYear();
      };

      // Auto-scale font based on widget size
      const baseSize = Math.min(width, height);
      const dynamicFontSize = Math.max(10, baseSize / 18); // Tuned for optimal look

      const getDaysInMonth = (date) => new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
      const getFirstDayOfMonth = (date) => new Date(date.getFullYear(), date.getMonth(), 1).getDay();

      const changeMonth = (delta) => setViewDate(new Date(viewDate.getFullYear(), viewDate.getMonth() + delta, 1));

      const isToday = (day) => {
        const today = new Date();
        return day === today.getDate() &&
          viewDate.getMonth() === today.getMonth() &&
          viewDate.getFullYear() === today.getFullYear();
      };

      const daysInMonth = getDaysInMonth(viewDate);
      const firstDay = getFirstDayOfMonth(viewDate);
      const days = Array.from({ length: daysInMonth }, (_, i) => i + 1);
      const blanks = Array.from({ length: firstDay }, (_, i) => i);
      const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

      const preventSelectClass = "select-none cursor-default";

      return (
        <div className={`flex flex-col h-full relative p-4 group ${(!isGlassy || isGlassy === 'solid') ? 'bg-white rounded-xl' : ''} ${preventSelectClass}`} style={{ fontSize: `${dynamicFontSize}px`, cursor: 'move' }}>
          {/* Header */}
          <div className="flex justify-between items-center mb-2 shrink-0" onMouseDown={e => e.stopPropagation()}>
            <div className="flex items-center">
              <button onClick={() => changeMonth(-1)} onMouseDown={(e) => e.stopPropagation()} className="p-1 hover:bg-slate-100 rounded-full text-slate-400 hover:text-slate-600 transition-colors">
                <ChevronLeft size={20} />
              </button>
              <div className={`font-bold text-[1.1em] mx-1 whitespace-nowrap ${(!isGlassy || isGlassy === 'solid') ? 'text-slate-800' : 'text-slate-900 drop-shadow-sm'}`}>
                {monthNames[viewDate.getMonth()]} {viewDate.getFullYear()}
              </div>
              <button onClick={() => changeMonth(1)} onMouseDown={(e) => e.stopPropagation()} className="p-1 hover:bg-slate-100 rounded-full text-slate-400 hover:text-slate-600 transition-colors">
                <ChevronRight size={20} />
              </button>
            </div>
          </div>

          <div className="flex-1 flex flex-col min-h-0">
            <div className="grid grid-cols-7 mb-1 shrink-0">
              {['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'].map(d => (
                <div key={d} className={`text-center text-[0.7em] font-extrabold uppercase ${(!isGlassy || isGlassy === 'solid') ? 'text-slate-400' : 'text-slate-700'}`}>{d}</div>
              ))}
            </div>
            <div className="grid grid-cols-7 gap-1 flex-1 content-start overflow-hidden">
              {blanks.map(i => <div key={`blank-${i}`} />)}
              {days.map(d => (
                <div
                  key={d}
                  onClick={() => onDayClick(d)}
                  className={`aspect-square flex items-center justify-center rounded-full text-[0.9em] font-medium transition-all cursor-pointer
                        ${isSelected(d) ? 'bg-indigo-600 text-white ring-2 ring-indigo-200' : isToday(d) ? 'bg-blue-100 text-blue-700' : 'text-slate-600 hover:bg-slate-50'}`}
                >
                  {d}
                </div>
              ))}
            </div>
          </div>
        </div>
      );
    };

    const App = () => {
      const [allRosters, setAllRosters] = useState(() => {
        try {
          const stored = localStorage.getItem('homeroom_all_rosters');
          if (stored) return JSON.parse(stored);
        } catch (e) { }
        // Migration of single roster
        const defaultRoster = getRoster();
        const defaultSlides = (() => {
          try {
            let s = JSON.parse(localStorage.getItem(WIDGETS_STORAGE_KEY)) || [[]];
            // Ensure Clock is present in the first slide if not anywhere
            // Check first slide
            if (!s[0].some(w => w.type === 'CLOCK')) {
              const clockWidget = {
                id: 'default-clock-' + Date.now(),
                type: 'CLOCK',
                position: { x: 50, y: 40 }, // Top Left
                id: 'default-clock-' + Date.now(),
                type: 'CLOCK',
                position: { x: 50, y: 40 }, // Top Left
                size: { width: 340, height: 260 },
                zIndex: 100,
                zIndex: 100,
                data: { fontSize: 16 },
                isMinimized: false
              };
              s[0].push(clockWidget);
            }
            return s;
          } catch (e) { return [[]]; }
        })();
        return [{ id: 'default', name: 'My Class', roster: defaultRoster, slides: defaultSlides }];
      });

      const [activeRosterId, setActiveRosterId] = useState(() => {
        return localStorage.getItem('homeroom_active_roster_id') || 'default';
      });

      const [roster, setRoster] = useState(() => {
        const active = allRosters.find(r => r.id === (localStorage.getItem('homeroom_active_roster_id') || 'default'));
        return active ? active.roster : allRosters[0].roster;
      });

      const [slides, setSlides] = useState(() => {
        const active = allRosters.find(r => r.id === (localStorage.getItem('homeroom_active_roster_id') || 'default'));
        let initialSlides = active ? (active.slides || [[]]) : [[]];

        // Ensure default clock on first load/empty state
        if (initialSlides.length === 1 && initialSlides[0].length === 0) {
          const defaultClock = {
            id: 'default-clock',
            type: 'CLOCK',
            position: { x: (window.innerWidth / 2) - (625 / 2), y: (window.innerHeight / 2) - (275 / 2) }, // Centered, 25% larger dimensions
            size: { width: 625, height: 275 }, // 500 * 1.25, 220 * 1.25
            zIndex: 1,
            data: { fontSize: 16, style: 'standard', isGlassy: 'clear' },
            isMinimized: false
          };
          initialSlides = [[defaultClock]];
        }
        return initialSlides;
      });

      const handleSetActiveRoster = (id) => {
        if (id === activeRosterId) return;
        // Save CURRENT state to current roster entry BEFORE switching
        setAllRosters(prev => prev.map(r => r.id === activeRosterId ? { ...r, roster, slides } : r));

        // Load NEW state
        const next = allRosters.find(r => r.id === id);
        if (next) {
          setRoster(next.roster);
          setSlides(next.slides || [[]]);
          setCurrentSlideIndex(0);
          setActiveRosterId(id);
          localStorage.setItem('homeroom_active_roster_id', id);
        }
      };

      const handleAddRoster = (name) => {
        const newRoster = { id: Date.now().toString(), name: name, roster: [], slides: [[]] };
        setAllRosters(prev => [...prev, newRoster]);
        handleSetActiveRoster(newRoster.id);
      };

      const handleDeleteRoster = (id) => {
        if (allRosters.length <= 1) return;
        const newRosters = allRosters.filter(r => r.id !== id);

        if (activeRosterId === id) {
          const nextRoster = newRosters[0];
          setActiveRosterId(nextRoster.id);
          setRoster(nextRoster.roster || []);
          setSlides(nextRoster.slides || [[]]);
          localStorage.setItem('homeroom_active_roster_id', nextRoster.id);
        }
        setAllRosters(newRosters);
        // Force immediate save for critical deletion
        try {
          localStorage.setItem('homeroom_all_rosters', JSON.stringify(newRosters));
        } catch (err) {
          console.error("Critical Save Error (Deletion):", err);
        }
      };

      const handleRenameRoster = (id, newName) => {
        setAllRosters(prev => prev.map(r => r.id === id ? { ...r, name: newName } : r));
      };

      // Periodic Sync to allRosters with Debounce (Performance optimization for 50+ classes)
      useEffect(() => {
        const t = setTimeout(() => {
          setAllRosters(prev => prev.map(r => r.id === activeRosterId ? { ...r, roster, slides } : r));
        }, 1500); // Wait 1.5s after last change before processing the massive global array
        return () => clearTimeout(t);
      }, [roster, slides, activeRosterId]);

      useEffect(() => {
        const t = setTimeout(() => {
          try {
            localStorage.setItem('homeroom_all_rosters', JSON.stringify(allRosters));
          } catch (e) {
            if (e.name === 'QuotaExceededError') {
              console.error("HomeRoom Storage Full: Try deleting unneeded drawings or images.");
            }
          }
        }, 2000); // Separate debounce for actual disk write
        return () => clearTimeout(t);
      }, [allRosters]);

      const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
      const [selectedId, setSelectedId] = useState(null);
      const [spotlightId, setSpotlightId] = useState(null);

      const [maxZIndex, setMaxZIndex] = useState(10);
      const [currentTime, setCurrentTime] = useState(new Date().toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' }));
      const [isDockMinimized, setIsDockMinimized] = useState(false);
      const [editingWidgetId, setEditingWidgetId] = useState(null);
      const [clockStyle, setClockStyle] = useState(() => {
        return localStorage.getItem('homeroom_clock_style') || 'standard';
      });
      useEffect(() => {
        localStorage.setItem('homeroom_clock_style', clockStyle);
      }, [clockStyle]);

      const [showClockDate, setShowClockDate] = useState(() => {
        return localStorage.getItem('homeroom_show_clock_date') !== 'false';
      });

      useEffect(() => {
        localStorage.setItem('homeroom_show_clock_date', showClockDate);
      }, [showClockDate]);

      const [isClockGlassy, setIsClockGlassy] = useState(() => {
        return localStorage.getItem('homeroom_clock_glassy') || 'clear';
      });

      useEffect(() => {
        localStorage.setItem('homeroom_clock_glassy', isClockGlassy);
      }, [isClockGlassy]);

      const [dockOrder, setDockOrder] = useState(() => {
        const stored = getDockOrder();
        const mainDefaults = ['SEAT_PICKER', 'GROUP_MAKER', 'SCHEDULE', 'CALENDAR', 'TEXT', 'OVERLAY_TEXT', 'TIMER', 'RANDOMIZER', 'CLOCK'];
        const drawerDefaults = ['TRAFFIC', 'QR', 'WEBCAM', 'DICE', 'VOTE', 'YOUTUBE', 'DRAWING'];
        const allDefaults = [...mainDefaults, ...drawerDefaults];

        // 1. Legacy Array Migration
        if (Array.isArray(stored)) {
          const extras = stored.filter(id => !allDefaults.includes(id));
          const missing = allDefaults.filter(id => !stored.includes(id));
          return {
            main: mainDefaults.filter(id => stored.includes(id)),
            drawer: [...drawerDefaults.filter(id => stored.includes(id)), ...extras, ...missing]
          };
        }

        // 2. Object Storage (Ensure new tools are added)
        if (stored && stored.main && stored.drawer) {
          const currentIds = [...stored.main, ...stored.drawer];
          const missing = allDefaults.filter(id => !currentIds.includes(id));
          if (missing.length > 0) {
            return {
              ...stored,
              drawer: [...stored.drawer, ...missing]
            };
          }
          return stored;
        }

        // 3. Fallback / First Load
        return {
          main: mainDefaults,
          drawer: drawerDefaults
        };
      });

      const [isDockLocked, setIsDockLocked] = useState(true);
      const [showMoreDrawer, setShowMoreDrawer] = useState(false);
      const drawerRef = useRef(null);


      // Undo/Redo History
      const [history, setHistory] = useState([]);
      const [redoStack, setRedoStack] = useState([]);

      const addToHistory = () => {
        setHistory(prev => [...prev.slice(-19), slides]);
        setRedoStack([]);
      };

      const handleUndo = useCallback(() => {
        if (history.length === 0) return;
        const previous = history[history.length - 1];
        setRedoStack(prev => [...prev, slides]);
        setSlides(previous);
        setHistory(prev => prev.slice(0, -1));
      }, [history, slides]);

      const handleRedo = useCallback(() => {
        if (redoStack.length === 0) return;
        const next = redoStack[redoStack.length - 1];
        setHistory(prev => [...prev, slides]);
        setSlides(next);
        setRedoStack(prev => prev.slice(0, -1));
      }, [redoStack, slides]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
            if (['INPUT', 'TEXTAREA'].includes(document.activeElement?.tagName) || document.activeElement?.isContentEditable) return;
            e.preventDefault();
            if (e.shiftKey) handleRedo();
            else handleUndo();
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [handleUndo, handleRedo]);

      useEffect(() => {
        saveDockOrder(dockOrder);
      }, [dockOrder]);

      useEffect(() => {
        const handleClickOutside = (event) => {
          if (drawerRef.current && !drawerRef.current.contains(event.target)) {
            setShowMoreDrawer(false);
          }
        };
        if (showMoreDrawer) document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
      }, [showMoreDrawer]);

      const handleDockDrop = (e, targetLocation, targetId = null) => {
        e.preventDefault();
        const widgetType = e.dataTransfer.getData('widgetType');
        if (!widgetType) return;

        let sourceLocation = 'main';
        if (dockOrder.drawer.includes(widgetType)) sourceLocation = 'drawer';
        else if (!dockOrder.main.includes(widgetType)) return;

        // If dropping onto itself, do nothing
        if (widgetType === targetId) return;

        setDockOrder(prev => {
          // Remove from old lists
          const newMain = prev.main.filter(id => id !== widgetType);
          const newDrawer = prev.drawer.filter(id => id !== widgetType);

          // Prepare target list
          let targetList = targetLocation === 'main' ? [...newMain] : [...newDrawer];

          if (targetId) {
            // Insert BEFORE the targetId
            const targetIndex = targetList.indexOf(targetId);
            if (targetIndex !== -1) {
              targetList.splice(targetIndex, 0, widgetType);
            } else {
              targetList.push(widgetType); // Fallback
            }
          } else {
            // Append to end
            targetList.push(widgetType);
          }

          if (targetLocation === 'main') {
            return { main: targetList, drawer: newDrawer };
          } else {
            return { main: newMain, drawer: targetList };
          }
        });
      };


      const [showOnboarding, setShowOnboarding] = useState(false);
      const [showSettingsModal, setShowSettingsModal] = useState(false);
      const [settingsInitialTab, setSettingsInitialTab] = useState('appearance');
      const [showBackupPrompt, setShowBackupPrompt] = useState(true); // Control visibility of backup prompt

      // Link Schedule to Calendar
      const [selectedDate, setSelectedDate] = useState(new Date());
      const [scheduleTemplate, setScheduleTemplate] = useState(getScheduleTemplate());
      useEffect(() => saveScheduleTemplate(scheduleTemplate), [scheduleTemplate]);

      // New Background State
      const [background, setBackground] = useState(getBackground());
      const [slideBackgrounds, setSlideBackgrounds] = useState(() => { try { return JSON.parse(localStorage.getItem('homeroom_slide_backgrounds')) || {}; } catch (e) { return {}; } });
      const [customBackgrounds, setCustomBackgrounds] = useState(() => { try { return JSON.parse(localStorage.getItem('homeroom_my_backgrounds')) || []; } catch (e) { return []; } });
      const [showBgPicker, setShowBgPicker] = useState(false);
      const [isGridEnabled, setIsGridEnabled] = useState(() => { try { return JSON.parse(localStorage.getItem('homeroom_grid_enabled')) || false; } catch (e) { return false; } });
      useEffect(() => { localStorage.setItem('homeroom_grid_enabled', JSON.stringify(isGridEnabled)); }, [isGridEnabled]);
      useEffect(() => { localStorage.setItem('homeroom_slide_backgrounds', JSON.stringify(slideBackgrounds)); }, [slideBackgrounds]);
      useEffect(() => { localStorage.setItem('homeroom_my_backgrounds', JSON.stringify(customBackgrounds)); }, [customBackgrounds]);

      // Backup Settings
      const [backupEnabled, setBackupEnabled] = useState(() => { try { return JSON.parse(localStorage.getItem('homeroom_backup_enabled')) ?? true; } catch { return true; } });
      const [backupInterval, setBackupInterval] = useState(() => { try { return parseInt(localStorage.getItem('homeroom_backup_interval')) || 7; } catch { return 7; } });

      useEffect(() => { localStorage.setItem('homeroom_backup_enabled', JSON.stringify(backupEnabled)); }, [backupEnabled]);
      useEffect(() => { localStorage.setItem('homeroom_backup_interval', backupInterval); }, [backupInterval]);

      // Initialize backup timer on first load
      useEffect(() => {
        if (!localStorage.getItem('homeroom_last_backup')) {
          localStorage.setItem('homeroom_last_backup', Date.now());
        }
      }, []);

      // --- PERSISTENCE & DATA ---
      useEffect(() => {
        const t = setTimeout(() => {
          try {
            localStorage.setItem(WIDGETS_STORAGE_KEY, JSON.stringify(slides));
            saveRoster(roster);
          } catch (e) {
            console.warn("HomeRoom: Quick-save failed. Data will still persist via global sync.");
          }
        }, 1000);
        return () => clearTimeout(t);
      }, [slides, roster]);

      const fileInputRef = useRef(null);
      const downloadData = () => {
        const data = {
          roster: getRoster(), // Current roster
          allRosters, // All class rosters
          activeRosterId,
          scheduleTemplate: getScheduleTemplate(), // Weekly schedule
          dock: getDockOrder(),
          widgets: slides, // Includes widget data (seating positions, randomizer picks, whiteboard lines, etc.)
          background,
          slideBackgrounds,
          customBackgrounds,
          // Global Settings
          isClockGlassy,
          clockStyle,
          showClockDate,
          backupEnabled,
          backupInterval,
          isGridEnabled,
          currentSlideIndex,
          timestamp: Date.now()
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `homeroom-backup-${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        // Auto-dismiss prompt on backup
        setShowBackupPrompt(false);
        localStorage.setItem('homeroom_last_backup', Date.now());
      };

      const uploadData = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const d = JSON.parse(ev.target.result);
            // Restore Rosters
            if (d.allRosters) {
              setAllRosters(d.allRosters);
              localStorage.setItem('homeroom_all_rosters', JSON.stringify(d.allRosters));
            } else if (d.roster) {
              // Backward compatibility for single roster exports
              saveRoster(d.roster);
              setRoster(d.roster);
            }

            if (d.activeRosterId) {
              setActiveRosterId(d.activeRosterId);
              localStorage.setItem('homeroom_active_roster_id', d.activeRosterId);
            }

            if (d.scheduleTemplate) {
              setScheduleTemplate(d.scheduleTemplate);
              saveScheduleTemplate(d.scheduleTemplate);
            }
            // Restore other settings
            if (d.dock) saveDockOrder(d.dock);
            if (d.background) saveBackground(d.background);
            if (d.widgets) setSlides(d.widgets);
            if (d.dock) setDockOrder(d.dock);
            if (d.background) setBackground(d.background);
            if (d.slideBackgrounds) setSlideBackgrounds(d.slideBackgrounds);
            if (d.customBackgrounds) setCustomBackgrounds(d.customBackgrounds);

            // Restore expanded global settings
            if (d.isClockGlassy !== undefined) { setIsClockGlassy(d.isClockGlassy); localStorage.setItem('homeroom_clock_glassy', d.isClockGlassy); }
            if (d.clockStyle !== undefined) { setClockStyle(d.clockStyle); localStorage.setItem('homeroom_clock_style', d.clockStyle); }
            if (d.showClockDate !== undefined) { setShowClockDate(d.showClockDate); localStorage.setItem('homeroom_clock_show_date', d.showClockDate); }
            if (d.backupEnabled !== undefined) { setBackupEnabled(d.backupEnabled); localStorage.setItem('homeroom_backup_enabled', d.backupEnabled); }
            if (d.backupInterval !== undefined) { setBackupInterval(d.backupInterval); localStorage.setItem('homeroom_backup_interval', d.backupInterval); }
            if (d.isGridEnabled !== undefined) { setIsGridEnabled(d.isGridEnabled); localStorage.setItem('homeroom_grid_enabled', d.isGridEnabled); }
            if (d.currentSlideIndex !== undefined) { setCurrentSlideIndex(d.currentSlideIndex); }

            alert("Import successful!");
          } catch (err) { alert("Import failed."); }
        };
        reader.readAsText(file);
      };

      // ... existing effects/callbacks ...
      const widgets = slides[currentSlideIndex] || [];
      const setWidgets = useCallback((updater) => { setSlides(prev => { const newS = [...prev]; newS[currentSlideIndex] = updater(newS[currentSlideIndex]); return newS; }); }, [currentSlideIndex]);
      const currentDate = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
      useEffect(() => { const timer = setInterval(() => { setCurrentTime(new Date().toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })); }, 1000 * 60); return () => clearInterval(timer); }, []);
      useEffect(() => { if (!hasRoster()) setShowOnboarding(true); }, []);

      const currentBg = slideBackgrounds[currentSlideIndex] || background;

      const handleBgSelect = (newBg, mode = 'all') => {
        if (mode === 'single') {
          setSlideBackgrounds(prev => ({ ...prev, [currentSlideIndex]: newBg }));
        } else {
          setBackground(newBg);
          saveBackground(newBg);
          setSlideBackgrounds({});
        }
      };

      // --- WIDGET MANAGEMENT ---
      const addWidget = (type, extraData = {}) => { addToHistory(); const id = Date.now().toString(); const size = WIDGET_SIZES[type]; let startY = (window.innerHeight / 2) - (size.height / 2) + (Math.random() * 40 - 20); if (type === 'GROUP_MAKER') startY -= 100; if (type === 'SCHEDULE') startY -= 60; if (type === 'SEAT_PICKER') startY = 30; let startX = (window.innerWidth / 2) - (size.width / 2) + (Math.random() * 40 - 20); if (type === 'SEAT_PICKER') startX += 60; const position = { x: startX, y: startY }; let data = { fontSize: 16 }; if (type === 'TIMER') data = { ...data, timeLeft: 120, isRunning: false, mode: 'visual' }; if (type === 'RANDOMIZER') data = { ...data, students: getInitialStudents(), currentName: null, isAnimating: false, pickedStudents: [] }; if (type === 'GROUP_MAKER') data = { ...data, students: getInitialStudents(), groupCount: 4, groups: [] }; if (type === 'SEAT_PICKER') { const savedDesks = getSeatLayout(); if (savedDesks && savedDesks.length > 0) { data = { ...data, desks: savedDesks, isEditing: false }; } else { const initialStudents = getInitialStudents(); const initialDesks = initialStudents.slice(0, 8).map((s, i) => ({ id: `desk-${i}`, x: 50 + (i % 4) * 120, y: 50 + Math.floor(i / 4) * 100, student: s.name, color: 'blue', type: 'student', rotation: 0 })); data = { ...data, desks: initialDesks, isEditing: false }; } } if (type === 'TEXT') data = { ...data, mode: 'text', content: '', items: [] }; if (type === 'OVERLAY_TEXT') data = { ...data, content: '', isGlassy: false }; if (type === 'WEBCAM') data = { ...data, isMirrored: true, isActive: true }; if (type === 'DICE') data = { ...data, sides: 6, diceCount: 1, results: [1], isRolling: false }; if (type === 'TRAFFIC') data = { ...data, activeLight: null }; if (type === 'QR') data = { ...data, url: '' }; if (type === 'VOTE') data = { ...data, question: 'Class Poll', options: [{ id: 1, text: 'Yes', count: 0 }, { id: 2, text: 'No', count: 0 }] }; if (type === 'DRAWING') data = { ...data, canvasData: null, color: '#000000', brushSize: 5, tool: 'pen', initialImage: null, pastedImage: null }; if (type === 'SCHEDULE') { const template = getScheduleTemplate(); const today = DAYS_OF_WEEK[new Date().getDay()]; data = { ...data, items: template[today] || [] }; } if (type === 'YOUTUBE') { data = { ...data, youtubeUrl: '' }; } if (type === 'CLOCK') { data = { ...data, style: 'standard', isGlassy: 'clear' }; } if (type === 'CALENDAR') { data = { ...data, isGlassy: true }; } data = { ...data, ...extraData }; const newWidget = { id, type, position, size, zIndex: maxZIndex + 1, data, isMinimized: false }; setWidgets(prev => [...prev, newWidget]); setMaxZIndex(prev => prev + 1); setSelectedId(id); };
      // Paste Listener
      useEffect(() => {
        const handlePaste = (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.contentEditable === 'true') {
            return;
          }
          const items = e.clipboardData.items;
          if (!items) return;
          for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.type.indexOf('image') !== -1) {
              const blob = item.getAsFile();
              const reader = new FileReader();
              reader.onload = (event) => {
                const src = event.target.result;

                // Logic: If DRAWING widget is selected, paste into it. Otherwise add new.
                const selectedWidget = selectedId ? (slides[currentSlideIndex] || []).find(w => w.id === selectedId) : null;
                if (selectedWidget && selectedWidget.type === 'DRAWING') {
                  updateWidgetData(selectedId, { pastedImage: src });
                } else {
                  addWidget('DRAWING', { initialImage: src });
                }
              };
              reader.readAsDataURL(blob);
              e.preventDefault();
              return;
            }
            if (item.type.indexOf('text/plain') !== -1 && item.kind === 'string') {
              item.getAsString((text) => {
                if (text && text.trim()) {
                  addWidget('TEXT', { content: text });
                }
              });
              e.preventDefault();
              return;
            }
          }
        };
        window.addEventListener('paste', handlePaste);
        return () => window.removeEventListener('paste', handlePaste);
      }, [addWidget, updateWidgetData, selectedId, slides, currentSlideIndex]);
      const removeWidget = (id) => { addToHistory(); const widget = widgets.find(w => w.id === id); if (widget && widget.type === 'SEAT_PICKER' && widget.data.desks) { saveSeatLayout(widget.data.desks); } setWidgets(prev => prev.filter(w => w.id !== id)); if (selectedId === id) setSelectedId(null); };
      const updateWidgetLayout = useCallback((id, newPos, newSize) => { setWidgets(prev => prev.map(w => w.id === id ? { ...w, position: newPos, size: newSize } : w)); }, [setWidgets]);
      const updateWidgetData = useCallback((id, updates) => { setWidgets(prev => prev.map(w => w.id === id ? { ...w, data: { ...w.data, ...updates } } : w)); }, [setWidgets]);
      const bringToFront = (id) => {
        setSelectedId(id);
        const widget = widgets.find(w => w.id === id);
        if (!widget || widget.zIndex === maxZIndex) return;
        setMaxZIndex(prev => {
          const nextZ = prev + 1;
          setWidgets(current => current.map(w => w.id === id ? { ...w, zIndex: nextZ } : w));
          return nextZ;
        });
      };
      const toggleMinimize = useCallback((id) => { setWidgets(prev => prev.map(w => w.id === id ? { ...w, isMinimized: !w.isMinimized } : w)); }, [setWidgets]);
      const toggleSpotlight = useCallback((id) => { setSpotlightId(prev => prev === id ? null : id); }, []);
      const nextSlide = () => { if (currentSlideIndex === slides.length - 1) { setSlides(prev => [...prev, []]); } setCurrentSlideIndex(prev => prev + 1); setSelectedId(null); };
      const prevSlide = () => { if (currentSlideIndex > 0) { setCurrentSlideIndex(prev => prev - 1); setSelectedId(null); } };
      const deleteCurrentSlide = () => {
        if (slides.length <= 1) return;
        if (!window.confirm("Delete this page? This cannot be undone.")) return;

        const idxToDelete = currentSlideIndex;

        // 1. Update Slides Array
        let updatedSlides = [];
        setSlides(prev => {
          const newSlides = prev.filter((_, i) => i !== idxToDelete);
          updatedSlides = newSlides.length > 0 ? newSlides : [[]];
          return updatedSlides;
        });

        // 2. Update Slide Backgrounds (Shift remaining keys down)
        setSlideBackgrounds(prev => {
          const next = { ...prev };
          delete next[idxToDelete];
          Object.keys(next).map(Number).sort((a, b) => a - b).forEach(k => {
            if (k > idxToDelete) {
              next[k - 1] = next[k];
              delete next[k];
            }
          });
          return next;
        });

        // 3. Update Index (Safely)
        setCurrentSlideIndex(prev => {
          const newLen = slides.length - 1;
          if (prev >= newLen) return Math.max(0, newLen - 1);
          return prev;
        });

        // 4. Force Persistent Save
        try {
          const allRostersCopy = JSON.parse(localStorage.getItem('homeroom_all_rosters') || '[]');
          const rosterIdx = allRostersCopy.findIndex(r => r.id === activeRosterId);
          if (rosterIdx !== -1) {
            allRostersCopy[rosterIdx].slides = updatedSlides;
            localStorage.setItem('homeroom_all_rosters', JSON.stringify(allRostersCopy));
          }
        } catch (e) { console.error("Slide Deletion Save Error:", e); }
      };

      const duplicateCurrentSlide = () => {
        addToHistory();
        const newSlide = JSON.parse(JSON.stringify(slides[currentSlideIndex])).map(w => ({ ...w, id: Date.now().toString() + Math.random().toString(36).substr(2, 5) }));

        const newSlides = [...slides];
        const newIndex = currentSlideIndex + 1;
        newSlides.splice(newIndex, 0, newSlide);

        setSlides(newSlides);

        // Correct Background Shifting for Duplication
        setSlideBackgrounds(prev => {
          const next = { ...prev };
          // All backgrounds after currentIndex must shift up
          Object.keys(next).map(Number).sort((a, b) => b - a).forEach(k => {
            if (k > currentSlideIndex) {
              next[k + 1] = next[k];
              delete next[k];
            }
          });
          // Copy current background to new slide if it exists
          if (prev[currentSlideIndex]) {
            next[newIndex] = prev[currentSlideIndex];
          }
          return next;
        });

        setCurrentSlideIndex(newIndex);

        // Persistent Save
        try {
          const allRostersCopy = JSON.parse(localStorage.getItem('homeroom_all_rosters') || '[]');
          const rosterIdx = allRostersCopy.findIndex(r => r.id === activeRosterId);
          if (rosterIdx !== -1) {
            allRostersCopy[rosterIdx].slides = newSlides;
            localStorage.setItem('homeroom_all_rosters', JSON.stringify(allRostersCopy));
          }
        } catch (e) { console.error("Slide Duplication Save Error:", e); }
      };

      // Removed legacy saveDock/handleDockDrop
      const renderDockItem = (id, location) => {
        const info = DOCK_LABELS[id];
        if (!info) return null;
        return (
          <div
            key={id}
            draggable={!isDockLocked}
            onDragStart={(e) => {
              e.dataTransfer.setData('widgetType', id);
              // Rotation Snap Effect for GHOST
              e.currentTarget.style.transform = "rotate(5deg) scale(1.1)";
              // Hide source immediately after ghost generation
              requestAnimationFrame(() => {
                e.target.classList.add('opacity-0');
              });
            }}
            onDragEnd={(e) => {
              e.currentTarget.style.transform = "";
              e.target.classList.remove('opacity-0');
            }}
            onDragOver={(e) => {
              if (!isDockLocked) {
                e.preventDefault();
                e.stopPropagation();
              }
            }}
            onDrop={(e) => {
              if (!isDockLocked) {
                e.preventDefault();
                e.stopPropagation();
                handleDockDrop(e, location, id);
              }
            }}
            onClick={() => {
              // When unlocked (edit mode), don't add widget on click - only drag works
              if (!isDockLocked || isDockMinimized) return;
              addWidget(id);
              if (location === 'drawer') setShowMoreDrawer(false);
            }}
            className={`flex flex-col items-center gap-0 py-1 px-2 rounded-xl transition-all cursor-pointer group relative
              ${!isDockLocked ? 'hover:bg-blue-50 hover:scale-105 active:scale-95 cursor-grab active:cursor-grabbing border-2 border-dashed border-blue-300' : 'hover:bg-white/50 hover:scale-110 active:scale-95 border-2 border-transparent'}`}
            title={!isDockLocked ? "Drag to reorder" : info.label}
          >
            {!isDockLocked && <div className="absolute -top-1 -right-1 bg-blue-500 text-white rounded-full p-0.5 shadow-sm"><GripVertical size={10} /></div>}
            <div className={`p-1.5 rounded-xl text-slate-600 transition-colors ${!isDockLocked ? 'bg-blue-100' : 'bg-white/80 group-hover:bg-white group-hover:text-blue-600 shadow-sm'}`}>
              {info.icon}
            </div>
            <span className="text-[10px] font-bold text-slate-700 group-hover:text-slate-900">{info.label}</span>
          </div>
        );
      };

      const renderWidgetContent = (widget) => {
        const isSelected = selectedId === widget.id;
        const props = {
          widget: { ...widget, updateLayout: updateWidgetLayout },
          updateData: updateWidgetData,
          updateLayout: updateWidgetLayout,
          isSelected,
          roster,
          onUpdateRoster: setRoster,
          extraProps: {
            clockStyle: widget.data?.style || clockStyle,
            setClockStyle: setClockStyle,
            onOpenSettings: () => { setSettingsInitialTab('appearance'); setShowSettingsModal(true); },
            isGlassy: widget.data?.isGlassy || isClockGlassy,
            showDate: widget.data?.showDate !== undefined ? widget.data.showDate : showClockDate,
            textColor: currentBg?.textColor || 'text-slate-800'
          }
        };

        switch (widget.type) {
          case 'TIMER': return <TimerWidget {...props} />;
          case 'RANDOMIZER': return <RandomizerWidget {...props} />;
          case 'GROUP_MAKER': return <GroupMakerWidget {...props} />;
          case 'SEAT_PICKER': return <SeatPickerWidget {...props} />;
          case 'TEXT': return <TextWidget {...props} />;
          case 'OVERLAY_TEXT': return <SimpleTextWidget {...props} />;
          case 'WEBCAM': return <WebcamWidget {...props} />;
          case 'DICE': return <DiceWidget {...props} />;
          case 'TRAFFIC': return <TrafficLightWidget {...props} />;
          case 'QR': return <QRCodeWidget {...props} />;
          case 'VOTE': return <VoteWidget {...props} />;
          case 'DRAWING': return <DrawingWidget {...props} />;
          case 'SCHEDULE': return <ScheduleWidget {...props} selectedDate={selectedDate} scheduleTemplate={scheduleTemplate} setScheduleTemplate={setScheduleTemplate} onOpenSettings={() => { setSettingsInitialTab('schedule'); setShowSettingsModal(true); }} />;
          case 'YOUTUBE': return <YouTubeWidget {...props} />;
          case 'CALENDAR': return <CalendarWidget {...props} selectedDate={selectedDate} onSelectDate={setSelectedDate} isGlassy={props.extraProps.isGlassy} />;
          case 'CLOCK': return <ClockWidget {...props} isGlassy={props.extraProps.isGlassy} />;
          default: return null;
        }
      };

      return (
        <div className="w-screen h-screen overflow-hidden relative" style={{
          backgroundColor: '#dbeafe', // fallback
          backgroundImage: currentBg && currentBg.id !== 'default' ? `url(${currentBg.src})` : 'none',
          backgroundSize: 'cover',
          backgroundPosition: 'center'
        }} onMouseDown={() => setSelectedId(null)}>
          {/* Modals */}
          {showOnboarding && <OnboardingModal onComplete={() => setShowOnboarding(false)} onSaveRoster={(newRoster) => setRoster(newRoster)} />}
          {showSettingsModal && <SettingsModal
            roster={roster}
            allRosters={allRosters}
            activeRosterId={activeRosterId}
            onSetActiveRoster={handleSetActiveRoster}
            onAddRoster={handleAddRoster}
            onDeleteRoster={handleDeleteRoster}
            onRenameRoster={handleRenameRoster}
            onClose={() => { setShowSettingsModal(false); setEditingWidgetId(null); }}
            onSave={(newRoster) => { setRoster(newRoster); }}
            downloadData={downloadData}
            fileInputRef={fileInputRef}
            initialTab={settingsInitialTab}
            isGridEnabled={isGridEnabled}
            onToggleGrid={setIsGridEnabled}
            currentBg={currentBg}
            onBgSelect={handleBgSelect}
            myBackgrounds={customBackgrounds}
            onAddCustomBg={(bg) => setCustomBackgrounds(prev => [bg, ...prev])}
            onDeleteCustomBg={(id) => {
              const newBgs = customBackgrounds.filter(bg => bg.id !== id);
              setCustomBackgrounds(newBgs);
              localStorage.setItem('homeroom_custom_backgrounds', JSON.stringify(newBgs));
            }}
            backupEnabled={backupEnabled}
            setBackupEnabled={setBackupEnabled}
            backupInterval={backupInterval}
            setBackupInterval={setBackupInterval}
            widgetList={widgets}  // Passing widgets for Data tab serialization if needed
            clockStyle={editingWidgetId ? (widgets.find(w => w.id === editingWidgetId)?.data?.style || 'standard') : clockStyle}
            setClockStyle={(newStyle) => {
              if (editingWidgetId) {
                updateWidgetData(editingWidgetId, { style: newStyle });
              } else {
                setWidgets(prev => prev.map(w => w.type === 'CLOCK' ? { ...w, data: { ...w.data, style: newStyle } } : w));
              }
              setClockStyle(newStyle);
            }}
            showClockDate={editingWidgetId ? (widgets.find(w => w.id === editingWidgetId)?.data?.showDate !== false) : showClockDate}
            setShowClockDate={(newVal) => {
              if (editingWidgetId) {
                updateWidgetData(editingWidgetId, { showDate: newVal });
              } else {
                setWidgets(prev => prev.map(w => w.type === 'CLOCK' ? { ...w, data: { ...w.data, showDate: newVal } } : w));
              }
              setShowClockDate(newVal);
            }}
            isClockGlassy={editingWidgetId ? (widgets.find(w => w.id === editingWidgetId)?.data?.isGlassy || isClockGlassy) : isClockGlassy}
            setIsClockGlassy={(newVal) => {
              if (editingWidgetId) {
                updateWidgetData(editingWidgetId, { isGlassy: newVal });
              } else {
                setWidgets(prev => prev.map(w => w.type === 'CLOCK' ? { ...w, data: { ...w.data, isGlassy: newVal } } : w));
                setIsClockGlassy(newVal);
              }
            }}
          />}
          <input ref={fileInputRef} type="file" accept=".json" className="hidden" onChange={uploadData} />

          {/* Default Geometric Background Layer */}
          {(!currentBg || currentBg.id === 'default') && (
            <div className="absolute inset-0 pointer-events-none z-0">
              <svg className="w-full h-full" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="gradOrange" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style={{ stopColor: "#fb923c", stopOpacity: 1 }} /><stop offset="100%" style={{ stopColor: "#ea580c", stopOpacity: 1 }} /></linearGradient><linearGradient id="gradBlue" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style={{ stopColor: "#3b82f6", stopOpacity: 1 }} /><stop offset="100%" style={{ stopColor: "#60a5fa", stopOpacity: 1 }} /></linearGradient></defs><rect width="100%" height="100%" fill="#dbeafe" /><path d="M1920 0V900C1400 900 1000 400 500 0H1920Z" fill="url(#gradOrange)" opacity="0.9" /><path d="M1920 0V700C1600 700 1300 300 900 0H1920Z" fill="#fed7aa" opacity="0.5" /><path d="M0 1080V300C500 300 900 800 1600 1080H0Z" fill="url(#gradBlue)" opacity="0.9" /><path d="M0 1080V500C300 500 700 900 1200 1080H0Z" fill="#93c5fd" opacity="0.5" /></svg>
            </div>
          )}

          {/* Dark Overlay for better contrast on images */}
          {currentBg && currentBg.id !== 'default' && <div className="absolute inset-0 bg-black/20 z-0 pointer-events-none" />}

          {/* Top Info Bar - Clock (REMOVED - now a widget) */}
          <div className={`absolute top-10 left-12 z-1 select-none transition-colors duration-300 ${currentBg.textColor || 'text-slate-800'}`}>
            {(() => {
              // Don't show if disabled
              if (!backupEnabled) return null;

              const last = localStorage.getItem('homeroom_last_backup');
              // If last backup time is valid check vs interval, otherwise wait (initialized to now above)
              const days = last ? (Date.now() - Number(last)) / (1000 * 60 * 60 * 24) : 0;

              if (days > backupInterval && showBackupPrompt) {
                return (
                  <div className="mt-4 animate-in fade-in slide-in-from-top-2 flex items-center gap-1 bg-red-100/90 rounded-lg p-1 pr-2 shadow-sm border border-red-200">
                    <button onClick={downloadData} className="flex items-center gap-2 text-red-600 px-2 py-1 rounded text-xs font-bold hover:bg-red-200 transition-colors">
                      <AlertTriangle size={14} /> Backup Data
                    </button>
                    <div className="w-px h-4 bg-red-200" />
                    <button onClick={() => setShowBackupPrompt(false)} className="p-1 text-red-400 hover:text-red-700 hover:bg-red-200 rounded-md transition-colors" title="Dismiss">
                      <X size={14} />
                    </button>
                  </div>
                );
              }
              return null;
            })()}
          </div>

          {/* Fixed Settings Button */}
          <button
            onClick={() => { setSettingsInitialTab('appearance'); setShowSettingsModal(true); }}
            className="fixed top-4 right-4 z-[9999] p-2 bg-white/80 backdrop-blur-md border border-white/50 rounded-full shadow-lg text-slate-500 hover:text-blue-600 hover:bg-white transition-all active:scale-95 group"
            title="Settings"
          >
            <Settings size={22} className="group-hover:rotate-45 transition-transform duration-300" />
          </button>



          {/* Widgets Area */}
          <div className="absolute inset-0 z-30 pointer-events-none">
            {/* Spotlight Overlay - inside widget container so only spotlighted widget appears above it */}
            {spotlightId && <div className="fixed inset-0 bg-black/85 cursor-pointer pointer-events-auto animate-in fade-in duration-500 backdrop-blur-[2px]" style={{ zIndex: 9998 }} onClick={() => setSpotlightId(null)}><div className="absolute inset-0 bg-gradient-radial from-transparent via-transparent to-black/40" /></div>}
            {widgets.map(w => {
              const isChromeless = ['OVERLAY_TEXT', 'CLOCK', 'CALENDAR'].includes(w.type);
              return (
                <DraggableResizable
                  key={w.id}
                  id={w.id}
                  position={w.position}
                  size={w.size}
                  zIndex={w.zIndex}
                  isSelected={selectedId === w.id}
                  isMinimized={w.isMinimized}
                  isSpotlighted={spotlightId === w.id}
                  isGridEnabled={isGridEnabled}
                  widgetType={w.type}
                  onSelect={bringToFront}
                  onUpdate={updateWidgetLayout}
                  onRemove={removeWidget}
                  onMinimizeToggle={toggleMinimize}
                  onSpotlight={toggleSpotlight}
                  onSettings={(id) => { setEditingWidgetId(id); setSettingsInitialTab('appearance'); setShowSettingsModal(true); }}
                  chromeless={isChromeless}
                  isGlassy={w.data?.isGlassy}
                  onToggleGlass={['CLOCK', 'CALENDAR', 'OVERLAY_TEXT', 'TEXT'].includes(w.type) ? () => {
                    const current = w.data.isGlassy || 'solid';
                    const next = current === 'solid' ? 'glass' : (current === 'glass' ? 'clear' : 'solid');
                    updateWidgetData(w.id, { isGlassy: next });
                  } : undefined}
                  onFontSizeChange={['QR', 'WEBCAM', 'YOUTUBE', 'CALENDAR', 'CLOCK'].includes(w.type) ? undefined : (d) => updateWidgetData(w.id, { fontSize: Math.max(8, (w.data.fontSize || 16) + d) })}
                >
                  {renderWidgetContent(w)}
                </DraggableResizable>
              );
            })}
          </div>

          {/* Slide Controls - Refined Styles */}
          <div className="absolute bottom-6 right-8 z-50 flex items-center pointer-events-none">
            <button onClick={handleUndo} disabled={history.length === 0} className="mr-3 pointer-events-auto p-2 bg-white/80 backdrop-blur-md hover:bg-white text-slate-600 disabled:opacity-30 disabled:hover:bg-white/80 rounded-full shadow-lg border border-white/50 transition-all active:scale-95 group" title="Undo (Ctrl+Z)">
              <Undo2 size={20} className="group-hover:text-blue-600" />
            </button>
            <div className="pointer-events-auto flex items-center gap-0.5 backdrop-blur-2xl rounded-full shadow-2xl p-0.5 ring-1 ring-white/50 relative">
              <div className="absolute inset-0 bg-white/20 rounded-full overflow-hidden -z-10 border border-white/40" />
              <button onClick={prevSlide} disabled={currentSlideIndex === 0} className="p-1.5 hover:bg-white/40 rounded-full text-gray-500 hover:text-blue-700 transition-all duration-200 disabled:opacity-20 group active:scale-95"><ChevronLeft size={20} /></button>
              <div className="px-2 flex items-center justify-center min-w-[35px]"><span className="text-[10px] font-extrabold text-blue-900 leading-none">{currentSlideIndex + 1} / {slides.length}</span></div>
              <button onClick={nextSlide} className="p-1.5 hover:bg-white/40 rounded-full text-gray-500 hover:text-blue-700 transition-all duration-200 group active:scale-95 flex items-center justify-center">{currentSlideIndex === slides.length - 1 ? <Plus size={20} /> : <ChevronRight size={20} />}</button>
              {slides.length > 0 && (
                <>
                  <div className="w-px h-4 bg-gray-300 mx-1" />
                  <button onClick={duplicateCurrentSlide} className="p-1.5 hover:bg-indigo-50 rounded-xl text-gray-400 hover:text-indigo-600 transition-all duration-200 active:scale-95" title="Duplicate Page"><ArrowRightSquare size={16} /></button>
                </>
              )}
              {slides.length > 1 && (
                <>
                  <div className="w-px h-4 bg-gray-300 mx-1" />
                  <button onClick={deleteCurrentSlide} className="p-1.5 hover:bg-red-50 rounded-xl text-gray-400 hover:text-red-600 transition-all duration-200 active:scale-95" title="Delete Page"><Trash2 size={16} /></button>
                </>
              )}
            </div>
          </div>

          <div className="absolute bottom-1 left-0 right-0 z-50 flex flex-col items-center justify-end pointer-events-none">
            <div className={`max-w-6xl mx-4 mb-2 transition-all duration-300 ease-in-out origin-bottom pointer-events-auto ${isDockMinimized ? 'translate-y-20 opacity-0 scale-95 pointer-events-none invisible' : 'translate-y-0 opacity-100 scale-100 visible'}`}>
              <div className={`flex items-center backdrop-blur-2xl rounded-3xl shadow-2xl p-0.5 ring-1 ring-white/50 relative`}>
                <div className="absolute inset-0 bg-white/20 rounded-3xl overflow-hidden -z-10 border border-white/40">
                  <div className="absolute inset-0 bg-gradient-to-b from-white/40 to-white/5 pointer-events-none" />
                </div>



                {/* MAIN DOCK */}
                <div
                  className={`flex gap-2 py-0.5 px-2 rounded-xl border-2 transition-all duration-300 ease-in-out ${!isDockLocked ? 'bg-blue-50/50 border-dashed border-blue-200 min-w-[200px]' : 'border-transparent'}`}
                  onDragOver={(e) => { e.preventDefault(); e.currentTarget.classList.add('bg-blue-100'); }}
                  onDragLeave={(e) => e.currentTarget.classList.remove('bg-blue-100')}
                  onDrop={(e) => {
                    e.currentTarget.classList.remove('bg-blue-100');
                    handleDockDrop(e, 'main');
                  }}
                >
                  {dockOrder.main.map((id) => renderDockItem(id, 'main'))}
                </div>

                <div className="w-px h-8 bg-slate-300 mx-2" />

                {/* MORE DRAWER BUTTON */}
                <div className="relative" ref={drawerRef}>
                  <button
                    onClick={() => setShowMoreDrawer(!showMoreDrawer)}
                    className={`flex flex-col items-center gap-0 py-1 px-2 rounded-xl transition-all cursor-pointer group
                            ${showMoreDrawer ? 'bg-indigo-100' : 'hover:bg-white/50'}
                            ${!isDockLocked && dockOrder.drawer.length > 0 ? 'border-2 border-dashed border-indigo-300 bg-indigo-50' : ''}
                        `}
                    onDragOver={(e) => {
                      if (!isDockLocked) {
                        e.preventDefault();
                        setShowMoreDrawer(true);
                      }
                    }}
                    onDrop={(e) => {
                      if (!isDockLocked) {
                        e.preventDefault();
                        handleDockDrop(e, 'drawer');
                      }
                    }}
                  >
                    <div className={`p-1.5 rounded-xl text-indigo-600 transition-colors ${showMoreDrawer ? 'bg-indigo-200 text-indigo-800' : 'bg-indigo-50 group-hover:bg-indigo-100 group-hover:text-indigo-700 shadow-sm'}`}>
                      {showMoreDrawer ? <ChevronDown size={24} /> : <MoreHorizontal size={24} />}
                    </div>
                    <span className="text-[10px] font-extrabold text-indigo-900 group-hover:text-indigo-700">More</span>
                  </button>

                  {/* DRAWER POPUP */}
                  {showMoreDrawer && (
                    <div
                      className="absolute bottom-full right-0 mb-4 bg-white/90 backdrop-blur-xl border border-white/50 p-4 rounded-2xl shadow-2xl flex flex-wrap gap-2 w-64 z-50 animate-in slide-in-from-bottom-2 fade-in duration-200"
                      onDragOver={(e) => { e.preventDefault(); e.currentTarget.classList.add('bg-indigo-50'); }}
                      onDragLeave={(e) => e.currentTarget.classList.remove('bg-indigo-50')}
                      onDrop={(e) => {
                        e.currentTarget.classList.remove('bg-indigo-50');
                        handleDockDrop(e, 'drawer');
                      }}
                    >
                      <div className="w-full text-[10px] font-bold text-slate-400 uppercase tracking-widest mb-1 border-b pb-1">Additional Tools</div>
                      {dockOrder.drawer.length > 0 ? (
                        dockOrder.drawer.map((id) => renderDockItem(id, 'drawer'))
                      ) : (
                        <div className="w-full text-center py-4 text-xs text-gray-400 italic">
                          {isDockLocked ? "No tools here." : "Drag tools here to hide them."}
                        </div>
                      )}
                    </div>
                  )}
                </div>

                <div className="w-px h-8 bg-slate-300 mx-2" />

                <button
                  onClick={() => setIsDockLocked(!isDockLocked)}
                  className={`p-1.5 rounded-full transition-all ${!isDockLocked ? 'bg-blue-100 text-blue-600 shadow-inner' : 'hover:bg-slate-100 text-slate-500 hover:text-slate-700'}`}
                  title={isDockLocked ? "Unlock Dock to Rearrange" : "Lock Dock"}
                >
                  {isDockLocked ? <Lock size={16} /> : <Unlock size={16} />}
                </button>
              </div>
            </div>
            <div className="pointer-events-auto transition-all duration-300 z-50 mt-1"><button onClick={() => setIsDockMinimized(!isDockMinimized)} className="bg-white/90 backdrop-blur-md hover:bg-white text-slate-500 hover:text-blue-600 p-1.5 rounded-full shadow-lg border border-white/50 transition-all active:scale-95">{isDockMinimized ? <ChevronUp size={22} /> : <ChevronDown size={22} />}</button></div>
          </div>
        </div>
      );
    };



    const root = createRoot(document.getElementById('root')); root.render(<App />);
  </script>
</body>

</html>