<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HomeRoom</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      overflow: hidden;
    }

    /* Ensure consistent emoji rendering across all systems */
    .emoji {
      font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', sans-serif;
    }

    .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
      background: transparent;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    /* Wobble animation for dock edit mode */
    @keyframes wobble {
      0% {
        transform: rotate(0deg);
      }

      25% {
        transform: rotate(-2deg);
      }

      75% {
        transform: rotate(2deg);
      }

      100% {
        transform: rotate(0deg);
      }
    }

    .animate-wobble {
      animation: wobble 0.3s infinite linear;
    }
  </style>
  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Import Map -->
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "lucide-react": "https://esm.sh/lucide-react@0.292.0"
    }
  }
  </script>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef, useCallback } from 'react';
    import { createRoot } from 'react-dom/client';
    import {
      Mic, Eraser, Timer, Shuffle, Users, Type, Armchair,
      Camera, Dices, ChevronDown, ChevronUp, Copy,
      Maximize2, GripHorizontal, Minus, Plus, Pause, Play, RotateCcw,
      Settings, CheckSquare, Square, RefreshCw, GripVertical, Trash2,
      Wand2, CameraOff, FlipHorizontal, X, Bold, List, ChevronLeft, ChevronRight,
      Save, AlertCircle, AlertTriangle, Share2, Edit3, Layout, User, MoreVertical, MoreHorizontal, Briefcase,
      RotateCw, Lock, Unlock, Grip, Palette, Image as ImageIcon, UploadCloud,
      Sun, Moon, BarChart2, Italic, Underline, AlignLeft, Clock, Smile,
      Volume2, VolumeX, Download, Upload, Check, Info, ExternalLink, Mail, Calendar, Youtube, Lightbulb, MousePointer2, Undo2, Redo2, ArrowRightSquare, QrCode, Bell
    } from 'lucide-react';

    // --- CONSTANTS ---
    const DEFAULT_NAMES = [];


    const DESK_COLORS = {
      blue: 'bg-blue-50 border-blue-400',
      red: 'bg-red-50 border-red-400',
      green: 'bg-green-50 border-green-400',
      yellow: 'bg-yellow-50 border-yellow-400'
    };

    const INIT_DOCK_ORDER = ['TIMER', 'RANDOMIZER', 'GROUP_MAKER', 'SEAT_PICKER', 'SCHEDULE', 'TEXT', 'TRAFFIC', 'QR', 'WEBCAM', 'DICE', 'VOTE', 'WHITEBOARD', 'YOUTUBE'];
    const TrafficLightIcon = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <rect x="7" y="2" width="10" height="20" rx="4" />
        <circle cx="12" cy="7" r="2" />
        <circle cx="12" cy="12" r="2" />
        <circle cx="12" cy="17" r="2" />
      </svg>
    );

    const DOCK_LABELS = {
      TIMER: { label: 'Timer', icon: <Timer /> },
      RANDOMIZER: { label: 'Random', icon: <Shuffle /> },
      GROUP_MAKER: { label: 'Groups', icon: <Users /> },
      SEAT_PICKER: { label: 'Seats', icon: <Armchair /> },
      TEXT: { label: 'Notes', icon: <Type /> },
      TRAFFIC: { label: 'Noise', icon: <TrafficLightIcon /> },
      QR: { label: 'QR Code', icon: <Share2 /> },
      WEBCAM: { label: 'Cam', icon: <Camera /> },
      DICE: { label: 'Dice', icon: <Dices /> },
      VOTE: { label: 'Poll', icon: <BarChart2 /> },
      WHITEBOARD: { label: 'Draw', icon: <Edit3 /> },
      SCHEDULE: { label: 'Schedule', icon: <Calendar /> },
      YOUTUBE: { label: 'Embed', icon: <Youtube /> }
    };

    // --- BACKGROUND PRESETS (UPDATED) ---
    const BACKGROUNDS = [
      { id: 'default', name: 'Original', type: 'preset', preview: 'bg-gradient-to-br from-blue-200 to-orange-200', style: {}, textColor: 'text-slate-800' },
      { id: 'forest', name: 'Forest', type: 'image', src: 'https://images.unsplash.com/photo-1622572860925-daa5e4219d53?q=80&w=1674&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D', textColor: 'text-white' },
      { id: 'ocean', name: 'Ocean', type: 'image', src: 'https://images.pexels.com/photos/1032650/pexels-photo-1032650.jpeg?auto=compress&cs=tinysrgb&w=1920', textColor: 'text-slate-800' },
      { id: 'sunset', name: 'Sunset', type: 'image', src: 'https://images.unsplash.com/photo-1503803548695-c2a7b4a5b875?q=80&w=1770&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D', textColor: 'text-white' },
      { id: 'galaxy', name: 'Galaxy', type: 'image', src: 'https://images.unsplash.com/photo-1464802686167-b939a6910659?q=80&w=1750&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D', textColor: 'text-white' },
      { id: 'puppy', name: 'Puppy', type: 'image', src: 'https://hips.hearstapps.com/hmg-prod/images/dog-puppy-on-garden-royalty-free-image-1586966191.jpg?crop=1xw:0.74975xh;0,0.190xh', textColor: 'text-white' },
      { id: 'kitten', name: 'Kitten', type: 'image', src: 'https://www.vets4pets.com/siteassets/species/cat/kitten/tiny-kitten-in-sunlight.jpg', textColor: 'text-white' },
      { id: 'aurora', name: 'Aurora', type: 'image', src: 'https://images.unsplash.com/photo-1531366936337-7c912a4589a7?auto=format&fit=crop&w=1920&q=80', textColor: 'text-white' },
    ];

    // --- STORAGE SERVICE ---
    const ROSTER_STORAGE_KEY = 'homeroom_roster_v2';
    const DOCK_ORDER_KEY = 'homeroom_dock_order';
    const BG_STORAGE_KEY = 'homeroom_background';
    const WIDGETS_STORAGE_KEY = 'homeroom_widgets';

    const getRoster = () => {
      try {
        const stored = JSON.parse(localStorage.getItem(ROSTER_STORAGE_KEY));
        if (!stored) return DEFAULT_NAMES.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true }));
        // Migration: If array of strings, convert to objects
        if (Array.isArray(stored) && stored.length > 0 && typeof stored[0] === 'string') {
          return stored.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true }));
        }
        return stored;
      } catch (e) { return DEFAULT_NAMES.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true })); }
    };
    const saveRoster = (roster) => { try { localStorage.setItem(ROSTER_STORAGE_KEY, JSON.stringify(roster)); } catch (e) { } };
    const hasRoster = () => !!localStorage.getItem(ROSTER_STORAGE_KEY);

    const getDockOrder = () => { try { return JSON.parse(localStorage.getItem(DOCK_ORDER_KEY)) || INIT_DOCK_ORDER; } catch (e) { return INIT_DOCK_ORDER; } };
    const saveDockOrder = (order) => { try { localStorage.setItem(DOCK_ORDER_KEY, JSON.stringify(order)); } catch (e) { } };

    const getBackground = () => { try { return JSON.parse(localStorage.getItem(BG_STORAGE_KEY)) || BACKGROUNDS[0]; } catch (e) { return BACKGROUNDS[0]; } };
    const saveBackground = (bg) => { try { localStorage.setItem(BG_STORAGE_KEY, JSON.stringify(bg)); } catch (e) { } };

    // Seat Layout Persistence (survives widget close/reopen)
    const SEAT_LAYOUT_KEY = 'homeroom_seat_layout';
    const getSeatLayout = () => { try { return JSON.parse(localStorage.getItem(SEAT_LAYOUT_KEY)); } catch (e) { return null; } };
    const saveSeatLayout = (desks) => { try { localStorage.setItem(SEAT_LAYOUT_KEY, JSON.stringify(desks)); } catch (e) { } };

    // Schedule Persistence
    const SCHEDULE_STORAGE_KEY = 'homeroom_schedule';
    const DAYS_OF_WEEK = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const getDefaultScheduleTemplate = () => ({ Monday: [], Tuesday: [], Wednesday: [], Thursday: [], Friday: [] });
    const getScheduleTemplate = () => { try { return JSON.parse(localStorage.getItem(SCHEDULE_STORAGE_KEY)) || getDefaultScheduleTemplate(); } catch (e) { return getDefaultScheduleTemplate(); } };
    const saveScheduleTemplate = (schedule) => { try { localStorage.setItem(SCHEDULE_STORAGE_KEY, JSON.stringify(schedule)); } catch (e) { } };

    const getInitialStudents = () => {
      const stored = getRoster();
      // stored is guaranteed to be objects now due to getRoster migration
      return stored;
    };

    const WIDGET_SIZES = {

      TIMER: { width: 280, height: 340 },
      RANDOMIZER: { width: 250, height: 250 },
      GROUP_MAKER: { width: 600, height: 400 },
      SEAT_PICKER: { width: 900, height: 600 },
      TEXT: { width: 340, height: 260 },
      WEBCAM: { width: 320, height: 240 },
      DICE: { width: 300, height: 320 },
      TRAFFIC: { width: 220, height: 360 },
      QR: { width: 250, height: 280 },
      VOTE: { width: 400, height: 350 },
      WHITEBOARD: { width: 500, height: 400 },

      SCHEDULE: { width: 380, height: 500 },
      YOUTUBE: { width: 480, height: 360 }
    };

    // --- COMPONENTS ---
    // Custom Time Picker (Items 9 & 10)
    const TimePicker = ({ time, onChange, onClose }) => {
      const [hours, minutes] = time.split(':').map(Number);
      const isPM = hours >= 12;
      const displayHours = hours % 12 || 12;
      const [manualInput, setManualInput] = useState("");

      const handleHourChange = (h) => {
        let newH = h;
        if (isPM && h !== 12) newH += 12;
        if (!isPM && h === 12) newH = 0;
        onChange(`${newH.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`);
      };

      const handleMinuteChange = (m) => {
        onChange(`${hours.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`);
      };

      const toggleAMPM = () => {
        const newH = (hours + 12) % 24;
        onChange(`${newH.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`);
      };

      const handleManualSubmit = () => {
        if (!manualInput) return;
        const [hStr, mStr] = manualInput.split(':');
        let h = parseInt(hStr);
        let m = parseInt(mStr) || 0;

        // Basic AM/PM detection if user types "9pm"
        const isPMInput = manualInput.toLowerCase().includes('p');
        const isAMInput = manualInput.toLowerCase().includes('a');

        if (isNaN(h)) return;

        if (isPMInput && h < 12) h += 12;
        if (isAMInput && h === 12) h = 0;

        // Clamp
        h = Math.max(0, Math.min(23, h));
        m = Math.max(0, Math.min(59, m));

        onChange(`${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`);
        setManualInput("");
      };

      return (
        <div className="absolute top-full left-0 mt-1 bg-white border border-gray-200 rounded-xl shadow-xl z-[60] p-3 flex flex-col gap-2 animate-in fade-in zoom-in-95" onClick={(e) => e.stopPropagation()}>
          {/* Manual Input */}
          <div className="flex gap-1 border-b border-gray-100 pb-2 mb-1">
            <input
              className="w-16 bg-gray-50 border rounded px-1 py-0.5 text-xs font-bold text-center outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="9:30"
              value={manualInput}
              onChange={(e) => setManualInput(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  handleManualSubmit();
                  onClose();
                }
              }}
              autoFocus
            />
            <button onClick={() => { handleManualSubmit(); onClose(); }} className="px-2 py-0.5 bg-blue-100 text-blue-600 rounded text-[10px] font-bold hover:bg-blue-200">OK</button>
          </div>

          <div className="flex gap-3">
            <div className="h-32 overflow-y-auto custom-scrollbar w-12 text-center">
              {Array.from({ length: 12 }, (_, i) => i + 1).map(h => (
                <div key={h} onClick={() => handleHourChange(h)} className={`p-1 text-sm font-bold rounded cursor-pointer hover:bg-indigo-50 ${displayHours === h ? 'bg-indigo-100 text-indigo-600' : 'text-gray-600'}`}>
                  {h}
                </div>
              ))}
            </div>

            <div className="h-32 overflow-y-auto custom-scrollbar w-12 text-center border-l border-gray-100 pl-1">
              {Array.from({ length: 12 }, (_, i) => i * 5).map(m => (
                <div key={m} onClick={() => handleMinuteChange(m)} className={`p-1 text-sm font-bold rounded cursor-pointer hover:bg-indigo-50 ${minutes === m ? 'bg-indigo-100 text-indigo-600' : 'text-gray-600'}`}>
                  {m.toString().padStart(2, '0')}
                </div>
              ))}
            </div>

            <div className="flex flex-col gap-1 justify-center border-l border-gray-100 pl-2">
              <button onClick={() => !isPM && toggleAMPM()} className={`px-2 py-1 text-xs font-bold rounded ${!isPM ? 'bg-orange-100 text-orange-600' : 'text-gray-400 hover:bg-gray-50'}`}>AM</button>
              <button onClick={() => isPM && toggleAMPM()} className={`px-2 py-1 text-xs font-bold rounded ${isPM ? 'bg-blue-100 text-blue-600' : 'text-gray-400 hover:bg-gray-50'}`}>PM</button>
              <div className="h-px bg-gray-200 my-1" />
              <button onClick={onClose} className="px-2 py-1 text-xs font-bold text-green-600 hover:bg-green-50 rounded">Done</button>
            </div>
          </div>
        </div>
      );
    };

    // SeatPickerWidget rewritten for Multi-Select and Random Empty Seats
    const SeatPickerWidget = ({ widget, updateData, roster, onUpdateRoster }) => {
      const { desks = [], isEditing = false, snapToGrid = 0, fontSize = 16 } = widget.data;
      const containerRef = useRef(null);

      const [draggedDesk, setDraggedDesk] = useState(null);
      const [rotatingDesk, setRotatingDesk] = useState(null);
      const [selectedDeskIds, setSelectedDeskIds] = useState([]); // Array for multi-select

      // Selection Box State
      const [isSelecting, setIsSelecting] = useState(false);
      const [selectionBox, setSelectionBox] = useState(null); // { x, y, w, h } relative to container

      const dragStartMouse = useRef({ x: 0, y: 0 });
      const initialDeskPositions = useRef({});

      // Roster Sync
      useEffect(() => {
        const allStudentNames = roster.map(s => s.name);
        let currentDesks = Array.isArray(desks) ? [...desks] : [];
        let needsUpdate = false;

        // Ensure students are seated or new desks created
        const seated = currentDesks.map(d => d.student).filter(Boolean);
        const unseated = allStudentNames.filter(name => !seated.includes(name));

        if (unseated.length > 0) {
          needsUpdate = true;
          // Fill empty spots first
          currentDesks = currentDesks.map(d => {
            if (d.type !== "teacher" && !d.student && unseated.length > 0) { return { ...d, student: unseated.shift() }; }
            return d;
          });
          // Create new desks for remaining
          for (var i = 0; i < unseated.length; i++) {
            currentDesks.push({ id: Date.now() + Math.random(), x: 50 + (i % 5) * 110, y: 50 + Math.floor(i / 5) * 80 + 100, student: unseated[i], color: "blue", type: "student", rotation: 0 });
          }
        }
        if (needsUpdate) updateData(widget.id, { desks: currentDesks });
      }, [roster, widget.id]);

      const toggleAbsence = (studentName, e) => { if (e) { e.preventDefault(); e.stopPropagation(); } if (!studentName || !onUpdateRoster) return; const updated = roster.map(s => s.name === studentName ? { ...s, active: !s.active } : s); onUpdateRoster(updated); };

      const handleMouseDown = (e, deskId) => {
        if (!isEditing) return;
        e.stopPropagation();

        let newSelection = [...selectedDeskIds];
        if (e.ctrlKey || e.metaKey) {
          if (newSelection.includes(deskId)) newSelection = newSelection.filter(id => id !== deskId);
          else newSelection.push(deskId);
        } else {
          if (!newSelection.includes(deskId)) newSelection = [deskId];
        }

        setSelectedDeskIds(newSelection);
        setDraggedDesk(deskId);

        // Capture initial state for drag
        dragStartMouse.current = { x: e.clientX, y: e.clientY };
        const initialPos = {};
        desks.forEach(d => { initialPos[d.id] = { x: d.x, y: d.y }; });
        initialDeskPositions.current = initialPos;
      };

      const handleBgMouseDown = (e) => {
        if (!isEditing) { setSelectedDeskIds([]); return; }
        if (e.target !== containerRef.current) return;
        setSelectedDeskIds([]);
        const rect = containerRef.current.getBoundingClientRect();
        setIsSelecting(true);
        setSelectionBox({ startX: e.nativeEvent.offsetX, startY: e.nativeEvent.offsetY, x: e.nativeEvent.offsetX, y: e.nativeEvent.offsetY, w: 0, h: 0 });
      };

      const handleRotateMouseDown = (e, deskId) => { if (!isEditing) return; e.stopPropagation(); setRotatingDesk(deskId); };

      const handleGlobalMouseMove = (e) => {
        if (isSelecting && selectionBox) {
          const rect = containerRef.current.getBoundingClientRect();
          const currentX = e.clientX - rect.left;
          const currentY = e.clientY - rect.top;
          const x = Math.min(selectionBox.startX, currentX);
          const y = Math.min(selectionBox.startY, currentY);
          const w = Math.abs(currentX - selectionBox.startX);
          const h = Math.abs(currentY - selectionBox.startY);
          setSelectionBox(prev => ({ ...prev, x, y, w, h }));
        }
        else if (draggedDesk && isEditing) {
          e.stopPropagation(); e.preventDefault();
          const totalDx = e.clientX - dragStartMouse.current.x;
          const totalDy = e.clientY - dragStartMouse.current.y;

          // Calculate "Leader" new position (the one we clicked)
          const leaderStart = initialDeskPositions.current[draggedDesk];
          if (!leaderStart) return;

          let rawNewX = leaderStart.x + totalDx;
          let rawNewY = leaderStart.y + totalDy;

          // Snap the leader
          let finalLeaderX = rawNewX;
          let finalLeaderY = rawNewY;

          if (snapToGrid > 0) {
            finalLeaderX = Math.round(rawNewX / snapToGrid) * snapToGrid;
            finalLeaderY = Math.round(rawNewY / snapToGrid) * snapToGrid;
          }

          // Calculate effective delta to apply to all selected items
          const effectiveDx = finalLeaderX - leaderStart.x;
          const effectiveDy = finalLeaderY - leaderStart.y;

          updateData(widget.id, {
            desks: desks.map(d => {
              if (selectedDeskIds.includes(d.id)) {
                const start = initialDeskPositions.current[d.id];
                if (!start) return d;
                return { ...d, x: start.x + effectiveDx, y: start.y + effectiveDy };
              }
              return d;
            })
          });
        }
        else if (rotatingDesk && isEditing) {
          e.preventDefault();
          const desk = desks.find(d => d.id === rotatingDesk);
          if (desk && containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            const deskCenterX = rect.left + desk.x + (desk.type === "teacher" ? 80 : 56);
            const deskCenterY = rect.top + desk.y + (desk.type === "teacher" ? 40 : 32);
            let angle = Math.atan2(e.clientY - deskCenterY, e.clientX - deskCenterX) * (180 / Math.PI);
            if (snapToGrid > 0) angle = Math.round(angle / 15) * 15;
            updateData(widget.id, { desks: desks.map(d => { if (d.id === rotatingDesk) return { ...d, rotation: angle + 45 }; return d; }) });
          }
        }
      };

      const handleGlobalMouseUp = () => {
        if (isSelecting && selectionBox) {
          // Commit selection
          const { x, y, w, h } = selectionBox;
          const selected = desks.filter(d => {
            // Simple center point collision
            const cx = d.x + (d.type === 'teacher' ? 40 : 28);
            const cy = d.y + (d.type === 'teacher' ? 20 : 16);
            return cx >= x && cx <= x + w && cy >= y && cy <= y + h;
          }).map(d => d.id);
          setSelectedDeskIds(selected);
          setIsSelecting(false);
          setSelectionBox(null);
        }
        setDraggedDesk(null);
        setRotatingDesk(null);
        setIsSelecting(false); // Cleanup just in case
      };

      useEffect(() => {
        if (isEditing) {
          window.addEventListener("mousemove", handleGlobalMouseMove);
          window.addEventListener("mouseup", handleGlobalMouseUp);
          return () => {
            window.removeEventListener("mousemove", handleGlobalMouseMove);
            window.removeEventListener("mouseup", handleGlobalMouseUp);
          };
        }
      }, [isEditing, draggedDesk, rotatingDesk, isSelecting, selectionBox, desks, snapToGrid]);

      const handleColorClick = (color) => {
        if (selectedDeskIds.length > 0) {
          updateData(widget.id, { desks: desks.map(d => selectedDeskIds.includes(d.id) ? { ...d, color } : d) });
        } else {
          const newDesk = { id: Date.now().toString(), x: 50, y: 50, student: null, color, type: 'student', rotation: 0 };
          updateData(widget.id, { desks: [...desks, newDesk] });
        }
      };

      const addTeacher = () => {
        const newDesk = { id: Date.now().toString(), x: 50, y: 50, student: null, color: "gray", type: "teacher", rotation: 0 };
        updateData(widget.id, { desks: [...desks, newDesk] });
      };

      const removeDesk = (id) => updateData(widget.id, { desks: desks.filter(d => d.id !== id) });
      const removeSelected = () => {
        updateData(widget.id, { desks: desks.filter(d => !selectedDeskIds.includes(d.id)) });
        setSelectedDeskIds([]);
      };

      const shuffleSeats = () => {
        const activeStudentNames = roster.filter(s => s.active).map(s => s.name);
        if (activeStudentNames.length === 0) { alert("No active students in roster!"); return; }

        const studentDesks = desks.filter(d => d.type === 'student');
        if (studentDesks.length === 0) return;

        // Create pool of "occupants": all active students + nulls for empty/remaining
        let pool = [...activeStudentNames];
        // If we have more desks than students, fill with nulls
        while (pool.length < studentDesks.length) pool.push(null);

        // Shuffle the pool (students AND empty spots)
        pool = pool.sort(() => Math.random() - 0.5);

        let poolIndex = 0;
        const newDesks = desks.map(d => {
          if (d.type !== 'student') return d;
          if (poolIndex < pool.length) {
            const student = pool[poolIndex++];
            return { ...d, student };
          }
          return { ...d, student: null };
        });

        updateData(widget.id, { desks: newDesks });
      };

      return (
        <div className="flex flex-col h-full bg-slate-50 relative overflow-hidden select-none">
          <div className="h-12 bg-white border-b flex items-center justify-between px-4 z-10 shrink-0 select-none">
            <h3 className="font-bold text-slate-700 flex items-center gap-2"><Layout size={18} /> Class Layout</h3>
            <div className="flex gap-2 items-center">
              {isEditing ? (<>
                <div className="flex items-center gap-2 mr-2">
                  <button onClick={(e) => { e.stopPropagation(); updateData(widget.id, { snapToGrid: snapToGrid > 0 ? 0 : 10 }); }} className={`px-2 py-1 rounded text-[10px] font-bold uppercase transition-colors mr-2 ${snapToGrid > 0 ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-400 hover:bg-gray-200'}`}>
                    Snap: {snapToGrid > 0 ? 'On' : 'Off'}
                  </button>
                  <div className="w-px h-6 bg-gray-200" />
                  <div className="flex bg-gray-100 rounded-lg p-0.5">
                    {["blue", "red", "green", "yellow"].map(c => (<button key={c} onClick={(e) => { e.stopPropagation(); handleColorClick(c); }} className={`w-6 h-6 rounded border m-0.5 hover:scale-110 transition-transform ${DESK_COLORS[c].split(" ")[0]} ${DESK_COLORS[c].split(" ")[1]}`} />))}
                    <button onClick={(e) => { e.stopPropagation(); addTeacher(); }} className="px-2 h-6 rounded bg-slate-600 text-[10px] m-0.5 text-white font-bold flex items-center gap-1 hover:scale-105 transition-transform"><Briefcase size={10} /> Teacher</button>
                    {selectedDeskIds.length > 0 && <button onClick={removeSelected} className="px-2 h-6 rounded bg-red-100 text-red-600 text-[10px] m-0.5 font-bold flex items-center gap-1 hover:bg-red-200"><Trash2 size={10} /></button>}
                  </div>
                </div>
                <button onClick={(e) => { e.stopPropagation(); updateData(widget.id, { isEditing: false }); setSelectedDeskIds([]); }} className="px-3 py-1 bg-green-600 text-white rounded text-xs font-bold shadow hover:bg-green-700">Done</button>
              </>) : (<>
                <button onClick={shuffleSeats} className="px-3 py-1 bg-indigo-600 text-white rounded text-xs font-bold shadow hover:bg-indigo-700 flex items-center gap-1"><Shuffle size={12} /> Shuffle</button>
                <button onClick={() => updateData(widget.id, { isEditing: true })} className="px-3 py-1 bg-white border border-gray-300 text-gray-600 rounded text-xs font-bold hover:bg-gray-50 flex items-center gap-1"><Edit3 size={12} /> Edit</button>
              </>)}
            </div>
          </div>
          <div ref={containerRef} className={`flex-1 relative overflow-hidden ${isEditing ? "bg-slate-100" : "bg-slate-50"}`} style={{ backgroundImage: isEditing ? "radial-gradient(#cbd5e1 1px, transparent 1px)" : "none", backgroundSize: `${Math.max(20, snapToGrid || 20)}px ${Math.max(20, snapToGrid || 20)}px` }} onMouseDown={handleBgMouseDown}>
            {desks.map(desk => {
              const isAbsent = desk.student && roster.find(s => s.name === desk.student && !s.active);
              const styleClass = desk.type === "teacher" ? "bg-slate-800 border-slate-600 text-white shadow-lg w-28 h-14 rounded-md" : `${DESK_COLORS[desk.color || "blue"]} w-20 h-11 rounded-lg`;
              const isSelected = selectedDeskIds.includes(desk.id);
              return (<div key={desk.id} onContextMenu={(e) => toggleAbsence(desk.student, e)} className={`absolute shadow-sm border-2 flex items-center justify-center transition-shadow ${isEditing ? "cursor-move hover:shadow-md" : "cursor-pointer"} ${styleClass} ${isAbsent ? "opacity-60" : ""} ${isSelected ? "ring-2 ring-blue-500 ring-offset-2 z-10" : ""}`} style={{ left: desk.x, top: desk.y, transform: `rotate(${desk.rotation || 0}deg)`, fontSize: (desk.type === 'teacher' ? 14 : fontSize) + 'px' }} onMouseDown={(e) => handleMouseDown(e, desk.id)} >
                {isAbsent && <div className="absolute -bottom-2 -left-2 bg-red-500 text-white text-[8px] font-bold px-1.5 py-0.5 rounded-full z-30 shadow-sm pointer-events-none">OUT</div>}
                {isEditing && (<>
                  <button onClick={(e) => { e.stopPropagation(); removeDesk(desk.id); }} className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-0.5 shadow-sm hover:bg-red-600 w-5 h-5 flex items-center justify-center z-20"><X size={12} strokeWidth={3} /></button>
                  <div onMouseDown={(e) => handleRotateMouseDown(e, desk.id)} className="absolute -top-3 -left-3 bg-blue-500 text-white rounded-full p-1 shadow-sm hover:bg-blue-600 w-6 h-6 flex items-center justify-center z-20 cursor-grab active:cursor-grabbing"><RotateCw size={14} strokeWidth={2.5} /></div>
                </>)}
                {/* Fix text selection on name */}
                {desk.type === "teacher" ? <div className="flex flex-col items-center opacity-80 select-none"><Briefcase size={16} className="mb-0.5" /><span className="text-[8px] uppercase font-bold tracking-widest">Teacher</span></div> : (desk.student ? <span className={`font-bold text-center px-0.5 truncate w-full text-[11px] select-none ${isAbsent ? 'text-slate-400 line-through' : 'text-slate-800'}`}>{desk.student}</span> : <span className={`italic text-[10px] select-none ${desk.color === "yellow" ? "text-yellow-700/50" : "text-slate-300"}`}>Empty</span>)}
                {desk.type !== "teacher" && <div className={`absolute -bottom-1 w-8 h-1 rounded-full ${desk.color === "yellow" ? "bg-yellow-200" : "bg-slate-200"}`} />}
              </div>);
            })}

            {/* Selection Box Visual */}
            {isSelecting && selectionBox && (
              <div className="absolute border border-blue-500 bg-blue-500/10 pointer-events-none z-50" style={{ left: selectionBox.x, top: selectionBox.y, width: selectionBox.w, height: selectionBox.h }} />
            )}
          </div>
        </div>);
    };


    const TextWidget = ({ widget, updateData }) => {
      const { items = [], content = "", mode = 'text', fontSize = 16, color = 'yellow' } = widget.data;
      const [newItemText, setNewItemText] = useState("");
      const editorRef = useRef(null);
      const [formats, setFormats] = useState({ bold: false, italic: false, underline: false });
      const [showColorMenu, setShowColorMenu] = useState(false);
      const [draggedItemIndex, setDraggedItemIndex] = useState(null);
      const [focusId, setFocusId] = useState(null);

      const COLORS = {
        yellow: { bg: 'bg-yellow-100', header: 'bg-yellow-100', text: 'text-yellow-900', border: 'border-yellow-300' },
        blue: { bg: 'bg-blue-50', header: 'bg-blue-100', text: 'text-blue-900', border: 'border-blue-300' },
        green: { bg: 'bg-green-50', header: 'bg-green-100', text: 'text-green-900', border: 'border-green-300' },
        pink: { bg: 'bg-pink-50', header: 'bg-pink-100', text: 'text-pink-900', border: 'border-pink-300' },
        purple: { bg: 'bg-purple-50', header: 'bg-purple-100', text: 'text-purple-900', border: 'border-purple-300' }
      };
      const theme = COLORS[color] || COLORS.yellow;

      const updateFormats = () => {
        setFormats({
          bold: document.queryCommandState('bold'),
          italic: document.queryCommandState('italic'),
          underline: document.queryCommandState('underline')
        });
      };

      const exec = (command) => {
        document.execCommand(command, false, null);
        updateFormats();
        if (editorRef.current) updateData(widget.id, { content: editorRef.current.innerHTML });
      };

      useEffect(() => {
        if (mode === 'text' && editorRef.current && document.activeElement !== editorRef.current) {
          if (editorRef.current.innerHTML !== (content || '')) {
            editorRef.current.innerHTML = content || '';
          }
        }
      }, [content, mode]);

      const addItem = () => {
        if (!newItemText.trim()) return;
        const newItem = { id: Date.now().toString(), text: newItemText.trim(), completed: false };
        updateData(widget.id, { items: [...items, newItem] });
        setNewItemText("");
      };

      const addItemAtIndex = (index) => {
        const newItem = { id: Date.now().toString(), text: "", completed: false };
        const newItems = [...items];
        newItems.splice(index + 1, 0, newItem);
        updateData(widget.id, { items: newItems });
        setFocusId(newItem.id);
      };

      const toggleItem = (id) => updateData(widget.id, { items: items.map(i => i.id === id ? { ...i, completed: !i.completed } : i).sort((a, b) => (a.completed === b.completed ? 0 : a.completed ? 1 : -1)) });
      const deleteItem = (id) => updateData(widget.id, { items: items.filter(i => i.id !== id) });
      const updateItemText = (id, text) => updateData(widget.id, { items: items.map(i => i.id === id ? { ...i, text } : i) });

      const toggleMode = () => {
        if (mode === 'text') {
          const tempDiv = document.createElement('div');
          // Use innerText to get representative text, but be careful of duplication
          tempDiv.innerHTML = content || "";
          const rawText = tempDiv.innerText || "";
          // Split by newline, trim, and remove empty lines
          const validLines = rawText.split('\n').map(l => l.trim()).filter(l => l.length > 0);
          // Create items
          const newItems = validLines.map((text, i) => ({ id: Date.now() + i + '', text, completed: false }));
          // CRITICAL: Explicitly set content to empty string to prevent ghost rendering
          updateData(widget.id, { mode: 'list', items: newItems, content: "" });
        } else {
          const newContent = items.map(i => `<div>${i.text}</div>`).join('');
          updateData(widget.id, { mode: 'text', content: newContent, items: [] });
        }
      };

      const handleDragStart = (e, index) => { setDraggedItemIndex(index); };
      const handleDragOver = (e, index) => {
        e.preventDefault();
        if (draggedItemIndex === null || draggedItemIndex === index) return;
        const newItems = [...items];
        const item = newItems[draggedItemIndex];
        newItems.splice(draggedItemIndex, 1);
        newItems.splice(index, 0, item);
        setDraggedItemIndex(index);
        updateData(widget.id, { items: newItems });
      };
      const handleDragEnd = () => { setDraggedItemIndex(null); };

      return (
        <div className={`h-full flex flex-col relative group ${theme.bg}`} style={{ boxShadow: 'inset 0 0 20px rgba(0,0,0,0.05)', fontFamily: 'Poppins, sans-serif' }} onClick={() => setShowColorMenu(false)}>
          <div className={`h-10 flex items-center px-4 shrink-0 relative z-20 justify-between ${theme.header} border-b ${theme.border} bg-opacity-50`}>
            <div className="flex items-center gap-2">
              <button onClick={(e) => { e.stopPropagation(); setShowColorMenu(!showColorMenu); }} className={`w-4 h-4 rounded-full border border-black/10 shadow-sm ${theme.bg.replace('50', '400').replace('100', '400')}`} />
              {showColorMenu && (
                <div className="absolute top-8 left-2 bg-white p-2 rounded-xl shadow-xl flex gap-1 z-50 border border-gray-100">
                  {Object.keys(COLORS).map(c => (
                    <button key={c} onClick={(e) => { e.stopPropagation(); updateData(widget.id, { color: c }); setShowColorMenu(false); }} className={`w-6 h-6 rounded-full border hover:scale-110 transition-transform ${COLORS[c].bg.replace('50', '500').replace('100', '500')}`} />
                  ))}
                </div>
              )}
              <span className={`font-bold text-xs uppercase tracking-widest flex items-center gap-2 ${theme.text} opacity-50`}>Note</span>
            </div>
            <div className="flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
              {mode === 'text' && (
                <>
                  <button onClick={() => exec('bold')} className={`p-1 rounded ${formats.bold ? 'bg-black/10 text-black' : 'hover:bg-black/5 text-black/50'} transition-all`}><Bold size={12} /></button>
                  <button onClick={() => exec('italic')} className={`p-1 rounded ${formats.italic ? 'bg-black/10 text-black' : 'hover:bg-black/5 text-black/50'} transition-all`}><Italic size={12} /></button>
                  <button onClick={() => exec('underline')} className={`p-1 rounded ${formats.underline ? 'bg-black/10 text-black' : 'hover:bg-black/5 text-black/50'} transition-all`}><Underline size={12} /></button>
                </>
              )}
              <div className="w-px h-4 bg-black/10 mx-1" />
              <button onClick={toggleMode} className={`p-1 hover:bg-black/5 rounded ${theme.text} opacity-70 hover:opacity-100`} title="Switch Mode">
                {mode === 'text' ? <List size={14} /> : <Type size={14} />}
              </button>
            </div>
          </div>
          <div className="flex-1 relative overflow-hidden flex flex-col">
            {mode === 'text' ? (
              <div ref={editorRef} className="w-full h-full p-4 outline-none overflow-auto custom-scrollbar leading-relaxed text-lg" contentEditable suppressContentEditableWarning onInput={(e) => updateData(widget.id, { content: e.currentTarget.innerHTML })} onKeyUp={updateFormats} onMouseUp={updateFormats} style={{ fontSize: fontSize + 'px' }} placeholder="Type a note..." />
            ) : (
              <>
                <div className="flex-1 overflow-y-auto custom-scrollbar p-2 pl-4 z-10">
                  <div className="space-y-1">
                    {items.map((item, idx) => (
                      <div key={item.id} draggable onDragStart={(e) => handleDragStart(e, idx)} onDragOver={(e) => handleDragOver(e, idx)} onDragEnd={handleDragEnd} className={`group/item flex items-start gap-2 p-1 rounded hover:bg-black/5 transition-colors ${item.completed ? 'opacity-50' : ''} ${draggedItemIndex === idx ? 'opacity-30' : ''}`}>
                        <div className="mt-1 cursor-grab active:cursor-grabbing text-gray-300 hover:text-gray-500"><GripVertical size={12} /></div>
                        <button onClick={() => toggleItem(item.id)} className={`mt-1 w-4 h-4 rounded border flex items-center justify-center shrink-0 transition-colors ${item.completed ? 'bg-green-500 border-green-500' : 'border-gray-400 bg-white'}`}>
                          {item.completed && <Check size={10} className="text-white" />}
                        </button>
                        <input
                          value={item.text}
                          onChange={(e) => updateItemText(item.id, e.target.value)}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                              e.preventDefault();
                              addItemAtIndex(idx);
                            }
                          }}
                          className={`flex-1 bg-transparent border-none outline-none text-sm font-medium break-words leading-snug pt-0.5 ${item.completed ? 'line-through text-gray-500' : 'text-slate-800'}`}
                          style={{ fontSize: fontSize + 'px' }}
                          autoFocus={item.id === focusId}
                        />
                        <div className="opacity-0 group-hover/item:opacity-100 flex gap-1">
                          <button onClick={() => deleteItem(item.id)} className="text-gray-300 hover:text-red-500"><X size={14} /></button>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
                <div className={`p-3 border-t ${theme.border} shrink-0 z-10 flex gap-2 bg-white/30`}>
                  <input type="text" value={newItemText} onChange={(e) => setNewItemText(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && addItem()} placeholder="Add item..." className="flex-1 bg-white/80 border-none rounded-lg px-3 py-1.5 text-sm outline-none focus:ring-2 focus:ring-black/10 placeholder-gray-400" />
                  <button onClick={addItem} disabled={!newItemText.trim()} className="bg-white hover:bg-white text-green-600 p-1.5 rounded-lg shadow-sm transition-all"><Plus size={18} /></button>
                </div>
              </>
            )}
          </div>
        </div>
      );
    };

    const DiceWidget = ({ widget, updateData }) => {
      const { sides = 6, diceCount = 1, results = [1], isRolling, fontSize = 16 } = widget.data;
      const [showSettings, setShowSettings] = useState(false);
      // Ensure results match diceCount
      const displayResults = (results && results.length === diceCount) ? results : Array(diceCount).fill(1).map((_, i) => (results[i] || 1));

      const roll = () => {
        if (isRolling) return;
        updateData(widget.id, { isRolling: true });
        let count = 0;
        const animate = () => {
          const temp = Array.from({ length: diceCount }, () => Math.floor(Math.random() * sides) + 1);
          updateData(widget.id, { results: temp });
          count++;
          if (count < 10) { setTimeout(animate, 80); }
          else { updateData(widget.id, { isRolling: false }); }
        };
        animate();
      };

      const renderDot = (active) => <div className={`w-2.5 h-2.5 rounded-full ${active ? 'bg-indigo-600' : 'bg-transparent'}`} />; // Slightly smaller dots for 2 dice

      const renderFace = (num) => {
        if (sides !== 6) return <span className="font-black text-indigo-800" style={{ fontSize: (fontSize * 3) + 'px' }}>{num}</span>;

        // D6 Dot Layout
        const positions = {
          1: [4], 2: [0, 8], 3: [0, 4, 8], 4: [0, 2, 6, 8], 5: [0, 2, 4, 6, 8], 6: [0, 2, 3, 5, 6, 8]
        };
        const activeDots = positions[num] || [];
        return (
          <div className="grid grid-cols-3 gap-1 p-2">
            {[0, 1, 2, 3, 4, 5, 6, 7, 8].map(i => renderDot(activeDots.includes(i)))}
          </div>
        );
      };

      if (showSettings) {
        return (
          <div className="h-full bg-white flex flex-col p-4">
            <div className="flex justify-between items-center mb-4"><h3 className="font-bold">Dice Settings</h3><button onClick={() => setShowSettings(false)} className="text-blue-600">Done</button></div>
            <div className="space-y-4">
              <div>
                <label className="text-sm font-bold text-gray-700 block mb-2">Number of Dice</label>
                <div className="flex gap-2">
                  {[1, 2, 3].map(num => (
                    <button
                      key={num}
                      onClick={() => updateData(widget.id, { diceCount: num })}
                      className={`flex-1 py-2 rounded-lg font-bold transition-colors ${diceCount === num ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                    >
                      {num}
                    </button>
                  ))}
                </div>
              </div>
              <div>
                <label className="text-sm font-bold text-gray-700 block mb-2">Sides: {sides}</label>
                <input type="range" min="2" max="20" value={sides} onChange={e => updateData(widget.id, { sides: Number(e.target.value) })} className="w-full accent-indigo-600" />
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="h-full bg-gradient-to-br from-indigo-50 to-white flex flex-col items-center justify-center relative p-4 select-none cursor-pointer group" onClick={roll} style={{ transform: `scale(${fontSize / 16})`, transformOrigin: 'center' }}>
          <button onClick={(e) => { e.stopPropagation(); setShowSettings(true); }} className="absolute top-2 right-2 p-2 text-gray-300 hover:text-indigo-600 rounded-full hover:bg-indigo-50 opacity-0 group-hover:opacity-100 transition-opacity"><Settings size={16} /></button>

          <div className="flex gap-4 items-center justify-center w-full h-full">
            {displayResults.map((val, idx) => (
              <div key={idx} className={`relative shadow-xl border-2 border-indigo-100 flex items-center justify-center transform transition-transform bg-white ${isRolling ? 'rotate-180 scale-105' : ''} ${diceCount === 1 ? 'w-32 h-32 rounded-2xl' : 'w-24 h-24 rounded-xl'}`}>
                {renderFace(val)}
              </div>
            ))}
          </div>

          <div className="text-indigo-400 font-bold text-[10px] uppercase mt-4 tracking-widest absolute bottom-4">{isRolling ? "Rolling..." : `Click to Roll`}</div>
        </div>
      );
    };

    const VoteWidget = ({ widget, updateData }) => {
      const { question = "Class Poll", options = [{ id: 1, text: "Yes", count: 0 }, { id: 2, text: "No", count: 0 }], fontSize = 16 } = widget.data;
      const [isEditing, setIsEditing] = useState(false);

      const vote = (id) => updateData(widget.id, { options: options.map(o => o.id === id ? { ...o, count: o.count + 1 } : o) });
      const totalVotes = options.reduce((acc, o) => acc + o.count, 0) || 1; // avoid /0

      const updateOption = (id, text) => updateData(widget.id, { options: options.map(o => o.id === id ? { ...o, text } : o) });
      const addOption = () => updateData(widget.id, { options: [...options, { id: Date.now(), text: "", count: 0 }] });
      const removeOption = (id) => updateData(widget.id, { options: options.filter(o => o.id !== id) });
      const resetCounts = () => updateData(widget.id, { options: options.map(o => ({ ...o, count: 0 })) });

      if (isEditing) {
        return (
          <div className="h-full bg-white flex flex-col p-4 overflow-hidden">
            <div className="flex justify-between items-center mb-2"><h3 className="font-bold text-sm">Edit Poll</h3><button onClick={() => setIsEditing(false)} className="text-blue-600 font-bold text-xs bg-blue-50 px-2 py-1 rounded">Done</button></div>
            <div className="flex-1 overflow-y-auto custom-scrollbar space-y-2">
              <div className="space-y-1">
                <label className="text-[10px] font-bold uppercase text-gray-400">Question</label>
                <input className="w-full border rounded p-1 text-sm font-bold" value={question} onChange={e => updateData(widget.id, { question: e.target.value })} />
              </div>
              <div className="space-y-1">
                <label className="text-[10px] font-bold uppercase text-gray-400">Options</label>
                {options.map((o, i) => (
                  <div key={o.id} className="flex gap-1 items-center">
                    <input className="flex-1 border rounded p-1 text-sm" value={o.text} onChange={e => updateOption(o.id, e.target.value)} placeholder={`Option ${i + 1}`} />
                    <button onClick={() => removeOption(o.id)} className="text-red-400 hover:text-red-600"><Trash2 size={14} /></button>
                  </div>
                ))}
                <button onClick={addOption} className="text-blue-600 text-xs font-bold hover:underline flex items-center gap-1">+ Add Option</button>
              </div>
            </div>
            <button onClick={resetCounts} className="mt-2 w-full py-2 border border-red-200 text-red-600 rounded text-xs font-bold hover:bg-red-50">Reset Votes</button>
          </div>
        );
      }

      return (
        <div className="h-full bg-white flex flex-col p-4 relative group">
          <button onClick={() => setIsEditing(true)} className="absolute top-2 right-2 p-1 text-gray-300 hover:text-blue-600 rounded hover:bg-blue-50 opacity-0 group-hover:opacity-100 transition-opacity"><Settings size={14} /></button>
          <h3 className="font-bold text-center mb-4 text-gray-800" style={{ fontSize: fontSize + 'px' }}>{question}</h3>
          <div className="flex-1 overflow-y-auto custom-scrollbar space-y-2">
            {options.map(o => {
              const pct = Math.round((o.count / totalVotes) * 100);
              return (
                <div key={o.id} onClick={() => vote(o.id)} className="cursor-pointer group/opt">
                  <div className="flex justify-between mb-1 font-medium text-gray-600" style={{ fontSize: (fontSize - 2) + 'px' }}><span>{o.text || "Option"}</span><span>{o.count} ({options.every(x => x.count === 0) ? 0 : pct}%)</span></div>
                  <div className="h-8 bg-gray-100 rounded-lg overflow-hidden relative">
                    <div className="absolute top-0 left-0 bottom-0 bg-blue-500 transition-all duration-500 ease-out" style={{ width: options.every(x => x.count === 0) ? '0%' : `${pct}%` }} />
                    <div className="absolute inset-0 hover:bg-black/5 transition-colors" />
                  </div>
                </div>
              );
            })}
          </div>
          <div className="mt-2 text-center text-[10px] text-gray-400 uppercase tracking-widest">{options.reduce((a, b) => a + b.count, 0)} Total Votes</div>
        </div>
      );
    };

    const TrafficLightWidget = ({ widget, updateData }) => {
      const { activeLight, isListening = false, sensitivity = 50, threshold = 80, showSettings = false, fontSize = 16 } = widget.data;
      const audioContextRef = useRef(null);
      const analyserRef = useRef(null);
      const dataArrayRef = useRef(null);
      const rafId = useRef(null);

      // Cleanup audio on unmount or when listening stops
      useEffect(() => {
        if (isListening) startAudio();
        else stopAudio();
        return () => stopAudio();
      }, [isListening]);

      // Re-run analysis if sensitivity/threshold changes while listening
      useEffect(() => {
        if (isListening && !rafId.current) analyze();
      }, [sensitivity, threshold]);

      const startAudio = async () => {
        if (audioContextRef.current) return;
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          audioContextRef.current = audioCtx;
          const analyser = audioCtx.createAnalyser();
          analyserRef.current = analyser;
          const source = audioCtx.createMediaStreamSource(stream);
          source.connect(analyser);
          analyser.fftSize = 256;
          const bufferLength = analyser.frequencyBinCount;
          dataArrayRef.current = new Uint8Array(bufferLength);
          analyze();
        } catch (e) {
          console.error(e);
          alert('Mic Error: ' + e.message);
          updateData(widget.id, { isListening: false });
        }
      };

      const stopAudio = () => {
        if (rafId.current) cancelAnimationFrame(rafId.current);
        rafId.current = null;
        if (audioContextRef.current) {
          audioContextRef.current.close();
          audioContextRef.current = null;
        }
      };

      const analyze = () => {
        if (!analyserRef.current || !dataArrayRef.current) return;
        analyserRef.current.getByteFrequencyData(dataArrayRef.current);

        let sum = 0;
        const data = dataArrayRef.current;
        for (let i = 0; i < data.length; i++) sum += data[i];
        const avg = sum / data.length;

        // Apply sensitivity (1-100) -> Multiplier (0.5 - 3.0)
        // Sensitivity 50 = 1.0x
        const multiplier = 0.5 + (sensitivity / 50);
        const volume = Math.min(avg * multiplier, 255);

        // Threshold (1-100) -> Cutoff (0-255)
        const limit = (threshold / 100) * 255;

        // Determine Light
        let newLight = 'green';
        if (volume > limit) {
          newLight = 'red';
        } else if (volume > limit * 0.7) {
          newLight = 'yellow';
        }

        // Only update if changed to avoid React render thrashing, but need to be responsive
        // We can just update locally or throttle updates? 
        // For this app, updateData triggers re-render of this widget only usually. 
        // Let's debounce slightly or just check if diff.
        if (newLight !== activeLight) {
          updateData(widget.id, { activeLight: newLight });
        }

        rafId.current = requestAnimationFrame(analyze);
      };

      if (showSettings) {
        return (
          <div className="h-full flex flex-col p-4 bg-white rounded-2xl border border-gray-200 shadow-xl overflow-hidden relative">
            <div className="flex justify-between items-center mb-4 text-gray-700">
              <h3 className="font-bold text-sm uppercase tracking-wider">Settings</h3>
              <button onClick={() => updateData(widget.id, { showSettings: false })} className="text-gray-400 hover:text-gray-700"><X size={18} /></button>
            </div>
            <div className="space-y-4 flex-1">
              <div>
                <label className="text-[10px] font-bold text-gray-400 uppercase block mb-1">Sensitivity ({sensitivity}%)</label>
                <input type="range" min="1" max="100" value={sensitivity} onChange={e => updateData(widget.id, { sensitivity: Number(e.target.value) })} className="w-full accent-blue-500 h-1 bg-gray-200 rounded-lg appearance-none" />
              </div>
              <div>
                <label className="text-[10px] font-bold text-gray-400 uppercase block mb-1">Max Volume ({threshold}%)</label>
                <input type="range" min="1" max="100" value={threshold} onChange={e => updateData(widget.id, { threshold: Number(e.target.value) })} className="w-full accent-red-500 h-1 bg-gray-200 rounded-lg appearance-none" />
              </div>
              <div className="text-[10px] text-gray-500 italic mt-2">
                Higher sensitivity = detects quieter sounds.<br />
                Lower Max Volume = Red light triggers sooner.
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="h-full flex flex-col items-center justify-center gap-3 p-4 bg-white rounded-2xl border border-gray-200 shadow-xl relative group" style={{ transform: `scale(${fontSize / 16})`, transformOrigin: 'center' }}>
          <div className="absolute top-2 right-2 flex flex-col gap-2 opacity-0 group-hover:opacity-100 transition-opacity z-10">
            <button
              onClick={() => updateData(widget.id, { showSettings: true })}
              className="p-1.5 bg-gray-100 text-gray-400 hover:text-blue-600 rounded-full hover:bg-blue-50 transition-colors"
              title="Settings"
            >
              <Settings size={14} />
            </button>
            <button
              onClick={() => updateData(widget.id, { isListening: !isListening })}
              className={`p-1.5 rounded-full transition-colors ${isListening ? 'bg-red-500 text-white animate-pulse' : 'bg-gray-100 text-gray-400 hover:text-red-500 hover:bg-red-50'}`}
              title={isListening ? "Stop Auto-Listen" : "Start Auto-Listen"}
            >
              {isListening ? <Mic size={14} /> : <Mic size={14} className="opacity-50" />}
            </button>
          </div>

          {['red', 'yellow', 'green'].map(color => (
            <div
              key={color}
              // Only allow manual click if NOT listening
              onClick={() => !isListening && updateData(widget.id, { activeLight: activeLight === color ? null : color })}
              className={`w-20 h-20 rounded-full transition-all duration-200 
                ${activeLight === color ? (
                  color === 'red' ? 'bg-red-500 shadow-[0_0_30px_rgba(239,68,68,0.8)] scale-105' :
                    color === 'yellow' ? 'bg-yellow-400 shadow-[0_0_30px_rgba(250,204,21,0.8)] scale-105' :
                      'bg-green-500 shadow-[0_0_30px_rgba(34,197,94,0.8)] scale-105'
                ) : 'bg-gray-100 scale-100'}
                ${!isListening ? 'cursor-pointer hover:opacity-80' : ''}
              `}
            />
          ))}
        </div>
      );
    };

    const QRCodeWidget = ({ widget, updateData }) => {
      const { url = '' } = widget.data;
      return (
        <div className="h-full flex flex-col p-4 bg-white relative group">
          <h3 className="text-center font-bold text-slate-700 mb-2 flex items-center justify-center gap-2"><QrCode size={16} /> QR Code</h3>
          <input
            className="w-full border rounded p-2 mb-2 text-xs"
            placeholder="https://..."
            value={url}
            onChange={(e) => updateData(widget.id, { url: e.target.value })}
          />
          <div className="flex-1 flex items-center justify-center bg-gray-50 rounded-lg p-4 overflow-hidden">
            {url ? (
              <img src={`https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(url)}`} alt="QR Code" className="w-full h-full object-contain mix-blend-multiply" />
            ) : (
              <div className="text-gray-400 text-[10px] text-center italic">Paste a URL above</div>
            )}
          </div>
        </div>
      );
    };

    const GRID_SIZE = 20;
    const HEADER_HEIGHT = 40;
    const WIDGET_TYPE_LABELS = { TIMER: 'Timer', RANDOMIZER: 'Random', GROUP_MAKER: 'Groups', SEAT_PICKER: 'Seats', TEXT: 'Notes', WEBCAM: 'Cam', DICE: 'Dice', TRAFFIC: 'Noise', QR: 'QR Code', VOTE: 'Poll', WHITEBOARD: 'Draw', SCHEDULE: 'Schedule', YOUTUBE: 'Embed' };

    // --- UTILS ---
    const DraggableResizable = ({ id, position, size, zIndex, isSelected, isMinimized = false, isSpotlighted = false, isGridEnabled = false, widgetType, onUpdate, onSelect, onRemove, onFontSizeChange, onMinimizeToggle, onSpotlight, children }) => {
      const [isDragging, setIsDragging] = useState(false); const [isResizing, setIsResizing] = useState(false); const startMousePos = useRef({ x: 0, y: 0 }); const startWidgetPos = useRef({ x: 0, y: 0 }); const startWidgetSize = useRef({ width: 0, height: 0 }); const onUpdateRef = useRef(onUpdate); const positionRef = useRef(position); const sizeRef = useRef(size); useEffect(() => { onUpdateRef.current = onUpdate; positionRef.current = position; sizeRef.current = size; }, [onUpdate, position, size]);
      const handleMouseDown = (e) => { e.stopPropagation(); onSelect(id); setIsDragging(true); startMousePos.current = { x: e.clientX, y: e.clientY }; startWidgetPos.current = { ...position }; };
      const handleResizeStart = (e) => { if (isMinimized) return; e.stopPropagation(); e.preventDefault(); onSelect(id); setIsResizing(true); startMousePos.current = { x: e.clientX, y: e.clientY }; startWidgetPos.current = { ...position }; startWidgetSize.current = { ...size }; };
      useEffect(() => { if (!isDragging && !isResizing) return; const handleMouseMove = (e) => { e.preventDefault(); const dx = e.clientX - startMousePos.current.x; const dy = e.clientY - startMousePos.current.y; if (isDragging) { let newX = startWidgetPos.current.x + dx; let newY = startWidgetPos.current.y + dy; if (isGridEnabled) { newX = Math.round(newX / GRID_SIZE) * GRID_SIZE; newY = Math.round(newY / GRID_SIZE) * GRID_SIZE; } onUpdateRef.current(id, { x: newX, y: newY }, sizeRef.current); } else if (isResizing) { let newWidth = Math.max(200, startWidgetSize.current.width + dx); let newHeight = Math.max(150, startWidgetSize.current.height + dy); if (isGridEnabled) { newWidth = Math.round(newWidth / GRID_SIZE) * GRID_SIZE; newHeight = Math.round(newHeight / GRID_SIZE) * GRID_SIZE; } onUpdateRef.current(id, positionRef.current, { width: newWidth, height: newHeight }); } }; const handleMouseUp = () => { if (isDragging) { const snappedX = Math.round(positionRef.current.x / GRID_SIZE) * GRID_SIZE; const snappedY = Math.round(positionRef.current.y / GRID_SIZE) * GRID_SIZE; onUpdateRef.current(id, { x: snappedX, y: snappedY }, sizeRef.current); } if (isResizing && isGridEnabled) { const snappedW = Math.round(sizeRef.current.width / GRID_SIZE) * GRID_SIZE; const snappedH = Math.round(sizeRef.current.height / GRID_SIZE) * GRID_SIZE; onUpdateRef.current(id, positionRef.current, { width: Math.max(200, snappedW), height: Math.max(150, snappedH) }); } setIsDragging(false); setIsResizing(false); }; window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', handleMouseUp); return () => { window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', handleMouseUp); }; }, [isDragging, isResizing, id, isGridEnabled]);
      const displayHeight = isMinimized ? HEADER_HEIGHT : size.height;
      const widgetLabel = WIDGET_TYPE_LABELS[widgetType] || widgetType || '';
      const computedZIndex = isSpotlighted ? 10000 : (isSelected ? 9999 : (zIndex + 100));
      return (<div className={`absolute flex flex-col bg-white rounded-xl shadow-xl overflow-hidden border-2 pointer-events-auto ${isDragging || isResizing ? '' : 'transition-all duration-200'} ${isSelected ? 'border-blue-500 shadow-2xl' : 'border-transparent border-gray-100'} ${isSpotlighted ? 'shadow-[0_0_80px_20px_rgba(255,255,255,0.3)]' : ''}`} style={{ left: position.x, top: position.y, width: size.width, height: displayHeight, zIndex: computedZIndex, touchAction: 'none' }} onMouseDown={() => { if (!isSelected) onSelect(id); }}> <div className="h-10 bg-gray-50 flex items-center justify-between px-2 cursor-move border-b border-gray-100 group select-none flex-shrink-0" onMouseDown={handleMouseDown}> <div className="flex items-center gap-1"> {onFontSizeChange && (<><button onClick={(e) => { e.stopPropagation(); onFontSizeChange?.(-2); }} className="p-1 text-gray-400 hover:text-blue-600 hover:bg-blue-100 rounded transition-colors"><Minus size={14} strokeWidth={3} /></button> <button onClick={(e) => { e.stopPropagation(); onFontSizeChange?.(2); }} className="p-1 text-gray-400 hover:text-blue-600 hover:bg-blue-100 rounded transition-colors"><Plus size={14} strokeWidth={3} /></button></>)} </div> <div className="flex-1 flex justify-center">{isMinimized ? <span className="text-xs font-bold text-gray-500 uppercase tracking-wider">{widgetLabel}</span> : <div className="w-12 h-1.5 bg-gray-300 rounded-full group-hover:bg-blue-400 transition-colors" />}</div> <div className="flex items-center gap-1"> {onSpotlight && (<button onClick={(e) => { e.stopPropagation(); onSpotlight(id); }} className={`p-1 rounded transition-colors ${isSpotlighted ? 'text-yellow-500 bg-yellow-100' : 'text-gray-400 hover:text-yellow-500 hover:bg-yellow-50'}`} title="Spotlight"> <Lightbulb size={14} /> </button>)} {onMinimizeToggle && (<button onClick={(e) => { e.stopPropagation(); onMinimizeToggle(id); }} className="p-1 text-gray-400 hover:text-blue-600 hover:bg-blue-100 rounded transition-colors" title={isMinimized ? "Restore" : "Minimize"}> <span className="font-bold text-sm leading-none">{isMinimized ? '+' : '−'}</span> </button>)} <button onClick={(e) => { e.stopPropagation(); onRemove(id); }} className="p-1 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded transition-colors"> <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> </button> </div> </div> {!isMinimized && <div className="flex-1 relative overflow-hidden flex flex-col custom-scrollbar">{children}</div>} {!isMinimized && <div className="absolute bottom-0 right-0 w-8 h-8 cursor-nwse-resize flex items-end justify-end p-1 opacity-0 hover:opacity-100 transition-opacity bg-gradient-to-tl from-gray-100 to-transparent z-10" onMouseDown={handleResizeStart}> <Maximize2 size={16} className="text-gray-400 transform rotate-90" /> </div>} </div>);
    };
    const TimerWidget = ({ widget, updateData }) => {
      const { durationMinutes = 2, timeLeft = 120, isRunning = false, fontSize = 16, mode = 'visual', color = 'blue', isMuted = false } = widget.data;
      const [customTime, setCustomTime] = useState("");
      const [showColorMenu, setShowColorMenu] = useState(false);
      const intervalRef = useRef(null);
      const isDraggingRef = useRef(false);
      const timerRef = useRef(null);

      // Colors
      const COLORS = {
        blue: { stroke: '#3b82f6', handle: '#2563eb', bg: 'bg-blue-500' },
        red: { stroke: '#ef4444', handle: '#dc2626', bg: 'bg-red-500' },
        green: { stroke: '#22c55e', handle: '#16a34a', bg: 'bg-green-500' },
        orange: { stroke: '#f97316', handle: '#ea580c', bg: 'bg-orange-500' },
        purple: { stroke: '#a855f7', handle: '#9333ea', bg: 'bg-purple-500' }
      };
      const theme = COLORS[color] || COLORS.blue;

      const playAlarm = () => {
        if (isMuted) return;
        try {
          // Wind chime sound
          const audio = new Audio('https://cdn.freesound.org/previews/352/352097_6403606-lq.mp3');
          audio.volume = 0.5;
          audio.play().catch(e => console.error("Audio play failed", e));
        } catch (e) { console.error(e); }
      };

      useEffect(() => {
        if (isRunning && timeLeft > 0) {
          intervalRef.current = window.setInterval(() => {
            updateData(widget.id, { timeLeft: Math.max(0, timeLeft - 1) });
          }, 1000);
        } else if (timeLeft === 0 && isRunning) {
          updateData(widget.id, { isRunning: false });
          playAlarm();
        }
        return () => { if (intervalRef.current) clearInterval(intervalRef.current); };
      }, [isRunning, timeLeft, widget.id, updateData]);

      const calculateTimeFromMouseEvent = (e) => {
        if (!timerRef.current) return;
        const rect = timerRef.current.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const x = e.clientX - cx;
        const y = e.clientY - cy;

        let angleRad = Math.atan2(y, x);
        let angle = angleRad + Math.PI / 2;
        if (angle < 0) angle += 2 * Math.PI;

        const totalMins = (angle / (2 * Math.PI)) * 60;
        const newSeconds = Math.max(0, Math.min(3600, Math.round(totalMins) * 60));

        return newSeconds;
      };

      const handleMouseDown = (e) => {
        if (isRunning) return;
        e.stopPropagation();
        e.preventDefault();
        isDraggingRef.current = true;

        const newTime = calculateTimeFromMouseEvent(e);
        if (newTime !== undefined) updateData(widget.id, { timeLeft: newTime });

        const handleGlobalMove = (ev) => {
          if (!isDraggingRef.current) return;
          ev.preventDefault();
          const t = calculateTimeFromMouseEvent(ev);
          if (t !== undefined) updateData(widget.id, { timeLeft: t });
        };

        const handleGlobalUp = () => {
          isDraggingRef.current = false;
          window.removeEventListener('mousemove', handleGlobalMove);
          window.removeEventListener('mouseup', handleGlobalUp);
        };

        window.addEventListener('mousemove', handleGlobalMove);
        window.addEventListener('mouseup', handleGlobalUp);
      };

      const toggleTimer = () => updateData(widget.id, { isRunning: !isRunning });
      const resetTimer = () => updateData(widget.id, { isRunning: false, timeLeft: 120 });
      const adjustTime = (delta) => updateData(widget.id, { timeLeft: Math.max(0, timeLeft + delta) });
      const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;

      const progress = timeLeft / 3600;
      const circum = 2 * Math.PI * 45; // Based on r=45?
      // Wait, we want the handle to be in the MIDDLE of the stroke.
      // Stroke width = 45.
      // Stroke is centered at r=22.5?
      // Circle r="22.5" stroke-width="45".
      // Inner radius = 0. Outer radius = 45.
      // So visual timer fills the whole circle.
      // The handle should be at r=22.5 to be in the middle of the "pie slice"?
      // Or at r=40 near the edge?
      // User said "lines up with the edge of the blue area".
      // If the blue area ends at r=45 (outer edge), and the handle is at r=45, it matches the outer edge.
      // If the user meant the flat "leading edge" of the time sector...
      // The handle IS at the leading edge.
      // But maybe the handle needs to be slightly inward to look good?
      // Let's try r=35.

      const angle = progress * 2 * Math.PI;
      // Handle Position
      const handleR = 38; // Slightly inside outer edge (45)
      const handleX = 50 + handleR * Math.cos(angle);
      const handleY = 50 + handleR * Math.sin(angle);

      return (
        <div className="flex flex-col items-center justify-between h-full p-2 relative bg-white select-none group">
          <div className="absolute top-2 left-2 z-20 opacity-0 group-hover:opacity-100 transition-opacity">
            <button
              onClick={() => setShowColorMenu(!showColorMenu)}
              className={`w-6 h-6 rounded-full ${COLORS[color].bg} ring-2 ring-white shadow-sm hover:scale-110 transition-transform`}
              title="Change Color"
            />
            {showColorMenu && (
              <div className="absolute top-full left-0 mt-2 bg-white rounded-xl shadow-xl border border-gray-100 p-2 flex flex-col gap-2 z-50 animate-in fade-in slide-in-from-top-2">
                {Object.keys(COLORS).map(c => (
                  <button
                    key={c}
                    onClick={() => { updateData(widget.id, { color: c }); setShowColorMenu(false); }}
                    className={`w-5 h-5 rounded-full ${COLORS[c].bg} ${color === c ? 'ring-2 ring-slate-400' : ''} hover:scale-110 transition-transform`}
                  />
                ))}
              </div>
            )}
          </div>
          <button onClick={() => updateData(widget.id, { mode: mode === 'digital' ? 'visual' : 'digital' })} className="absolute top-2 right-2 p-1.5 text-gray-300 hover:text-blue-600 rounded-full hover:bg-blue-50 opacity-0 group-hover:opacity-100 transition-opacity z-20" title="Switch Mode"><Clock size={16} /></button>

          <div className="flex-1 w-full flex items-center justify-center p-2 min-h-0">
            {mode === 'visual' ? (
              <div className="relative w-full h-full max-h-[90%] aspect-square flex items-center justify-center">
                <svg ref={timerRef} className="transform -rotate-90 w-full h-full overflow-visible" viewBox="0 0 100 100" onMouseDown={handleMouseDown} style={{ cursor: isRunning ? 'default' : 'grab' }}>
                  {/* Ticks */}
                  {/* Ticks */}
                  {Array.from({ length: 60 }).map((_, i) => {
                    const isMajor = i % 5 === 0;
                    const deg = i * 6;
                    const rad = deg * Math.PI / 180;
                    const innerR = isMajor ? 38 : 42;
                    const outerR = 45;
                    const x1 = 50 + innerR * Math.cos(rad);
                    const y1 = 50 + innerR * Math.sin(rad);
                    const x2 = 50 + outerR * Math.cos(rad);
                    const y2 = 50 + outerR * Math.sin(rad);
                    return (
                      <line
                        key={i}
                        x1={x1}
                        y1={y1}
                        x2={x2}
                        y2={y2}
                        stroke={isMajor ? "#cbd5e1" : "#e2e8f0"}
                        strokeWidth={isMajor ? "2" : "1"}
                      />
                    );
                  })}
                  {/* Track */}
                  <circle cx="50" cy="50" r="45" stroke="#f3f4f6" strokeWidth="10" fill="white" />

                  {/* colored slice - r=22.5, width=45 covers 0-45 radius (full pie) */}
                  {timeLeft > 0 && (
                    <circle cx="50" cy="50" r="22.5" stroke={theme.stroke} strokeWidth="45" fill="none"
                      strokeDasharray={`${2 * Math.PI * 22.5} ${2 * Math.PI * 22.5}`}
                      strokeDashoffset={2 * Math.PI * 22.5 * (1 - progress)}
                      className="transition-all duration-75 ease-linear pointer-events-none"
                    />
                  )}

                  {/* Border */}
                  <circle cx="50" cy="50" r="45" stroke="#e5e7eb" strokeWidth="1" fill="none" pointerEvents="none" />

                  {/* Handle */}
                  {!isRunning && (
                    <g transform={`translate(${handleX}, ${handleY})`}>
                      <circle r="5" fill="white" stroke={theme.handle} strokeWidth="2" className="shadow-sm cursor-grab active:cursor-grabbing" />
                    </g>
                  )}
                </svg>
                <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                  <span className="font-bold text-slate-700 bg-white/80 px-2 rounded-lg backdrop-blur-sm shadow-sm" style={{ fontSize: (fontSize * 1.5) + 'px' }}>{formatTime(timeLeft)}</span>
                </div>
              </div>
            ) : (
              <div className="flex flex-col items-center">
                <div className={`font-black text-slate-800 tracking-widest mb-4 font-sans`} style={{ fontSize: (fontSize * 4) + 'px' }}>{formatTime(timeLeft)}</div>
                {!isRunning && (
                  <div className="flex flex-col items-center gap-2">
                    <div className="flex gap-4">
                      {/* Removed -30/+30 buttons */}
                    </div>
                    <div className="flex gap-2 items-center mt-2">
                      <input
                        type="text"
                        placeholder="00:00"
                        className="w-20 text-center border rounded p-1 text-sm font-bold text-gray-600"
                        value={customTime}
                        onChange={(e) => setCustomTime(e.target.value)}
                        onKeyDown={(e) => {
                          if (e.key === 'Enter') {
                            const parts = customTime.split(':').map(Number);
                            let seconds = 0;
                            if (parts.length === 2) seconds = parts[0] * 60 + parts[1];
                            else if (parts.length === 1) seconds = parts[0] * 60; // Assume minutes if just one number? Or seconds? User said "amount of time". Assume minutes for single number is standard teacher timer behavior, or seconds? Let's assume minutes if < 100, else seconds? Let's check logic. Actually, standard is usually minutes. Let's do M:S support.
                            // Improved parsing
                            if (parts.length === 1 && !isNaN(parts[0])) seconds = parts[0] * 60;

                            if (seconds > 0) {
                              updateData(widget.id, { timeLeft: seconds });
                              setCustomTime("");
                            }
                          }
                        }}
                      />
                      <button onClick={() => {
                        const parts = customTime.split(':').map(Number);
                        let seconds = 0;
                        if (parts.length === 2) seconds = parts[0] * 60 + parts[1];
                        else if (parts.length === 1 && !isNaN(parts[0])) seconds = parts[0] * 60;
                        if (seconds > 0) {
                          updateData(widget.id, { timeLeft: seconds });
                          setCustomTime("");
                        }
                      }} className="bg-slate-200 hover:bg-slate-300 text-slate-600 px-2 py-1 rounded text-xs font-bold">Set</button>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>

          <div className="flex gap-4 items-center z-10 py-2">
            <button onClick={() => updateData(widget.id, { isMuted: !isMuted })} className={`p-2 rounded-full transition-colors ${isMuted ? 'text-red-400 bg-red-50' : 'text-slate-400 hover:bg-slate-100 hover:text-slate-600'}`} title={isMuted ? "Unmute" : "Mute"}>
              {isMuted ? <VolumeX size={18} /> : <Volume2 size={18} />}
            </button>
            <button onClick={toggleTimer} className={`p-4 rounded-full text-white shadow-lg transition-transform active:scale-95 flex items-center justify-center ${isRunning ? 'bg-orange-500 hover:bg-orange-600' : 'bg-green-500 hover:bg-green-600'}`}>
              {isRunning ? <Pause size={24} fill="currentColor" /> : <Play size={24} fill="currentColor" className="ml-1" />}
            </button>
            <button onClick={resetTimer} className="p-3 hover:bg-slate-100 rounded-full text-slate-500 transition-colors" title="Reset"><RotateCcw size={20} /></button>
          </div>
        </div>
      );
    };

    const RandomizerWidget = ({ widget, updateData, roster }) => {
      const { currentName, isAnimating, fontSize = 16, pickedStudents = [] } = widget.data;
      const steps = useRef(0);
      const intervalRef = useRef(null);
      const activeStudents = roster.filter(s => s.active);
      const unpickedStudents = activeStudents.filter(s => !pickedStudents.includes(s.name));

      useEffect(() => {
        if (isAnimating) {
          // If no unpicked students, reset the list before picking
          let availableStudents = unpickedStudents.length > 0 ? unpickedStudents : activeStudents;
          if (availableStudents.length === 0) { updateData(widget.id, { isAnimating: false }); return; }

          intervalRef.current = window.setInterval(() => {
            const randomName = availableStudents[Math.floor(Math.random() * availableStudents.length)].name;
            updateData(widget.id, { currentName: randomName });
            steps.current++;
            if (steps.current >= 20) {
              if (intervalRef.current) clearInterval(intervalRef.current);
              // Add the final picked name to the picked list
              const finalName = widget.data.currentName || randomName;
              const newPickedList = unpickedStudents.length > 0
                ? [...pickedStudents, finalName]
                : [finalName]; // Reset list if everyone was picked
              updateData(widget.id, { isAnimating: false, pickedStudents: newPickedList });
              steps.current = 0;
            }
          }, 100);
        }
        return () => { if (intervalRef.current) clearInterval(intervalRef.current); };
      }, [isAnimating, widget.id, activeStudents.length]);

      const resetPicked = () => updateData(widget.id, { pickedStudents: [], currentName: null });
      const scaledFS = (fontSize / 16) * 30;
      const pickedCount = pickedStudents.length;
      const totalCount = activeStudents.length;

      return (
        <div className="flex flex-col items-center justify-center h-full p-4 bg-indigo-50 relative group">
          {/* Reset button */}
          <button onClick={resetPicked} className="absolute top-2 right-2 p-1.5 text-gray-300 hover:text-indigo-600 rounded-full hover:bg-indigo-100 opacity-0 group-hover:opacity-100 transition-opacity z-20" title="Reset picked students">
            <RefreshCw size={16} />
          </button>

          {/* Progress indicator */}
          <div className="absolute top-2 left-2 text-[10px] font-bold text-indigo-400 uppercase tracking-wider opacity-60">
            {pickedCount}/{totalCount} picked
          </div>

          <div className="flex-1 flex items-center justify-center w-full">
            <h2 className="font-bold text-center break-words text-indigo-900 leading-tight" style={{ fontSize: scaledFS + 'px' }}>{currentName || <span className="text-indigo-200">?</span>}</h2>
          </div>
          <button onClick={() => { steps.current = 0; updateData(widget.id, { isAnimating: true }); }} disabled={isAnimating || activeStudents.length === 0} className="bg-indigo-600 text-white px-8 py-3 rounded-full flex gap-2 items-center font-bold shadow-lg transition-all active:scale-95">
            <Shuffle size={18} /> Pick Random
          </button>
          {activeStudents.length === 0 && <div className="absolute bottom-16 text-xs text-red-500 font-bold">No active students in roster!</div>}
          {unpickedStudents.length === 0 && activeStudents.length > 0 && <div className="absolute bottom-16 text-xs text-green-600 font-bold">All picked! Will reset on next pick.</div>}
        </div>
      );
    };

    const GroupMakerWidget = ({ widget, updateData, roster }) => {
      const { groups = [], fontSize = 16, groupCount = 4 } = widget.data;
      const containerRef = useRef(null);
      const [columns, setColumns] = useState(4);

      const activeStudents = roster.filter(s => s.active);
      const count = activeStudents.length;
      const scaledFS = (fontSize / 16) * 14;

      // Responsive column calculation
      useEffect(() => {
        if (!containerRef.current) return;
        const observer = new ResizeObserver((entries) => {
          for (let entry of entries) {
            const width = entry.contentRect.width;
            // Min column width of 140px
            const newCols = Math.max(2, Math.min(8, Math.floor(width / 140)));
            setColumns(newCols);
          }
        });
        observer.observe(containerRef.current);
        return () => observer.disconnect();
      }, []);

      const createGroups = (countNeeded) => {
        const shuffled = [...activeStudents].sort(() => Math.random() - 0.5);
        const newG = Array.from({ length: countNeeded }, () => []);
        shuffled.forEach((s, i) => newG[i % countNeeded].push(s));
        updateData(widget.id, { groups: newG, groupCount: countNeeded });
      };

      // Calculate grid template based on dynamic columns
      const gridStyle = {
        display: 'grid',
        gridTemplateColumns: `repeat(${columns}, minmax(0, 1fr))`,
        gap: '0.5rem'
      };

      return (
        <div className="flex flex-col h-full bg-gray-50 relative p-4">
          <div className="flex flex-col gap-2 flex-1 min-h-0">
            <div className="flex justify-between items-center mb-1 shrink-0">
              <div className="bg-white border border-gray-200 px-2 py-0.5 rounded-md shadow-sm">
                <span className="text-[10px] uppercase font-bold text-gray-400 tracking-wider">Present: </span>
                <span className="text-xs font-bold text-blue-600">{count}</span>
              </div>
            </div>

            <div ref={containerRef} className="overflow-y-auto content-start custom-scrollbar flex-1" style={gridStyle}>
              {groups.length > 0 ? groups.map((g, i) => (
                <div key={i} className="bg-white p-2 rounded-xl shadow-sm border border-gray-100 min-h-[80px] flex flex-col">
                  <div className="font-bold text-[10px] uppercase text-gray-400 mb-1 tracking-wider">Group {i + 1}</div>
                  <div className="flex-1 space-y-0.5">
                    {g.map(s => (
                      <div key={s.id} className="px-1.5 py-0.5 bg-gray-50 rounded flex items-center text-gray-700 font-medium truncate" style={{ fontSize: scaledFS + 'px' }}>{s.name}</div>
                    ))}
                  </div>
                </div>
              )) : <div className="col-span-full flex items-center justify-center text-gray-400 italic">No groups created</div>}
            </div>

            <div className="bg-white p-2 rounded-xl border border-gray-200 shadow-sm mt-auto shrink-0">
              <div className="flex justify-between items-center mb-1">
                <span className="text-xs font-bold text-slate-600">Groups: {groupCount}</span>
                <span className="text-[10px] text-slate-400">~{Math.ceil(count / groupCount)} students/group</span>
              </div>
              <input
                type="range" min="2" max="12" value={groupCount}
                onChange={e => {
                  const c = Number(e.target.value);
                  updateData(widget.id, { groupCount: c });
                  createGroups(c);
                }}
                className="w-full accent-blue-600 h-2 bg-slate-100 rounded-lg appearance-none cursor-pointer mb-2"
              />
              <button onClick={() => createGroups(groupCount)} className="w-full py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold rounded-lg transition-colors">
                Shuffle Groups
              </button>
            </div>
          </div>
        </div>
      );
    };

    const WebcamWidget = ({ widget, updateData }) => {
      const { isMirrored = true, isActive = true } = widget.data;
      const videoRef = useRef(null);
      const streamRef = useRef(null);

      const takePhoto = () => {
        if (videoRef.current) {
          const canvas = document.createElement('canvas');
          canvas.width = videoRef.current.videoWidth;
          canvas.height = videoRef.current.videoHeight;
          const ctx = canvas.getContext('2d');
          if (isMirrored) {
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
          }
          ctx.drawImage(videoRef.current, 0, 0);
          const link = document.createElement('a');
          link.download = `photo-${Date.now()}.png`;
          link.href = canvas.toDataURL('image/png');
          link.click();
        }
      };

      useEffect(() => {
        const startCamera = async () => {
          if (isActive) {
            try {
              const stream = await navigator.mediaDevices.getUserMedia({ video: true });
              streamRef.current = stream;
              if (videoRef.current) {
                videoRef.current.srcObject = stream;
              }
            } catch (e) {
              console.error("Camera Error:", e);
              updateData(widget.id, { isActive: false });
            }
          } else {
            stopCamera();
          }
        };
        startCamera();
        return () => {
          stopCamera();
        };
      }, [isActive]);

      const stopCamera = () => {
        if (streamRef.current) {
          streamRef.current.getTracks().forEach(track => track.stop());
          streamRef.current = null;
        }
        if (videoRef.current) {
          videoRef.current.srcObject = null;
        }
      };

      return (
        <div className="w-full h-full bg-black relative flex flex-col group overflow-hidden">
          <div className="flex-1 relative bg-gray-900 flex items-center justify-center">
            {isActive ? (
              <video ref={videoRef} autoPlay playsInline muted className={`w-full h-full object-cover pointer-events-none ${isMirrored ? 'scale-x-[-1]' : ''}`} />
            ) : (
              <div className="text-white/50 text-center flex flex-col items-center">
                <CameraOff size={48} className="mb-2 opacity-50" />
                <span className="text-sm font-medium">Camera Off</span>
              </div>
            )}
          </div>

          {/* Gradient Overlay */}
          <div className="absolute bottom-0 left-0 right-0 h-32 bg-gradient-to-t from-black/90 via-black/50 to-transparent pointer-events-none" />

          {/* Controls */}
          <div className="absolute bottom-0 left-0 right-0 p-4 text-white z-10">
            <div className="flex justify-center gap-3 opacity-0 group-hover:opacity-100 transition-opacity">
              <button onClick={() => updateData(widget.id, { isActive: !isActive })} className="p-3 bg-white/20 backdrop-blur-md hover:bg-white/30 rounded-full text-white">
                {isActive ? <CameraOff size={20} /> : <Camera size={20} />}
              </button>
              <button onClick={takePhoto} className="p-3 bg-white/20 backdrop-blur-md hover:bg-white/30 rounded-full text-white">
                <Camera size={20} />
              </button>
              {isActive && (
                <button onClick={() => updateData(widget.id, { isMirrored: !isMirrored })} className="p-3 bg-white/20 backdrop-blur-md hover:bg-white/30 rounded-full text-white">
                  {isMirrored ? <FlipHorizontal size={16} /> : <FlipHorizontal size={16} className="text-gray-400" />}
                </button>
              )}
            </div>
          </div>
        </div>
      );
    };




    // Draw tool emojis/stickers
    const DRAW_EMOJIS = ['⭐', '❤️', '✅', '❌', '👍', '👎', '🎯', '🏆', '🔥', '💡', '📌', '🎨', '📝', '🌟', '✨', '🎉', '💯', '👀', '🤔', '💪', '🌈', '⚡', '🎁', '😊', '🙌'];

    const WhiteboardWidget = ({ widget, updateData }) => {
      const { tool = 'pen', color = '#000000', size = 5, lines = [], textItems = [], emojiItems = [], imageItems = [] } = widget.data;
      const canvasRef = useRef(null);
      const isDrawing = useRef(false);
      const [showColorPicker, setShowColorPicker] = useState(false);
      const [showEmojiPicker, setShowEmojiPicker] = useState(false);
      const fileInputRef = useRef(null);
      const [selectedItem, setSelectedItem] = useState(null);

      // History
      const [history, setHistory] = useState([]);
      const [redoStack, setRedoStack] = useState([]);

      const addToHistory = () => {
        setHistory(prev => [...prev, widget.data]);
        setRedoStack([]);
      };

      const handleUndo = () => {
        if (history.length === 0) return;
        const previous = history[history.length - 1];
        setRedoStack(prev => [...prev, widget.data]);
        setHistory(prev => prev.slice(0, -1));
        updateData(widget.id, previous);
        setSelectedItem(null);
      };

      const handleRedo = () => {
        if (redoStack.length === 0) return;
        const next = redoStack[redoStack.length - 1];
        setHistory(prev => [...prev, widget.data]);
        setRedoStack(prev => prev.slice(0, -1));
        updateData(widget.id, next);
        setSelectedItem(null);
      };

      // Drawing Logic

      const lastPointRef = useRef(null);

      const handleCanvasMouseDown = (e) => {
        if (tool !== 'pen' && tool !== 'eraser') return;
        addToHistory();
        const rect = canvasRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        isDrawing.current = true;

        // Reset last point for speed calc
        lastPointRef.current = { x, y, time: Date.now(), w: size };

        // Start a new line path
        updateData(widget.id, { lines: [...lines, { points: [{ x, y, w: size }], color: tool === 'eraser' ? '#ffffff' : color, size, tool }] });
      };

      const moveDrawing = (e) => {
        if (!isDrawing.current) return;
        if (tool !== 'pen' && tool !== 'eraser') return;
        const rect = canvasRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const now = Date.now();

        // Speed Sensitivity Calculation
        let newWidth = size;
        if (tool === 'pen' && lastPointRef.current) {
          const dx = (x - lastPointRef.current.x) * rect.width;
          const dy = (y - lastPointRef.current.y) * rect.height;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const dt = now - lastPointRef.current.time;

          if (dt > 0) {
            const speed = dist / dt; // pixels per ms
            // Dynamic width: Faster = Thinner
            // More dramatic range (0.1x to 3x)
            const targetWidth = Math.max(size * 0.1, Math.min(size * 3.0, size * (1.5 - speed / 3)));
            // Smoothing
            newWidth = lastPointRef.current.w * 0.5 + targetWidth * 0.5;
          }
        }

        lastPointRef.current = { x, y, time: now, w: newWidth };

        // Append point to last line
        const newLines = [...lines];
        if (newLines.length > 0) {
          const lastLine = { ...newLines[newLines.length - 1] };
          lastLine.points = [...lastLine.points, { x, y, w: newWidth }];
          newLines[newLines.length - 1] = lastLine;
          updateData(widget.id, { lines: newLines });
        }
      };

      const stopDrawing = () => {
        isDrawing.current = false;
      };

      // Keep lines in a ref so resize observer can access latest without re-subscribing
      const linesRef = useRef(lines);
      useEffect(() => { linesRef.current = lines; }, [lines]);

      // Simple draw function that reads from linesRef
      const drawCanvas = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas || canvas.width === 0) return;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const dpr = window.devicePixelRatio || 1;
        const currentLines = linesRef.current;
        currentLines.forEach(l => {
          if (l.points && l.points.length > 0) {
            if (!l.points[0].w || l.tool === 'eraser') {
              ctx.beginPath();
              ctx.strokeStyle = l.color;
              ctx.lineWidth = l.size * dpr;
              ctx.moveTo(l.points[0].x * canvas.width, l.points[0].y * canvas.height);
              l.points.forEach(p => ctx.lineTo(p.x * canvas.width, p.y * canvas.height));
              ctx.stroke();
            } else {
              ctx.fillStyle = l.color;
              for (let i = 0; i < l.points.length - 1; i++) {
                const p1 = l.points[i], p2 = l.points[i + 1];
                const x1 = p1.x * canvas.width, y1 = p1.y * canvas.height;
                const x2 = p2.x * canvas.width, y2 = p2.y * canvas.height;
                const dist = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                if (dist < 0.5) continue;
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const sin = Math.sin(angle), cos = Math.cos(angle);
                const dx1 = sin * (p1.w * dpr) * 0.5, dy1 = cos * (p1.w * dpr) * 0.5;
                const dx2 = sin * (p2.w * dpr) * 0.5, dy2 = cos * (p2.w * dpr) * 0.5;
                ctx.beginPath();
                ctx.moveTo(x1 - dx1, y1 + dy1);
                ctx.lineTo(x1 + dx1, y1 - dy1);
                ctx.lineTo(x2 + dx2, y2 - dy2);
                ctx.lineTo(x2 - dx2, y2 + dy2);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x1, y1, (p1.w * dpr) * 0.5, 0, Math.PI * 2);
                ctx.fill();
              }
              if (l.points.length > 0) {
                const last = l.points[l.points.length - 1];
                ctx.beginPath();
                ctx.arc(last.x * canvas.width, last.y * canvas.height, (last.w * dpr) * 0.5, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          }
        });
      }, []);

      // Redraw when lines change
      useEffect(() => { drawCanvas(); }, [lines, drawCanvas]);

      // Resize observer runs once on mount, calls drawCanvas which reads linesRef
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const resizeCanvas = () => {
          const rect = canvas.getBoundingClientRect();
          if (rect.width === 0 || rect.height === 0) return;
          const dpr = window.devicePixelRatio || 1;
          canvas.style.width = `${rect.width}px`;
          canvas.style.height = `${rect.height}px`;
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          drawCanvas();
        };

        const observer = new ResizeObserver(() => requestAnimationFrame(resizeCanvas));
        observer.observe(canvas);
        setTimeout(resizeCanvas, 10); // Small delay for layout

        return () => observer.disconnect();
      }, [drawCanvas]);

      // Item Drag Logic
      const dragItemStart = useRef(null);
      const isDraggingItem = useRef(false);
      const draggingId = useRef(null);
      const dragMode = useRef('move'); // move, rotate, scale

      const handleItemMouseDown = (e, type, id, mode = 'move') => {
        // Fix for Double Event (Drag vs Canvas)
        if (e.defaultPrevented) return;
        e.preventDefault();
        e.stopPropagation();

        addToHistory();
        setSelectedItem({ type, id });
        isDraggingItem.current = true;
        draggingId.current = id;
        dragMode.current = mode;

        let item;
        if (type === 'text') item = textItems.find(i => i.id === id);
        if (type === 'emoji') item = emojiItems.find(i => i.id === id);
        if (type === 'image') item = imageItems.find(i => i.id === id);

        const rect = canvasRef.current.getBoundingClientRect();
        dragItemStart.current = {
          startX: item ? item.x : 0.5,
          startY: item ? item.y : 0.5,
          initialMx: e.clientX,
          initialMy: e.clientY,
          startScale: item ? (item.scale || 1) : 1,
          startRotation: item ? (item.rotation || 0) : 0,
          rect: rect
        };
      };

      useEffect(() => {
        const handleWindowMove = (e) => {
          if (isDraggingItem.current && selectedItem) {
            e.preventDefault();
            const { type, id } = selectedItem;
            const startData = dragItemStart.current;
            const rect = startData.rect;

            const updateList = (list, key) => {
              var newList = [];
              for (var i = 0; i < list.length; i++) {
                if (list[i].id === id) {
                  var item = list[i];
                  var updates = {};
                  if (dragMode.current === 'move') {
                    const dx = (e.clientX - startData.initialMx) / rect.width;
                    const dy = (e.clientY - startData.initialMy) / rect.height;
                    updates = { x: startData.startX + dx, y: startData.startY + dy };
                  } else if (dragMode.current === 'rotate') {
                    const cx = startData.startX * rect.width + rect.left;
                    const cy = startData.startY * rect.height + rect.top;
                    const angle = Math.atan2(e.clientY - cy, e.clientX - cx) * (180 / Math.PI);
                    updates = { rotation: angle + 90 };
                  } else if (dragMode.current === 'scale') {
                    const cx = startData.startX * rect.width + rect.left;
                    const cy = startData.startY * rect.height + rect.top;
                    const dist = Math.sqrt(Math.pow(e.clientX - cx, 2) + Math.pow(e.clientY - cy, 2));
                    const startDist = Math.sqrt(Math.pow(startData.initialMx - cx, 2) + Math.pow(startData.initialMy - cy, 2));
                    const scaleFactor = dist / (startDist || 1);
                    updates = { scale: Math.max(0.2, startData.startScale * scaleFactor) };
                  }
                  newList.push({ ...item, ...updates });
                } else {
                  newList.push(list[i]);
                }
              }
              var updateObj = {}; updateObj[key] = newList;
              updateData(widget.id, updateObj);
            };

            if (type === 'text') updateList(textItems, 'textItems');
            if (type === 'emoji') updateList(emojiItems, 'emojiItems');
            if (type === 'image') updateList(imageItems, 'imageItems');
          }
        };

        const handleWindowUp = () => {
          isDraggingItem.current = false;
          draggingId.current = null;
        };

        window.addEventListener('mousemove', handleWindowMove);
        window.addEventListener('mouseup', handleWindowUp);
        return () => {
          window.removeEventListener('mousemove', handleWindowMove);
          window.removeEventListener('mouseup', handleWindowUp);
        };
      }, [selectedItem, textItems, emojiItems, imageItems, widget.id]);

      const updateTextContent = (id, text) => {
        addToHistory();
        updateData(widget.id, { textItems: textItems.map(t => t.id === id ? { ...t, text } : t) });
      };

      const addEmoji = (emoji, e) => {
        if (e) { e.preventDefault(); e.stopPropagation(); }
        addToHistory();
        const newItem = { id: Date.now().toString(), x: 0.5, y: 0.5, emoji, scale: 1 };
        updateData(widget.id, { emojiItems: [...emojiItems, newItem] });
        setShowEmojiPicker(false);
      };

      const handleImageUpload = (e) => {
        const file = e.target.files[0];
        if (file) {
          addToHistory();
          const reader = new FileReader();
          reader.onload = (ev) => {
            const img = new Image(); img.src = ev.target.result;
            img.onload = () => {
              const aspect = img.width / img.height;
              const newItem = { id: Date.now().toString(), x: 0.5, y: 0.5, src: ev.target.result, scale: 1, width: 200, height: 200 / aspect };
              updateData(widget.id, { imageItems: [...imageItems, newItem] });
            };
          };
          reader.readAsDataURL(file);
        }
      };

      const savePNG = () => { var link = document.createElement('a'); link.download = 'whiteboard.png'; link.href = canvasRef.current.toDataURL(); link.click(); };
      const clearAll = () => { addToHistory(); updateData(widget.id, { lines: [], textItems: [], emojiItems: [], imageItems: [] }); };
      const deleteSelectedItem = () => {
        if (!selectedItem) return;
        addToHistory();
        const { type, id } = selectedItem;
        if (type === 'text') updateData(widget.id, { textItems: textItems.filter(i => i.id !== id) });
        if (type === 'emoji') updateData(widget.id, { emojiItems: emojiItems.filter(i => i.id !== id) });
        if (type === 'image') updateData(widget.id, { imageItems: imageItems.filter(i => i.id !== id) });
        setSelectedItem(null);
      };

      return (
        <div className="h-full bg-white flex flex-col relative group">
          <div className="bg-gray-50 p-2 border-b flex items-center justify-between shrink-0 gap-3">
            <div className="flex gap-2 items-center shrink-0">
              <div className="relative">
                <button onClick={() => setShowColorPicker(!showColorPicker)} className={`w-8 h-8 rounded-full border-2 border-white shadow-sm flex items-center justify-center`} style={{ backgroundColor: color }} />
                {showColorPicker && (
                  <div className="absolute top-full left-0 mt-2 bg-white p-2 rounded-xl shadow-xl flex gap-1 z-50 border border-gray-100">
                    {['#000000', '#ef4444', '#f59e0b', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899', '#9ca3af'].map(c => (
                      <button key={c} onClick={() => { updateData(widget.id, { color: c }); setShowColorPicker(false); }} className="w-6 h-6 rounded-full border hover:scale-110 transition-transform" style={{ backgroundColor: c }} />
                    ))}
                  </div>
                )}
              </div>
              <div className="w-px h-6 bg-gray-200 mx-1" />
              <button onClick={() => updateData(widget.id, { tool: 'move' })} className={`p-2 rounded-xl transition-all ${tool === 'move' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-400'}`} title="Select/Move"><MousePointer2 size={18} /></button>
              <button onClick={() => updateData(widget.id, { tool: 'pen' })} className={`p-2 rounded-xl transition-all ${tool === 'pen' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-400'}`} title="Pen"><Edit3 size={18} /></button>
              <button onClick={() => updateData(widget.id, { tool: 'eraser' })} className={`p-2 rounded-xl transition-all ${tool === 'eraser' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-400'}`} title="Eraser"><Eraser size={18} /></button>
              <div className="w-px h-6 bg-gray-200 mx-1" />
              <button onClick={handleUndo} className="p-2 rounded-xl hover:bg-gray-100 text-gray-400 disabled:opacity-30" disabled={history.length === 0} title="Undo"><Undo2 size={18} /></button>
              <button onClick={handleRedo} className="p-2 rounded-xl hover:bg-gray-100 text-gray-400 disabled:opacity-30" disabled={redoStack.length === 0} title="Redo"><Redo2 size={18} /></button>

              <div className="flex flex-col justify-center px-1">
                <input type="range" min="1" max="50" value={size} onChange={(e) => updateData(widget.id, { size: Number(e.target.value) })} className="w-20 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-slate-600" title={`Size: ${size}`} />
              </div>
              <div className="w-px h-6 bg-gray-200 mx-1" />
              <button onClick={() => updateData(widget.id, { tool: 'text' })} className={`p-2 rounded-xl transition-all ${tool === 'text' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-400'}`} title="Text"><Type size={18} /></button>
              <button onClick={(e) => { e.stopPropagation(); setShowEmojiPicker(!showEmojiPicker); }} className={`p-2 rounded-xl transition-all ${showEmojiPicker ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-400'}`} title="Sticker"><Smile size={18} /></button>
              <button onClick={() => fileInputRef.current.click()} className="p-2 rounded-xl transition-all hover:bg-gray-100 text-gray-400" title="Image"><ImageIcon size={18} /></button>
              <input ref={fileInputRef} type="file" accept="image/*" className="hidden" onChange={handleImageUpload} />
            </div>
            {selectedItem && (
              <div className="flex items-center gap-2 bg-white border border-gray-200 rounded-xl px-3 py-1 shadow-sm animate-in fade-in zoom-in-95">
                <span className="text-[10px] uppercase font-bold text-gray-400">Selected</span>
                <div className="w-px h-4 bg-gray-200" />
                <button onClick={deleteSelectedItem} className="p-1 hover:bg-red-50 text-red-500 rounded" title="Delete"><Trash2 size={16} /></button>
              </div>
            )}
            <div className="flex gap-1 ml-auto">
              <button onClick={savePNG} className="text-gray-400 hover:text-green-600 p-2" title="Download"><Download size={18} /></button>
              <button onClick={clearAll} className="text-gray-400 hover:text-red-500 p-2" title="Clear All"><RotateCcw size={18} /></button>
            </div>
          </div>
          <div className="flex-1 relative overflow-hidden bg-white cursor-crosshair" onClick={(e) => { if (e.target === e.currentTarget && tool === 'move') setSelectedItem(null); }}>
            {/* Layers: Items Bottom, Canvas Top */}
            <div className="absolute inset-0 z-0">
              {imageItems.map(img => (
                <div key={img.id} onMouseDown={(e) => handleItemMouseDown(e, 'image', img.id)} className={`absolute cursor-move group ${selectedItem?.id === img.id ? 'ring-2 ring-blue-500 ring-offset-2' : ''}`} style={{ left: `${img.x * 100}%`, top: `${img.y * 100}%`, transform: 'translate(-50%, -50%) rotate(' + (img.rotation || 0) + 'deg)', width: (img.width || 100) * (img.scale || 1), height: (img.height || 100) * (img.scale || 1) }}>
                  <img src={img.src} draggable={false} className="w-full h-full object-contain pointer-events-none" />
                  {selectedItem?.id === img.id && (
                    <>
                      <div className="absolute -top-6 left-1/2 -translate-x-1/2 w-6 h-6 bg-white border border-blue-500 rounded-full shadow cursor-grab flex items-center justify-center p-1 z-50" onMouseDown={(e) => handleItemMouseDown(e, 'image', img.id, 'rotate')}><RotateCw size={12} className="text-blue-600" /></div>
                      <div className="absolute -bottom-3 -right-3 w-5 h-5 bg-white border-2 border-blue-500 rounded-full shadow cursor-nwse-resize z-50" onMouseDown={(e) => handleItemMouseDown(e, 'image', img.id, 'scale')} />
                    </>
                  )}
                </div>
              ))}

              {textItems.map(t => (
                <div key={t.id} onMouseDown={(e) => handleItemMouseDown(e, 'text', t.id)} onClick={(e) => { e.stopPropagation(); setSelectedItem({ type: 'text', id: t.id }); }} className={`absolute cursor-move ${selectedItem?.id === t.id ? 'ring-2 ring-blue-500 ring-offset-4 rounded' : ''}`} style={{ left: `${t.x * 100}%`, top: `${t.y * 100}%`, transform: `translate(-50%, -50%) rotate(${t.rotation || 0}deg)` }}>
                  {selectedItem?.id === t.id ? (
                    <>
                      <div className="relative">
                        <input value={t.text} onMouseDown={(e) => { e.stopPropagation(); }} onChange={e => updateTextContent(t.id, e.target.value)} className="bg-transparent border-none outline-none font-bold text-center min-w-[50px]" style={{ color: t.color, fontSize: `${16 * (t.scale || 1)}px` }} autoFocus />
                      </div>
                      <div className="absolute -top-10 left-1/2 -translate-x-1/2 w-6 h-6 bg-white border border-blue-500 rounded-full shadow cursor-grab flex items-center justify-center p-1 z-50" onMouseDown={(e) => handleItemMouseDown(e, 'text', t.id, 'rotate')}><RotateCw size={12} className="text-blue-600" /></div>
                      <div className="absolute -bottom-3 -right-6 w-5 h-5 bg-white border-2 border-blue-500 rounded-full shadow cursor-nwse-resize z-50" onMouseDown={(e) => handleItemMouseDown(e, 'text', t.id, 'scale')} />
                    </>
                  ) : (
                    <div className="font-bold whitespace-nowrap select-none" style={{ color: t.color, fontSize: `${16 * (t.scale || 1)}px` }}>{t.text}</div>
                  )}
                </div>
              ))}

              {emojiItems.map(emoji => (
                <div key={emoji.id} onMouseDown={(ev) => handleItemMouseDown(ev, 'emoji', emoji.id)} onClick={(e) => { e.stopPropagation(); setSelectedItem({ type: 'emoji', id: emoji.id }); }} className={`absolute cursor-move select-none ${selectedItem?.id === emoji.id ? 'ring-2 ring-blue-500 ring-offset-2 rounded-lg' : ''}`} style={{ left: `${emoji.x * 100}%`, top: `${emoji.y * 100}%`, transform: `translate(-50%, -50%) rotate(${emoji.rotation || 0}deg)`, fontSize: `${32 * (emoji.scale || 1)}px` }}>
                  <span className="emoji relative inline-block"> {emoji.emoji} </span>
                  {selectedItem?.id === emoji.id && (
                    <>
                      <div className="absolute -top-8 left-1/2 -translate-x-1/2 w-6 h-6 bg-white border border-blue-500 rounded-full shadow cursor-grab flex items-center justify-center p-1 z-50" onMouseDown={(e) => handleItemMouseDown(e, 'emoji', emoji.id, 'rotate')}><RotateCw size={12} className="text-blue-600" /></div>
                      <div className="absolute -bottom-3 -right-3 w-5 h-5 bg-white border-2 border-blue-500 rounded-full shadow cursor-nwse-resize z-50" onMouseDown={(e) => handleItemMouseDown(e, 'emoji', emoji.id, 'scale')} />
                    </>
                  )}
                </div>
              ))}
            </div>

            <canvas ref={canvasRef} className={`absolute inset-0 w-full h-full touch-none z-10 ${tool === 'move' ? 'pointer-events-none' : 'pointer-events-auto cursor-crosshair'}`} onMouseDown={handleCanvasMouseDown} onMouseMove={moveDrawing} onMouseUp={stopDrawing} onMouseLeave={stopDrawing} />

            {showEmojiPicker && (
              <div className="absolute top-16 left-4 z-[100] bg-white rounded-xl shadow-2xl border border-gray-200 p-3 w-72 max-h-56 overflow-y-auto custom-scrollbar" onClick={e => e.stopPropagation()}>
                <div className="grid grid-cols-6 gap-2"> {DRAW_EMOJIS.map((em, i) => <button key={i} onClick={(e) => addEmoji(em, e)} className="text-2xl p-2 rounded-lg hover:bg-blue-50 transition-colors flex items-center justify-center">{em}</button>)} </div>
              </div>
            )}
          </div>
        </div>
      );
    };


    const SCHEDULE_EMOJIS = ['📚', '🎨', '🏃', '🎵', '💻', '🥪', '📝', '🔬', '🗣️', '🛑', '🚌', '🏠', '📅', '⭐', '🔔'];

    const ScheduleWidget = ({ widget, updateData, onOpenSettings }) => {
      const { fontSize = 14 } = widget.data;
      const [dragIndex, setDragIndex] = useState(null);
      const [emojiPickerIndex, setEmojiPickerIndex] = useState(null);
      const [timePickerIndex, setTimePickerIndex] = useState(null);
      const today = DAYS_OF_WEEK[new Date().getDay()];
      const [scheduleData, setScheduleData] = useState(() => { const template = getScheduleTemplate(); return template[today] || []; });

      useEffect(() => {
        const refreshFromStorage = () => { const template = getScheduleTemplate(); setScheduleData(template[today] || []); };
        const interval = setInterval(refreshFromStorage, 1000);
        return () => clearInterval(interval);
      }, [today]);

      useEffect(() => {
        const handleClickOutside = () => { setEmojiPickerIndex(null); setTimePickerIndex(null); };
        if (emojiPickerIndex !== null || timePickerIndex !== null) { document.addEventListener('click', handleClickOutside); return () => document.removeEventListener('click', handleClickOutside); }
      }, [emojiPickerIndex, timePickerIndex]);

      const now = new Date();
      const currentMinutes = now.getHours() * 60 + now.getMinutes();
      const parseTimeToMinutes = (time) => { if (!time) return 0; const [h, m] = time.split(':').map(Number); return h * 60 + m; };

      const isCurrentItem = (item, index) => {
        const itemMinutes = parseTimeToMinutes(item.time);
        const nextItem = scheduleData[index + 1];
        const nextMinutes = nextItem ? parseTimeToMinutes(nextItem.time) : 24 * 60;
        return currentMinutes >= itemMinutes && currentMinutes < nextMinutes;
      };

      const saveScheduleData = (newItems) => { const template = getScheduleTemplate(); template[today] = newItems; saveScheduleTemplate(template); setScheduleData(newItems); };
      const updateItem = (index, field, value) => { const newItems = [...scheduleData]; newItems[index] = { ...newItems[index], [field]: value }; saveScheduleData(newItems); };
      const addItem = () => { const newItem = { id: Date.now().toString(), time: '09:00', emoji: '📚', title: 'New Activity', description: '' }; const newItems = [...scheduleData, newItem].sort((a, b) => parseTimeToMinutes(a.time) - parseTimeToMinutes(b.time)); saveScheduleData(newItems); };
      const removeItem = (index) => { const newItems = scheduleData.filter((_, i) => i !== index); saveScheduleData(newItems); };

      const handleDragStart = (index) => { setDragIndex(index); };
      const handleDragOver = (e) => { e.preventDefault(); };
      const handleDrop = (targetIndex) => { if (dragIndex === null || dragIndex === targetIndex) return; const newItems = [...scheduleData]; const [moved] = newItems.splice(dragIndex, 1); newItems.splice(targetIndex, 0, moved); saveScheduleData(newItems); setDragIndex(null); };
      const selectEmoji = (index, emoji) => { updateItem(index, 'emoji', emoji); setEmojiPickerIndex(null); };

      return (
        <div className="flex flex-col h-full bg-gradient-to-br from-indigo-50 to-purple-50">
          <div className="h-10 bg-white/80 backdrop-blur border-b flex items-center justify-between px-3 shrink-0">
            <h3 className="font-bold text-indigo-800 text-sm flex items-center gap-2"><Calendar size={16} /> {today}'s Schedule</h3>
            <div className="flex gap-1">
              <button onClick={addItem} className="p-1.5 text-indigo-600 hover:bg-indigo-100 rounded-lg transition-colors" title="Add activity"><Plus size={16} /></button>
              <button onClick={onOpenSettings} className="p-1.5 text-gray-400 hover:bg-gray-100 rounded-lg transition-colors" title="Schedule settings"><Settings size={16} /></button>
            </div>
          </div>
          <div className="flex-1 overflow-y-auto p-2 flex flex-col gap-1 custom-scrollbar">
            {scheduleData.length === 0 ? (
              <div className="flex flex-col items-center justify-center h-full text-center p-4">
                <Calendar size={40} className="text-indigo-200 mb-3" />
                <p className="text-indigo-400 text-sm font-medium mb-2">No schedule items yet</p>
                <button onClick={addItem} className="px-3 py-1.5 bg-indigo-600 text-white text-xs font-bold rounded-lg hover:bg-indigo-700 flex items-center gap-1"><Plus size={14} /> Add Activity</button>
              </div>
            ) : (
              scheduleData.map((item, index) => {
                const isCurrent = isCurrentItem(item, index);
                return (
                  <div key={item.id} draggable onDragStart={() => handleDragStart(index)} onDragOver={handleDragOver} onDrop={() => handleDrop(index)} className={`relative group flex gap-2 p-2 rounded-lg border transition-all cursor-move w-full min-h-[4rem] ${isCurrent ? 'bg-indigo-100 border-indigo-400 ring-2 ring-indigo-300' : 'bg-white border-gray-200 hover:border-indigo-200'}`} style={{ zIndex: emojiPickerIndex === index ? 50 : 0 }}>
                    {isCurrent && <div className="absolute -left-1 top-1/2 -translate-y-1/2 w-2 h-2 bg-indigo-500 rounded-full animate-pulse" />}

                    <div className="flex flex-col items-center shrink-0 w-20 relative">
                      <button onClick={(e) => { e.stopPropagation(); setTimePickerIndex(timePickerIndex === index ? null : index); }} className="w-full text-sm font-bold text-indigo-600 bg-white/50 border border-indigo-100 px-2 py-1 rounded hover:bg-indigo-50">
                        {(() => {
                          const [h, m] = (item.time || '09:00').split(':');
                          const hours = parseInt(h);
                          const ampm = hours >= 12 ? 'PM' : 'AM';
                          const displayH = hours % 12 || 12;
                          return `${displayH}:${m} ${ampm}`;
                        })()}
                      </button>
                      {timePickerIndex === index && (
                        <TimePicker time={item.time || '09:00'} onChange={(t) => updateItem(index, 'time', t)} onClose={() => setTimePickerIndex(null)} />
                      )}
                    </div>

                    <div className="relative flex items-center text-xl shrink-0">
                      <div className="cursor-pointer hover:scale-110 transition-transform p-1 rounded hover:bg-indigo-100" onClick={(e) => { e.stopPropagation(); setEmojiPickerIndex(emojiPickerIndex === index ? null : index); }}>
                        {item.emoji || '📚'}
                      </div>
                      {emojiPickerIndex === index && (
                        <div className="absolute left-0 top-full mt-1 z-50 bg-white rounded-xl shadow-xl border border-gray-200 p-2 w-48 max-h-40 overflow-y-auto custom-scrollbar" onClick={(e) => e.stopPropagation()}>
                          <div className="grid grid-cols-5 gap-1"> {SCHEDULE_EMOJIS.map((emoji, i) => (<button key={i} onClick={() => selectEmoji(index, emoji)} className={`text-xl p-1.5 rounded-lg hover:bg-indigo-100 transition-colors ${item.emoji === emoji ? 'bg-indigo-200 ring-2 ring-indigo-400' : ''}`}>{emoji}</button>))} </div>
                        </div>
                      )}
                    </div>
                    <div className="flex-1 min-w-0">
                      <input type="text" value={item.title || ''} onChange={(e) => updateItem(index, 'title', e.target.value)} className="w-full font-bold text-gray-800 bg-transparent border-none outline-none truncate" style={{ fontSize: fontSize + 'px' }} placeholder="Activity name" />
                      <input type="text" value={item.description || ''} onChange={(e) => updateItem(index, 'description', e.target.value)} className="w-full text-xs text-gray-500 bg-transparent border-none outline-none truncate" placeholder="Description (optional)" />
                    </div>
                    <button onClick={() => removeItem(index)} className="p-1 text-red-400 hover:text-red-600 opacity-0 group-hover:opacity-100 transition-opacity self-center"><X size={14} /></button>
                  </div>
                );
              })
            )}
          </div>
        </div>
      );
    };

    const EmbedWidget = ({ widget, updateData }) => {
      const { url = "", youtubeUrl = "" } = widget.data;
      const currentUrl = url || youtubeUrl;
      const [input, setInput] = useState(currentUrl);

      const getEmbedSrc = (link) => {
        if (!link) return null;
        let processedLink = link.trim();
        // Auto-add protocol if missing (and not an iframe tag)
        if (!processedLink.startsWith('http://') && !processedLink.startsWith('https://') && !processedLink.startsWith('<iframe')) {
          processedLink = 'https://' + processedLink;
        }

        if (processedLink.includes("youtube.com") || processedLink.includes("youtu.be")) {
          const id = processedLink.match(/(?:youtu\.be\/|youtube\.com\/watch\?v=|youtube\.com\/embed\/)([\w-]{11})/)?.[1];
          // User requested yout-ube.com for ad-free experience
          return id ? `https://www.yout-ube.com/watch?v=${id}` : null;
        }
        if (processedLink.includes("vimeo.com")) {
          const id = processedLink.match(/vimeo\.com\/(\d+)/)?.[1];
          return id ? `https://player.vimeo.com/video/${id}` : null;
        }
        if (processedLink.includes("<iframe")) {
          const src = processedLink.match(/src="([^"]+)"/)?.[1];
          return src || null;
        }
        return processedLink;
      };

      const embedSrc = getEmbedSrc(currentUrl);

      return (
        <div className="h-full flex flex-col bg-white border border-slate-200 shadow-xl rounded-2xl relative group overflow-hidden">
          {!embedSrc ? (
            <div className="flex-1 flex flex-col items-center justify-center p-6 text-slate-600 gap-4">
              <div className="p-4 bg-red-50 rounded-full text-red-500"><Youtube size={32} /></div>
              <div className="text-center space-y-3 w-full">
                <div className="font-bold text-lg text-slate-800">Embed Content</div>
                <p className="text-slate-400 text-xs text-center max-w-[200px] mx-auto">Paste a link (YouTube, Google Slides, website) or embed code.</p>
                <div className="flex gap-2">
                  <input
                    className="flex-1 bg-slate-50 border border-slate-200 rounded-lg p-2 text-sm text-slate-800 placeholder-slate-400 focus:border-blue-500 outline-none transition-all"
                    placeholder="Paste link here..."
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={(e) => e.key === 'Enter' && updateData(widget.id, { url: input })}
                  />
                  <button onClick={() => updateData(widget.id, { url: input })} className="bg-blue-600 text-white px-3 py-2 rounded-lg font-bold hover:bg-blue-700 transition-colors shadow-sm"><Check size={18} /></button>
                </div>
              </div>
            </div>
          ) : (
            <>
              <iframe src={embedSrc} className="w-full h-full bg-white" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />
              <button
                onClick={() => updateData(widget.id, { url: "", youtubeUrl: "" })}
                className="absolute top-2 right-2 bg-white/90 hover:bg-red-50 text-slate-400 hover:text-red-500 p-2 rounded-full opacity-0 group-hover:opacity-100 transition-all z-10 shadow-sm border border-slate-100"
                title="Remove Embed"
              >
                <X size={16} />
              </button>
            </>
          )}
        </div>
      );
    };
    const YouTubeWidget = EmbedWidget;

    // --- MISSING COMPONENTS (Restored) ---
    // (Onboarding now works with object roster)
    const OnboardingModal = ({ onComplete, onSaveRoster }) => {
      const [text, setText] = useState(DEFAULT_NAMES.join('\n'));
      const handleSave = () => {
        const names = text.split('\n').map(n => n.trim()).filter(n => n);
        if (names.length > 0) {
          const roster = names.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true }));
          saveRoster(roster);
          if (onSaveRoster) onSaveRoster(roster);
        }
        onComplete();
      };
      return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-in fade-in duration-300">
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg flex flex-col overflow-hidden">
            <div className="p-6 bg-gradient-to-r from-blue-600 to-indigo-600 text-white">
              <h2 className="text-2xl font-bold mb-2">Welcome to HomeRoom! 🍎</h2>
              <p className="opacity-90 text-sm">Let's set up your class roster. You can change this anytime.</p>
            </div>
            <div className="p-6">
              <label className="block text-sm font-bold text-gray-700 mb-2">Student Names (one per line)</label>
              <textarea
                value={text}
                onChange={e => setText(e.target.value)}
                className="w-full h-48 border-2 border-gray-200 rounded-xl p-4 text-sm focus:border-blue-500 focus:ring-4 focus:ring-blue-50 outline-none transition-all custom-scrollbar resize-none font-sans"
                style={{ fontFamily: '"Segoe UI Emoji", "Apple Color Emoji", sans-serif' }}
                placeholder="Paste names here..."
              />
            </div>
            <div className="p-4 border-t bg-gray-50 flex justify-end">
              <button
                onClick={handleSave}
                className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl shadow-lg shadow-blue-200 transition-all active:scale-95 flex items-center gap-2"
              >
                <Save size={18} /> Save & Get Started
              </button>
            </div>
          </div>
        </div>
      );
    };

    const AppearanceSettings = ({ currentBg, onSelect, isGridEnabled, onToggleGrid, myBackgrounds, onAddCustom, onDeleteCustom }) => {
      const [customUrl, setCustomUrl] = useState('');
      const [dragActive, setDragActive] = useState(false);
      const [applyToAll, setApplyToAll] = useState(true);
      const fileInputRef = useRef(null);

      const handleDrag = (e) => {
        e.preventDefault(); e.stopPropagation();
        if (e.type === "dragenter" || e.type === "dragover") setDragActive(true);
        else if (e.type === "dragleave") setDragActive(false);
      };

      const handleDrop = (e) => {
        e.preventDefault(); e.stopPropagation();
        setDragActive(false);
        if (e.dataTransfer.files && e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
      };

      const resizeImage = (file, callback) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const MAX_WIDTH = 1024; // Apps optimized
            const MAX_HEIGHT = 1024;
            let width = img.width;
            let height = img.height;
            if (width > height) { if (width > MAX_WIDTH) { height *= MAX_WIDTH / width; width = MAX_WIDTH; } }
            else { if (height > MAX_HEIGHT) { width *= MAX_HEIGHT / height; height = MAX_HEIGHT; } }
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
            callback(canvas.toDataURL('image/jpeg', 0.7)); // Optimized quality
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      };

      const handleFile = useCallback((file) => {
        if (!file.type.startsWith('image/')) return;
        resizeImage(file, (dataUrl) => {
          const newBg = { id: 'custom-' + Date.now(), name: file.name, type: 'image', src: dataUrl, textColor: 'text-white' };
          onAddCustom(newBg);
          onSelect(newBg, applyToAll ? 'all' : 'single');
        });
      }, [applyToAll, onSelect, onAddCustom]);

      useEffect(() => {
        const handleWindowPaste = (e) => {
          const items = e.clipboardData?.items;
          if (items) {
            for (let i = 0; i < items.length; i++) {
              if (items[i].type.indexOf('image') !== -1) {
                e.preventDefault();
                e.stopImmediatePropagation(); // Prevent App from handling it
                handleFile(items[i].getAsFile());
                break;
              }
            }
          }
        };
        window.addEventListener('paste', handleWindowPaste, true); // Capture phase
        return () => window.removeEventListener('paste', handleWindowPaste, true);
      }, [handleFile]);

      const onDeleteCustomClick = (e, id) => {
        e.stopPropagation();
        if (confirm('Delete this background?')) {
          onDeleteCustom(id);
          // Ensure it's deselected if current
          if (currentBg && currentBg.id === id) {
            onSelect(BACKGROUNDS[0], 'all');
          }
        }
      };

      return (
        <div className="flex flex-col h-full overflow-hidden">
          <div className="mb-4 grid grid-cols-2 gap-3">
            <div className="p-3 bg-gray-50 rounded-xl flex items-center justify-between">
              <div className="flex items-center gap-2">
                <div className="p-2 bg-blue-100 text-blue-600 rounded-lg"><Grip size={18} /></div>
                <div className="font-bold text-xs text-gray-800">Snap to Grid</div>
              </div>
              <button
                onClick={() => onToggleGrid?.(!isGridEnabled)}
                className={`relative w-10 h-6 rounded-full transition-colors ${isGridEnabled ? 'bg-blue-500' : 'bg-gray-300'}`}
              >
                <div className={`absolute top-1 w-4 h-4 rounded-full bg-white shadow-sm transition-transform ${isGridEnabled ? 'translate-x-5' : 'translate-x-1'}`} />
              </button>
            </div>

            <div className="p-3 bg-gray-50 rounded-xl flex items-center justify-between">
              <div className="flex items-center gap-2">
                <div className="p-2 bg-indigo-100 text-indigo-600 rounded-lg"><Type size={18} /></div>
                <div className="font-bold text-xs text-gray-800">Clock & Date</div>
              </div>
              <div className="flex bg-gray-200 rounded-lg p-1">
                <button
                  onClick={() => onSelect({ ...currentBg, textColor: 'text-slate-800' }, applyToAll ? 'all' : 'single')}
                  className={`p-1 rounded-md transition-all ${(!currentBg?.textColor || currentBg?.textColor === 'text-slate-800') ? 'bg-white shadow text-orange-500' : 'text-gray-400 hover:text-gray-600'}`}
                  title="Dark Text"
                >
                  <Moon size={14} />
                </button>
                <button
                  onClick={() => onSelect({ ...currentBg, textColor: 'text-white' }, applyToAll ? 'all' : 'single')}
                  className={`p-1 rounded-md transition-all ${currentBg?.textColor === 'text-white' ? 'bg-slate-700 shadow text-yellow-300' : 'text-gray-400 hover:text-gray-600'}`}
                  title="Light Text"
                >
                  <Sun size={14} />
                </button>
              </div>
            </div>
          </div>

          <div className="flex-1 overflow-y-auto custom-scrollbar p-1">
            {/* Custom / My Backgrounds */}
            {myBackgrounds.length > 0 && (
              <>
                <div className="text-xs font-bold text-gray-500 uppercase mb-2">My Backgrounds</div>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                  {myBackgrounds.map(bg => (
                    <button key={bg.id} onClick={() => { onSelect(bg, applyToAll ? 'all' : 'single'); }} className={`relative group rounded-xl overflow-hidden aspect-video border-2 transition-all active:scale-95 shadow-sm hover:shadow-md ${currentBg?.id === bg.id ? 'border-purple-600 ring-2 ring-purple-100' : 'border-transparent hover:border-gray-200'}`}>
                      <img src={bg.src} alt={bg.name} className="w-full h-full object-cover" />
                      <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                        <span className="text-white font-bold tracking-wide shadow-sm truncate px-2">{bg.name}</span>
                      </div>
                      {currentBg?.id === bg.id && <div className="absolute top-2 left-2 bg-purple-600 text-white p-1 rounded-full shadow-lg"><Check size={12} /></div>}
                      <div onClick={(e) => onDeleteCustomClick(e, bg.id)} className="absolute top-1 right-1 bg-white/90 text-red-500 p-1.5 rounded-full opacity-0 group-hover:opacity-100 hover:bg-red-50 transition-all shadow-md border border-red-100 z-20" title="Delete"><Trash2 size={14} /></div>
                    </button>
                  ))}
                </div>
              </>
            )}

            <div className="text-xs font-bold text-gray-500 uppercase mb-2">Background Presets</div>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
              {BACKGROUNDS.map(bg => (
                <button key={bg.id} onClick={() => { onSelect(bg, applyToAll ? 'all' : 'single'); }} className={`relative group rounded-xl overflow-hidden aspect-video border-2 transition-all active:scale-95 shadow-sm hover:shadow-md ${currentBg?.id === bg.id ? 'border-purple-600 ring-2 ring-purple-100' : 'border-transparent hover:border-gray-200'}`}>
                  {bg.id === 'default' ? (
                    <div className="w-full h-full">
                      <svg className="w-full h-full" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                          <linearGradient id="thumbGradOrange" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style={{ stopColor: "#fb923c", stopOpacity: 1 }} /><stop offset="100%" style={{ stopColor: "#ea580c", stopOpacity: 1 }} /></linearGradient>
                          <linearGradient id="thumbGradBlue" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style={{ stopColor: "#3b82f6", stopOpacity: 1 }} /><stop offset="100%" style={{ stopColor: "#60a5fa", stopOpacity: 1 }} /></linearGradient>
                        </defs>
                        <rect width="100%" height="100%" fill="#dbeafe" />
                        <path d="M1920 0V900C1400 900 1000 400 500 0H1920Z" fill="url(#thumbGradOrange)" />
                        <path d="M1920 0V700C1600 700 1300 300 900 0H1920Z" fill="#fed7aa" />
                        <path d="M0 1080V300C500 300 900 800 1600 1080H0Z" fill="url(#thumbGradBlue)" />
                        <path d="M0 1080V500C300 500 700 900 1200 1080H0Z" fill="#93c5fd" />
                      </svg>
                    </div>
                  ) : bg.type === 'preset' ? (
                    <div className={`w-full h-full ${bg.preview}`}></div>
                  ) : (
                    <img src={bg.src} alt={bg.name} className="w-full h-full object-cover" />
                  )}
                  <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                    <span className="text-white font-bold tracking-wide shadow-sm">{bg.name}</span>
                  </div>
                  {currentBg?.id === bg.id && <div className="absolute top-2 right-2 bg-purple-600 text-white p-1 rounded-full shadow-lg"><Check size={12} /></div>}
                </button>
              ))}
            </div>

            <div className="text-xs font-bold text-gray-500 uppercase mb-2">Upload Custom Background</div>
            <div
              className={`relative border-2 border-dashed rounded-xl p-4 transition-all flex items-center justify-between gap-3 cursor-pointer group hover:border-blue-400 hover:bg-blue-50 ${dragActive ? 'border-blue-500 bg-blue-50 scale-[1.02]' : 'border-gray-300 bg-gray-50'}`}
              onDragEnter={handleDrag}
              onDragLeave={handleDrag}
              onDragOver={handleDrag}
              onDrop={handleDrop}
              onClick={() => fileInputRef.current?.click()}
            >
              <input ref={fileInputRef} type="file" accept="image/*" className="hidden" onChange={(e) => e.target.files && handleFile(e.target.files[0])} />
              <div className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors shrink-0 ${dragActive ? 'bg-blue-500 text-white' : 'bg-white text-blue-500 shadow-sm group-hover:scale-110'}`}>
                {dragActive ? <Download size={20} className="animate-bounce" /> : <UploadCloud size={20} />}
              </div>
              <div className="flex-1 text-left">
                <p className="text-gray-700 font-bold mb-1">
                  <span className="text-blue-600 hover:underline">Click to upload</span> or drag and drop
                </p>
                <p className="text-xs text-gray-400">SVG, PNG, JPG or GIF</p>
              </div>
              <div className="absolute top-2 right-2 flex gap-1">
                <div className="bg-white/80 backdrop-blur px-2 py-1 rounded text-[10px] font-bold text-gray-400 uppercase border border-gray-200">Paste Supported</div>
              </div>
            </div>

            <div className="mt-6 flex items-center justify-between bg-gray-50 p-3 rounded-xl border border-gray-100">
              <div className="flex items-center gap-2">
                <div className={`w-10 h-6 rounded-full p-1 cursor-pointer transition-colors ${applyToAll ? 'bg-blue-500' : 'bg-gray-300'}`} onClick={() => setApplyToAll(!applyToAll)}>
                  <div className={`w-4 h-4 bg-white rounded-full shadow-sm transition-transform ${applyToAll ? 'translate-x-4' : ''}`} />
                </div>
                <div className="flex flex-col">
                  <span className="text-sm font-bold text-gray-700">Apply to all slides</span>
                  <span className="text-[10px] text-gray-400">If unchecked, background only applies to current slide</span>
                </div>
              </div>
              {/* Fallback URL Input */}
              <div className="flex items-center gap-2">
                <span className="text-xs font-bold text-gray-400 uppercase">OR URL:</span>
                <input
                  type="text"
                  placeholder="Paste URL..."
                  className="border border-gray-300 rounded-lg px-2 py-1 text-xs w-32 outline-none focus:border-blue-500"
                  value={customUrl}
                  onChange={(e) => setCustomUrl(e.target.value)}
                  onClick={(e) => e.stopPropagation()}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && customUrl) {
                      const newBg = { id: 'custom-url-' + Date.now(), name: 'Custom URL', type: 'image', src: customUrl, textColor: 'text-white' };
                      onAddCustom(newBg);
                      onSelect(newBg, applyToAll ? 'all' : 'single');
                    }
                  }}
                />
                {customUrl && (
                  <button onClick={() => {
                    const newBg = { id: 'custom-url-' + Date.now(), name: 'Custom URL', type: 'image', src: customUrl, textColor: 'text-white' };
                    onAddCustom(newBg);
                    onSelect(newBg, applyToAll ? 'all' : 'single');
                  }} className="p-1 bg-blue-500 text-white rounded hover:bg-blue-600"><Check size={14} /></button>
                )}
              </div>
            </div>
          </div>
        </div>
      );
    };

    const SettingsModal = ({ onClose, onSave, downloadData, uploadData, roster, allRosters, activeRosterId, onSetActiveRoster, onAddRoster, onDeleteRoster, onRenameRoster, fileInputRef, initialTab = 'roster', isGridEnabled, onToggleGrid, currentBg, onBgSelect, myBackgrounds, onAddCustomBg, onDeleteCustomBg, backupEnabled, setBackupEnabled, backupInterval, setBackupInterval, settingsTimePickerIndex, setSettingsTimePickerIndex }) => {
      const [activeTab, setActiveTab] = useState(initialTab);
      const [mode, setMode] = useState('list');

      const [localRoster, setLocalRoster] = useState(roster);
      const [bulkText, setBulkText] = useState(roster.map(s => s.name).join('\n'));

      // Roster Management State
      const [isAddingRoster, setIsAddingRoster] = useState(false);
      const [newRosterName, setNewRosterName] = useState('');
      const [newRosterBulk, setNewRosterBulk] = useState('');
      const [editingRosterId, setEditingRosterId] = useState(null);
      const [editRosterName, setEditRosterName] = useState('');

      // Feedback form state
      const [feedbackName, setFeedbackName] = useState('');
      const [feedbackEmail, setFeedbackEmail] = useState('');
      const [feedbackMessage, setFeedbackMessage] = useState('');
      const [feedbackCopied, setFeedbackCopied] = useState(false);

      const toggleActive = (id) => {
        setLocalRoster(prev => prev.map(s => s.id === id ? { ...s, active: !s.active } : s));
      };

      const handleBulkSave = () => {
        const lines = bulkText.split('\n').map(n => n.trim()).filter(n => n);
        const newRoster = lines.map(name => {
          const existing = roster.find(s => s.name === name);
          return existing ? existing : { id: Math.random().toString(36).substr(2, 9), name: name, active: true };
        });
        setLocalRoster(newRoster);
        setMode('list');
      };

      const handleSaveAll = () => {
        onSave(localRoster);
        onClose();
      };

      const [feedbackStatus, setFeedbackStatus] = useState('');

      const handleFeedbackSubmit = () => {
        const subject = encodeURIComponent('HomeRoom Feedback');
        const body = encodeURIComponent(`Name: ${feedbackName}\nEmail: ${feedbackEmail}\n\nMessage:\n${feedbackMessage}`);
        window.location.href = `mailto:jeffhennigar@gmail.com?subject=${subject}&body=${body}`;
        setFeedbackName(''); setFeedbackEmail(''); setFeedbackMessage('');
        setFeedbackStatus('Opening email client...');
        setTimeout(() => setFeedbackStatus(''), 3000);
      };

      const handleGmailSubmit = () => {
        const subject = encodeURIComponent('HomeRoom Feedback');
        const body = encodeURIComponent(`Name: ${feedbackName}\nEmail: ${feedbackEmail}\n\nMessage:\n${feedbackMessage}`);
        window.open(`https://mail.google.com/mail/?view=cm&fs=1&to=jeffhennigar@gmail.com&su=${subject}&body=${body}`, '_blank');
        setFeedbackName(''); setFeedbackEmail(''); setFeedbackMessage('');
        setFeedbackStatus('Opening Gmail...');
        setTimeout(() => setFeedbackStatus(''), 3000);
      };

      const handleCopyFeedback = () => {
        const text = `To: jeffhennigar@gmail.com\nSubject: HomeRoom Feedback\n\nName: ${feedbackName}\nEmail: ${feedbackEmail}\n\nMessage:\n${feedbackMessage}`;
        navigator.clipboard.writeText(text).then(() => {
          setFeedbackCopied(true);
          setFeedbackStatus('Copied to clipboard!');
          setTimeout(() => { setFeedbackCopied(false); setFeedbackStatus(''); }, 3000);
        });
      };

      // Schedule template state
      const [scheduleTemplate, setScheduleTemplate] = useState(getScheduleTemplate());
      const [selectedDay, setSelectedDay] = useState('Monday');
      const [settingsEmojiPickerIndex, setSettingsEmojiPickerIndex] = useState(null);
      const [showCopyMenu, setShowCopyMenu] = useState(false);
      const [copyStatus, setCopyStatus] = useState('');
      const [copyTargetDays, setCopyTargetDays] = useState([]);
      const [showRosterMenu, setShowRosterMenu] = useState(false); // Item 13 Custom Dropdown State

      const copyScheduleDays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].filter(d => d !== selectedDay);

      const handleBatchCopy = () => {
        if (copyTargetDays.length === 0) return;
        setScheduleTemplate(prev => {
          const next = { ...prev };
          const sourceItems = prev[selectedDay] || [];
          copyTargetDays.forEach(day => {
            next[day] = JSON.parse(JSON.stringify(sourceItems));
          });
          return next;
        });
        setCopyStatus(`Copied to ${copyTargetDays.length} days!`);
        setTimeout(() => setCopyStatus(''), 2000);
        setShowCopyMenu(false);
        setCopyTargetDays([]);
      };

      const toggleCopyDay = (day) => {
        setCopyTargetDays(prev => prev.includes(day) ? prev.filter(d => d !== day) : [...prev, day]);
      };

      const addScheduleItem = (day) => {
        const newItem = { id: Date.now().toString(), time: '09:00', emoji: '📚', title: 'New Activity', description: '' };
        setScheduleTemplate(prev => ({ ...prev, [day]: [...(prev[day] || []), newItem] }));
      };

      const updateScheduleItem = (day, index, field, value) => {
        setScheduleTemplate(prev => {
          const items = [...(prev[day] || [])];
          items[index] = { ...items[index], [field]: value };
          return { ...prev, [day]: items };
        });
      };

      const removeScheduleItem = (day, index) => {
        setScheduleTemplate(prev => ({ ...prev, [day]: prev[day].filter((_, i) => i !== index) }));
      };

      const saveSchedule = () => {
        saveScheduleTemplate(scheduleTemplate);
      };

      const tabs = [
        { id: 'roster', label: 'Roster', icon: <User size={16} /> },
        { id: 'appearance', label: 'Appearance', icon: <ImageIcon size={16} /> },
        { id: 'schedule', label: 'Schedule', icon: <Calendar size={16} /> },
        { id: 'data', label: 'Data', icon: <Download size={16} /> },
        { id: 'about', label: 'About', icon: <Info size={16} /> },
        { id: 'feedback', label: 'Feedback', icon: <Mail size={16} /> }
      ];

      return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
          <div className="bg-white rounded-2xl shadow-2xl w-[600px] h-[600px] flex flex-col overflow-hidden relative">
            {/* Header with Tabs */}
            <div className="border-b">
              <div className="p-4 flex justify-between items-center">
                <h3 className="font-bold text-gray-800 flex items-center gap-2"><Settings size={20} /> Settings</h3>
                <button onClick={onClose} className="p-2 hover:bg-gray-200 rounded-full text-gray-500"><X size={20} /></button>
              </div>
              <div className="flex px-2 pb-0">
                {tabs.map(tab => (
                  <button
                    key={tab.id}
                    onClick={() => setActiveTab(tab.id)}
                    className={`flex items-center gap-1.5 px-3 py-2 text-xs font-bold transition-all border-b-2 ${activeTab === tab.id ? 'text-blue-600 border-blue-600' : 'text-gray-500 border-transparent hover:text-gray-700 hover:bg-gray-50'}`}
                  >
                    {tab.icon} {tab.label}
                  </button>
                ))}
              </div>
            </div>

            {/* Tab Content */}
            <div className="flex-1 overflow-y-auto custom-scrollbar">
              {/* GENERAL TAB */}


              {/* ROSTER TAB */}
              {activeTab === 'roster' && (
                <div className="p-4">
                  <div className="mb-6 space-y-4">
                    <div className="flex-1">
                      <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Active Roster</label>
                      <div className="flex gap-2">
                        {/* Custom Dropdown (Item 13) */}
                        <div className="relative flex-1">
                          <button onClick={() => setShowRosterMenu(!showRosterMenu)} className="w-full flex justify-between items-center border border-gray-200 rounded-lg px-3 py-2 text-sm bg-white hover:bg-gray-50 transition-colors focus:ring-2 focus:ring-purple-500 shadow-sm">
                            <span className="font-bold text-gray-700 truncate mr-2">{allRosters.find(r => r.id === activeRosterId)?.name || 'Select Class'}</span>
                            <ChevronDown size={16} className={`text-gray-400 transition-transform ${showRosterMenu ? 'rotate-180' : ''}`} />
                          </button>
                          {showRosterMenu && (
                            <div className="absolute top-full left-0 right-0 mt-1 bg-white border border-gray-100 rounded-xl shadow-xl py-1 z-50 animate-in fade-in zoom-in-95 duration-200 max-h-48 overflow-y-auto custom-scrollbar">
                              {allRosters.map(r => (
                                <button key={r.id} onClick={() => { onSetActiveRoster(r.id); setShowRosterMenu(false); }} className={`w-full text-left px-4 py-2 text-sm font-bold hover:bg-purple-50 transition-colors flex justify-between items-center ${activeRosterId === r.id ? 'text-purple-700 bg-purple-50' : 'text-gray-600'}`}>
                                  <span className="truncate">{r.name}</span>
                                  {activeRosterId === r.id && <Check size={14} className="flex-shrink-0 ml-2" />}
                                </button>
                              ))}
                            </div>
                          )}
                        </div>
                        <button onClick={() => { setIsAddingRoster(true); setNewRosterName(''); setNewRosterBulk(''); }} className="p-2 bg-purple-100 text-purple-600 rounded-lg hover:bg-purple-200" title="Add New Roster"><Plus size={18} /></button>
                        <button onClick={() => {
                          const r = allRosters.find(r => r.id === activeRosterId);
                          setEditingRosterId(activeRosterId);
                          setEditRosterName(r?.name || '');
                        }} className="p-2 border border-gray-200 text-gray-400 rounded-lg hover:bg-gray-50" title="Rename Roster"><Edit3 size={16} /></button>
                        {allRosters.length > 1 && (
                          <button onClick={() => {
                            if (confirm('Delete this entire roster?')) onDeleteRoster(activeRosterId);
                          }} className="p-2 border border-red-100 text-red-500 rounded-lg hover:bg-red-50" title="Delete Roster"><Trash2 size={16} /></button>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* Add Roster Modal Overlay */}
                  {isAddingRoster && (
                    <div className="absolute inset-0 bg-white/95 z-10 flex flex-col p-6 animate-in fade-in zoom-in-95 duration-200">
                      <h3 className="text-lg font-bold text-gray-800 mb-4">Create New Class</h3>
                      <div className="space-y-4 flex-1">
                        <div>
                          <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Class Name</label>
                          <input autoFocus type="text" value={newRosterName} onChange={e => setNewRosterName(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-purple-500 font-bold text-gray-700" placeholder="e.g., Period 2 - Science" />
                        </div>
                        <div className="flex-1 flex flex-col">
                          <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Students (Paste list)</label>
                          <textarea value={newRosterBulk} onChange={e => setNewRosterBulk(e.target.value)} className="flex-1 border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-purple-500 resize-none custom-scrollbar" placeholder="Paste names here..." style={{ minHeight: '200px' }} />
                        </div>
                        <div className="flex gap-2 justify-end pt-2">
                          <button onClick={() => setIsAddingRoster(false)} className="px-4 py-2 text-gray-500 font-bold hover:bg-gray-100 rounded-lg">Cancel</button>
                          <button disabled={!newRosterName.trim()} onClick={() => {
                            onAddRoster(newRosterName, newRosterBulk);
                            setIsAddingRoster(false);
                          }} className="px-6 py-2 bg-purple-600 text-white font-bold rounded-lg hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed">Create Class</button>
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Rename Roster Overlay */}
                  {editingRosterId && (
                    <div className="absolute inset-0 bg-white/95 z-10 flex flex-col p-6 animate-in fade-in zoom-in-95 duration-200 justify-center items-center">
                      <div className="w-full max-w-sm space-y-4">
                        <h3 className="text-lg font-bold text-gray-800 text-center">Rename Class</h3>
                        <input autoFocus type="text" value={editRosterName} onChange={e => setEditRosterName(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-blue-500 font-bold text-gray-700 text-center" />
                        <div className="flex gap-2 justify-center">
                          <button onClick={() => setEditingRosterId(null)} className="px-4 py-2 text-gray-500 font-bold hover:bg-gray-100 rounded-lg">Cancel</button>
                          <button onClick={() => {
                            onRenameRoster(editingRosterId, editRosterName);
                            setEditingRosterId(null);
                          }} className="px-6 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700">Save Name</button>
                        </div>
                      </div>
                    </div>
                  )}

                  <div className="flex items-center justify-between mb-4 bg-gray-50 p-2 rounded-xl">
                    <div className="text-sm font-bold text-gray-700 px-2">{localRoster.length} Students</div>
                    <div className="flex gap-1">
                      <button onClick={() => setMode('list')} className={`px-2.5 py-1.5 rounded-lg text-xs font-bold transition-all ${mode === 'list' ? 'bg-white shadow text-purple-600' : 'text-gray-500'}`}>List</button>
                      <button onClick={() => setMode('bulk')} className={`px-2.5 py-1.5 rounded-lg text-xs font-bold transition-all ${mode === 'bulk' ? 'bg-white shadow text-purple-600' : 'text-gray-500'}`}>Bulk Add</button>
                    </div>
                  </div>

                  <>
                    {mode === 'list' ? (
                      <div className="p-4">
                        <div className="space-y-1">
                          {localRoster.map(s => (
                            <div key={s.id} onClick={() => toggleActive(s.id)} className={`flex items-center justify-between p-2 rounded cursor-pointer border ${s.active ? 'bg-white border-gray-100 hover:border-blue-300' : 'bg-gray-50 border-transparent opacity-60'}`}>
                              <div className="flex items-center gap-3">
                                <div className={`w-4 h-4 rounded border flex items-center justify-center ${s.active ? 'bg-blue-500 border-blue-500' : 'border-gray-400 bg-white'}`}>
                                  {s.active && <Check size={12} className="text-white" />}
                                </div>
                                <span className={`font-medium ${s.active ? 'text-gray-900' : 'text-gray-500 line-through'}`}>{s.name}</span>
                              </div>
                            </div>
                          ))}
                          {localRoster.length === 0 && <div className="text-center text-gray-400 py-8 px-4 bg-gray-50 rounded-xl my-4 border border-dashed border-gray-200">No students yet. Click Bulk Add to add your class.</div>}
                        </div>
                      </div>
                    ) : (
                      <div className="p-4 flex flex-col" style={{ minHeight: '300px' }}>
                        <label className="text-xs font-bold text-gray-500 uppercase mb-2">Edit Names (One per line)</label>
                        <textarea
                          className="flex-1 border-2 border-gray-200 rounded-xl p-4 outline-none focus:border-blue-500 focus:ring-4 focus:ring-blue-50 transition-all custom-scrollbar resize-none font-medium text-slate-700"
                          autoFocus
                          value={bulkText}
                          onChange={e => setBulkText(e.target.value)}
                          style={{ minHeight: '200px' }}
                        />
                        <button onClick={handleBulkSave} className="mt-2 bg-blue-100 text-blue-700 font-bold py-2 rounded-lg hover:bg-blue-200">Update List</button>
                      </div>
                    )}
                  </>
                </div>
              )}

              {/* APPEARANCE TAB */}
              {activeTab === 'appearance' && (
                <div className="flex flex-col h-full overflow-hidden">
                  <div className="flex-1 min-h-0">
                    <AppearanceSettings
                      currentBg={currentBg}
                      onSelect={onBgSelect}
                      isGridEnabled={isGridEnabled}
                      onToggleGrid={onToggleGrid}
                      myBackgrounds={myBackgrounds}
                      onAddCustom={onAddCustomBg}
                      onDeleteCustom={onDeleteCustomBg}
                    />
                  </div>
                </div>
              )}

              {/* SCHEDULE TAB */}
              {activeTab === 'schedule' && (
                <div className="p-4">
                  <p className="text-gray-600 text-sm mb-4">Set up your weekly schedule template. Each day's activities will load automatically when you open the Schedule widget.</p>

                  {/* Day Selector */}
                  <div className="flex gap-2 mb-4 items-start">
                    <div className="flex-1 flex gap-1 overflow-x-auto pb-2 custom-scrollbar">
                      {['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].map(day => (
                        <button
                          key={day}
                          onClick={() => setSelectedDay(day)}
                          className={`px-3 py-1.5 text-xs font-bold rounded-lg transition-colors whitespace-nowrap ${selectedDay === day ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                        >
                          {day.slice(0, 3)}
                        </button>
                      ))}
                    </div>
                    <div className="relative shrink-0 pt-0.5">
                      <button onClick={() => setShowCopyMenu(!showCopyMenu)} className="px-3 py-1.5 text-xs font-bold rounded-lg bg-blue-100 text-blue-600 hover:bg-blue-200 flex items-center gap-1"><Copy size={12} /> Copy...</button>
                      {showCopyMenu && (
                        <div className="absolute top-full right-0 mt-1 bg-white rounded-lg shadow-xl border border-gray-200 z-50 w-48 overflow-hidden flex flex-col">
                          <div className="px-3 py-2 text-[10px] font-bold text-gray-400 uppercase bg-gray-50 border-b">Copy {selectedDay} to:</div>
                          <div className="max-h-48 overflow-y-auto custom-scrollbar p-1">
                            {copyScheduleDays.map(d => (
                              <label key={d} className="flex items-center gap-2 w-full text-left px-2 py-1.5 text-xs hover:bg-blue-50 text-gray-700 font-medium rounded cursor-pointer">
                                <input
                                  type="checkbox"
                                  checked={copyTargetDays.includes(d)}
                                  onChange={() => toggleCopyDay(d)}
                                  className="w-3.5 h-3.5 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                                />
                                {d}
                              </label>
                            ))}
                          </div>
                          <div className="p-2 border-t bg-gray-50">
                            <button
                              onClick={handleBatchCopy}
                              disabled={copyTargetDays.length === 0}
                              className="w-full bg-blue-600 text-white rounded py-1 text-xs font-bold hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                              Copy ({copyTargetDays.length})
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                  {copyStatus && <span className="text-xs text-green-600 font-bold block mb-2 animate-pulse">{copyStatus}</span>}

                  {/* Activities for selected day */}
                  <div className="space-y-2 max-h-60 overflow-y-auto custom-scrollbar">
                    {(scheduleTemplate[selectedDay] || []).map((item, index) => (
                      <div key={item.id} className="relative flex gap-2 p-2 bg-gray-50 rounded-lg border border-gray-200" style={{ zIndex: (settingsEmojiPickerIndex === index || settingsTimePickerIndex === index) ? 50 : 0 }}>
                        <div className="flex flex-col items-center shrink-0 w-20 relative">
                          <button onClick={(e) => { e.stopPropagation(); setSettingsTimePickerIndex(settingsTimePickerIndex === index ? null : index); }} className="w-full text-xs font-bold text-indigo-600 bg-white border border-indigo-100 px-1 py-1 rounded hover:bg-indigo-50">
                            {(() => {
                              const [h, m] = (item.time || '09:00').split(':');
                              const hours = parseInt(h);
                              const ampm = hours >= 12 ? 'PM' : 'AM';
                              const displayH = hours % 12 || 12;
                              return `${displayH}:${m} ${ampm}`;
                            })()}
                          </button>
                          {settingsTimePickerIndex === index && (
                            <TimePicker time={item.time || '09:00'} onChange={(t) => updateScheduleItem(selectedDay, index, 'time', t)} onClose={() => setSettingsTimePickerIndex(null)} />
                          )}
                        </div>
                        <div className="relative">
                          <div
                            className="text-lg cursor-pointer hover:scale-110 transition-transform p-1 rounded hover:bg-gray-200 emoji"
                            onClick={() => setSettingsEmojiPickerIndex(settingsEmojiPickerIndex === index ? null : index)}
                          >
                            {item.emoji || '📚'}
                          </div>
                          {settingsEmojiPickerIndex === index && (
                            <div className="absolute left-0 top-full mt-1 z-50 bg-white rounded-xl shadow-xl border border-gray-200 p-2 w-48 max-h-40 overflow-y-auto custom-scrollbar">
                              <div className="grid grid-cols-5 gap-1">
                                {SCHEDULE_EMOJIS.map((emoji, i) => (
                                  <button
                                    key={i}
                                    onClick={() => { updateScheduleItem(selectedDay, index, 'emoji', emoji); setSettingsEmojiPickerIndex(null); }}
                                    className={`text-xl p-1.5 rounded-lg hover:bg-indigo-100 transition-colors emoji ${item.emoji === emoji ? 'bg-indigo-200 ring-2 ring-indigo-400' : ''}`}
                                  >
                                    {emoji}
                                  </button>
                                ))}
                              </div>
                            </div>
                          )}
                        </div>
                        <div className="flex-1 min-w-0">
                          <input
                            type="text"
                            value={item.title || ''}
                            onChange={(e) => updateScheduleItem(selectedDay, index, 'title', e.target.value)}
                            className="w-full text-sm font-bold bg-transparent border-none outline-none"
                            placeholder="Activity name"
                          />
                          <input
                            type="text"
                            value={item.description || ''}
                            onChange={(e) => updateScheduleItem(selectedDay, index, 'description', e.target.value)}
                            className="w-full text-xs text-gray-500 bg-transparent border-none outline-none"
                            placeholder="Description (optional)"
                          />
                        </div>
                        <button onClick={() => removeScheduleItem(selectedDay, index)} className="p-1 text-red-400 hover:text-red-600 self-center"><X size={14} /></button>
                      </div>
                    ))}
                    {(scheduleTemplate[selectedDay] || []).length === 0 && (
                      <div className="text-center py-4 text-gray-400 text-sm">No activities for {selectedDay}</div>
                    )}
                  </div>

                  <div className="flex gap-2 mt-3">
                    <button onClick={() => addScheduleItem(selectedDay)} className="flex-1 py-2 bg-indigo-100 text-indigo-700 font-bold text-sm rounded-lg hover:bg-indigo-200 flex items-center justify-center gap-1">
                      <Plus size={16} /> Add Activity
                    </button>
                  </div>

                  <button onClick={saveSchedule} className="w-full mt-4 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-xl flex items-center justify-center gap-2">
                    <Save size={18} /> Save Schedule Template
                  </button>
                </div>
              )}

              {/* ABOUT TAB */}
              {activeTab === 'about' && (
                <div className="p-6">
                  <div className="flex flex-col items-center mb-6">
                    <img src="https://raw.githubusercontent.com/jeffhennigar/homeroom/main/effortless_edtech_logo.png" alt="Effortless EdTech" className="w-24 h-24 rounded-full bg-white p-1 shadow-lg mb-3 object-contain" />
                    <h2 className="text-lg font-bold text-gray-800">HomeRoom</h2>
                    <div className="px-2 py-0.5 bg-blue-100 text-blue-700 text-[10px] font-bold rounded-full mb-2 tracking-widest uppercase">Version 1.0</div>
                    <p className="text-gray-500 text-sm text-center">A classroom management tool by <span className="font-semibold text-teal-600">Effortless EdTech</span></p>
                  </div>
                  <div className="space-y-2">
                    <a href="mailto:jeffhennigar@gmail.com" className="flex items-center gap-3 p-3 bg-gray-50 hover:bg-blue-50 rounded-xl transition-colors group">
                      <div className="p-2 bg-blue-100 rounded-lg text-blue-600"><Mail size={16} /></div>
                      <div><div className="text-xs text-gray-400">Contact</div><div className="text-sm font-semibold text-gray-700 group-hover:text-blue-600">jeffhennigar@gmail.com</div></div>
                    </a>
                    <a href="https://www.teacherspayteachers.com/store/effortless-edtech" target="_blank" rel="noopener noreferrer" className="flex items-center gap-3 p-3 bg-gray-50 hover:bg-green-50 rounded-xl transition-colors group">
                      <div className="p-2 bg-green-100 rounded-lg text-green-600"><ExternalLink size={16} /></div>
                      <div><div className="text-xs text-gray-400">Teachers Pay Teachers</div><div className="text-sm font-semibold text-gray-700 group-hover:text-green-600">Visit Store &rarr;</div></div>
                    </a>
                    <a href="https://www.etsy.com/shop/EffortlessEdtech" target="_blank" rel="noopener noreferrer" className="flex items-center gap-3 p-3 bg-gray-50 hover:bg-orange-50 rounded-xl transition-colors group">
                      <div className="p-2 bg-orange-100 rounded-lg text-orange-600"><ExternalLink size={16} /></div>
                      <div><div className="text-xs text-gray-400">Etsy Shop</div><div className="text-sm font-semibold text-gray-700 group-hover:text-orange-600">Visit Store &rarr;</div></div>
                    </a>
                  </div>
                </div>
              )}

              {/* DATA TAB */}
              {activeTab === 'data' && (
                <div className="p-6">
                  <div className="mb-6 p-4 bg-blue-50 border border-blue-100 rounded-xl flex gap-3">
                    <div className="shrink-0 text-blue-500"><Info size={20} /></div>
                    <div className="text-sm text-blue-900">
                      <p className="font-bold mb-1">Your Data is Private & Local</p>
                      <p className="opacity-80 leading-relaxed">HomeRoom stores all your data directly on this computer's browser. Nothing is sent to the cloud. Please <strong>backup your data regularly</strong> to keep it safe!</p>
                    </div>
                  </div>
                  <div className="space-y-3">
                    <button onClick={downloadData} className="w-full flex items-center gap-3 p-4 bg-green-50 hover:bg-green-100 rounded-xl transition-colors group border border-green-200">
                      <div className="p-3 bg-green-500 rounded-xl text-white"><Download size={20} /></div>
                      <div className="text-left">
                        <div className="font-bold text-gray-800">Export Data</div>
                        <div className="text-xs text-gray-500">Download roster, widgets, and settings</div>
                      </div>
                    </button>
                    <button onClick={() => fileInputRef.current.click()} className="w-full flex items-center gap-3 p-4 bg-blue-50 hover:bg-blue-100 rounded-xl transition-colors group border border-blue-200">
                      <div className="p-3 bg-blue-500 rounded-xl text-white"><Upload size={20} /></div>
                      <div className="text-left">
                        <div className="font-bold text-gray-800">Import Data</div>
                        <div className="text-xs text-gray-500">Restore from a backup file</div>
                      </div>
                    </button>
                  </div>

                  {/* Backup Settings */}
                  <div className="mt-6 border-t pt-6">
                    <h4 className="text-sm font-bold text-gray-700 mb-3 uppercase tracking-wide">Backup Reminders</h4>
                    <div className="flex flex-col gap-3">
                      <div className="flex items-center justify-between p-3 bg-gray-50 rounded-xl border border-gray-100">
                        <div className="flex items-center gap-2">
                          <div className={`p-2 rounded-lg ${backupEnabled ? 'bg-indigo-100 text-indigo-600' : 'bg-gray-200 text-gray-500'}`}><Bell size={18} /></div>
                          <div>
                            <div className="font-bold text-sm text-gray-800">Backup Reminders</div>
                            <div className="text-[10px] text-gray-500">Show a prompt to backup your data</div>
                          </div>
                        </div>
                        <button
                          onClick={() => setBackupEnabled(!backupEnabled)}
                          className={`relative w-12 h-7 rounded-full transition-colors ${backupEnabled ? 'bg-indigo-500' : 'bg-gray-300'}`}
                        >
                          <div className={`absolute top-1 w-5 h-5 rounded-full bg-white shadow-sm transition-transform ${backupEnabled ? 'translate-x-6' : 'translate-x-1'}`} />
                        </button>
                      </div>

                      {backupEnabled && (
                        <div className="flex items-center justify-between p-3 bg-gray-50 rounded-xl border border-gray-100">
                          <div className="flex items-center gap-2">
                            <div className="p-2 bg-blue-100 text-blue-600 rounded-lg"><Clock size={18} /></div>
                            <div>
                              <div className="font-bold text-sm text-gray-800">Reminder Frequency</div>
                              <div className="text-[10px] text-gray-500">How often to remind you</div>
                            </div>
                          </div>
                          <div className="flex items-center gap-2">
                            <input
                              type="number"
                              min="1"
                              max="365"
                              value={backupInterval}
                              onChange={(e) => setBackupInterval(Math.max(1, parseInt(e.target.value) || 1))}
                              className="w-16 p-2 text-center font-bold border rounded-lg outline-none focus:border-indigo-500 border-gray-300"
                            />
                            <span className="text-sm font-bold text-gray-500">days</span>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              )}

              {/* FEEDBACK TAB */}
              {activeTab === 'feedback' && (
                <div className="p-6">
                  <p className="text-gray-600 text-sm mb-4">Have feedback or questions? Fill out this form and we'll get back to you!</p>
                  <div className="space-y-3">
                    <div>
                      <label className="text-xs font-bold text-gray-500 uppercase mb-1 block">Your Name</label>
                      <input type="text" value={feedbackName} onChange={e => setFeedbackName(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-blue-500 transition-colors" placeholder="Your name" />
                    </div>
                    <div>
                      <label className="text-xs font-bold text-gray-500 uppercase mb-1 block">Email</label>
                      <input type="email" value={feedbackEmail} onChange={e => setFeedbackEmail(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-blue-500 transition-colors" placeholder="you@school.edu" />
                    </div>
                    <div>
                      <label className="text-xs font-bold text-gray-500 uppercase mb-1 block">Message</label>
                      <textarea value={feedbackMessage} onChange={e => setFeedbackMessage(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-blue-500 transition-colors resize-none" rows={4} placeholder="Your feedback or question..." />
                    </div>

                    <div className="flex flex-col gap-2">
                      <button onClick={handleFeedbackSubmit} disabled={!feedbackMessage.trim()} className="w-full py-3 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-300 text-white font-bold rounded-xl transition-colors flex items-center justify-center gap-2">
                        <Mail size={18} /> Send via Email App
                      </button>

                      <div className="flex gap-2">
                        <button onClick={handleGmailSubmit} disabled={!feedbackMessage.trim()} className="flex-1 py-3 bg-red-100 hover:bg-red-200 disabled:bg-gray-100 disabled:text-gray-400 text-red-700 font-bold rounded-xl transition-colors flex items-center justify-center gap-2">
                          <Mail size={18} /> Send via Gmail
                        </button>
                        <button onClick={handleCopyFeedback} disabled={!feedbackMessage.trim()} className="flex-1 py-3 bg-gray-100 hover:bg-gray-200 disabled:bg-gray-50 disabled:text-gray-300 text-gray-700 font-bold rounded-xl transition-colors flex items-center justify-center gap-2">
                          {feedbackCopied ? <Check size={18} className="text-green-600" /> : <List size={18} />} {feedbackCopied ? 'Copied!' : 'Copy Text'}
                        </button>
                      </div>
                    </div>
                    <p className="text-[10px] text-gray-400 text-center mt-2">
                      If "Send" doesn't work, use "Copy Text" and paste it into your email manually to <b>jeffhennigar@gmail.com</b>
                    </p>
                    {feedbackStatus && <div className="text-center text-sm font-bold text-green-600 mt-2 bg-green-50 p-2 rounded-lg animate-in fade-in slide-in-from-bottom-2">{feedbackStatus}</div>}
                  </div>
                </div>
              )}
            </div>

            {/* Footer - only show save for roster tab */}
            {activeTab === 'roster' && (
              <div className="p-4 border-t bg-gray-50 flex justify-end gap-2">
                <button onClick={onClose} className="px-4 py-2 text-slate-500 font-bold hover:bg-slate-100 rounded-lg transition-colors">Cancel</button>
                <button onClick={handleSaveAll} className="px-6 py-2 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow transition-all active:scale-95 flex items-center gap-2">
                  <Save size={18} /> Save
                </button>
              </div>
            )}
          </div >
        </div >
      );
    };





    const App = () => {
      const [allRosters, setAllRosters] = useState(() => {
        try {
          const stored = localStorage.getItem('homeroom_all_rosters');
          if (stored) return JSON.parse(stored);
        } catch (e) { }
        // Migration of single roster
        const defaultRoster = getRoster();
        const defaultSlides = (() => {
          try { return JSON.parse(localStorage.getItem(WIDGETS_STORAGE_KEY)) || [[]]; } catch (e) { return [[]]; }
        })();
        return [{ id: 'default', name: 'My Class', roster: defaultRoster, slides: defaultSlides }];
      });

      const [activeRosterId, setActiveRosterId] = useState(() => {
        return localStorage.getItem('homeroom_active_roster_id') || 'default';
      });

      const [roster, setRoster] = useState(() => {
        const active = allRosters.find(r => r.id === (localStorage.getItem('homeroom_active_roster_id') || 'default'));
        return active ? active.roster : allRosters[0].roster;
      });

      const [slides, setSlides] = useState(() => {
        const active = allRosters.find(r => r.id === (localStorage.getItem('homeroom_active_roster_id') || 'default'));
        return active ? (active.slides || [[]]) : [[]];
      });

      const handleSetActiveRoster = (id) => {
        if (id === activeRosterId) return;
        // Save CURRENT state to current roster entry BEFORE switching
        setAllRosters(prev => prev.map(r => r.id === activeRosterId ? { ...r, roster, slides } : r));

        // Load NEW state
        const next = allRosters.find(r => r.id === id);
        if (next) {
          setRoster(next.roster);
          setSlides(next.slides || [[]]);
          setCurrentSlideIndex(0);
          setActiveRosterId(id);
          localStorage.setItem('homeroom_active_roster_id', id);
        }
      };

      const handleAddRoster = (name) => {
        const newRoster = { id: Date.now().toString(), name: name, roster: [], slides: [[]] };
        setAllRosters(prev => [...prev, newRoster]);
        handleSetActiveRoster(newRoster.id);
      };

      const handleDeleteRoster = (id) => {
        if (allRosters.length <= 1) return;
        const newRosters = allRosters.filter(r => r.id !== id);
        setAllRosters(newRosters);
        if (activeRosterId === id) {
          handleSetActiveRoster(newRosters[0].id);
        }
      };

      const handleRenameRoster = (id, newName) => {
        setAllRosters(prev => prev.map(r => r.id === id ? { ...r, name: newName } : r));
      };

      // Periodic Sync to allRosters
      useEffect(() => {
        setAllRosters(prev => prev.map(r => r.id === activeRosterId ? { ...r, roster, slides } : r));
      }, [roster, slides, activeRosterId]);

      useEffect(() => {
        localStorage.setItem('homeroom_all_rosters', JSON.stringify(allRosters));
      }, [allRosters]);

      const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
      const [selectedId, setSelectedId] = useState(null);
      const [spotlightId, setSpotlightId] = useState(null);
      const [settingsTimePickerIndex, setSettingsTimePickerIndex] = useState(null); // Settings Schedule UI
      const [maxZIndex, setMaxZIndex] = useState(10);
      const [currentTime, setCurrentTime] = useState(new Date().toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' }));
      const [isDockMinimized, setIsDockMinimized] = useState(false);
      const [dockOrder, setDockOrder] = useState(() => {
        const stored = getDockOrder();
        const mainDefaults = ['TIMER', 'GROUP_MAKER', 'SEAT_PICKER', 'SCHEDULE', 'TEXT', 'RANDOMIZER'];
        const drawerDefaults = ['TRAFFIC', 'QR', 'WEBCAM', 'DICE', 'VOTE', 'WHITEBOARD', 'YOUTUBE'];
        const allDefaults = [...mainDefaults, ...drawerDefaults];

        // 1. Legacy Array Migration
        if (Array.isArray(stored)) {
          const extras = stored.filter(id => !allDefaults.includes(id));
          const missing = allDefaults.filter(id => !stored.includes(id));
          return {
            main: mainDefaults.filter(id => stored.includes(id)),
            drawer: [...drawerDefaults.filter(id => stored.includes(id)), ...extras, ...missing]
          };
        }

        // 2. Object Storage (Ensure new tools are added)
        if (stored && stored.main && stored.drawer) {
          const currentIds = [...stored.main, ...stored.drawer];
          const missing = allDefaults.filter(id => !currentIds.includes(id));
          if (missing.length > 0) {
            return {
              ...stored,
              drawer: [...stored.drawer, ...missing]
            };
          }
          return stored;
        }

        // 3. Fallback / First Load
        return {
          main: mainDefaults,
          drawer: drawerDefaults
        };
      });

      const [isDockLocked, setIsDockLocked] = useState(true);
      const [showMoreDrawer, setShowMoreDrawer] = useState(false);
      const drawerRef = useRef(null);

      // Undo/Redo History
      const [history, setHistory] = useState([]);
      const [redoStack, setRedoStack] = useState([]);

      const addToHistory = () => {
        setHistory(prev => [...prev.slice(-19), slides]);
        setRedoStack([]);
      };

      const handleUndo = useCallback(() => {
        if (history.length === 0) return;
        const previous = history[history.length - 1];
        setRedoStack(prev => [...prev, slides]);
        setSlides(previous);
        setHistory(prev => prev.slice(0, -1));
      }, [history, slides]);

      const handleRedo = useCallback(() => {
        if (redoStack.length === 0) return;
        const next = redoStack[redoStack.length - 1];
        setHistory(prev => [...prev, slides]);
        setSlides(next);
        setRedoStack(prev => prev.slice(0, -1));
      }, [redoStack, slides]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
            if (['INPUT', 'TEXTAREA'].includes(document.activeElement?.tagName) || document.activeElement?.isContentEditable) return;
            e.preventDefault();
            if (e.shiftKey) handleRedo();
            else handleUndo();
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [handleUndo, handleRedo]);

      useEffect(() => {
        saveDockOrder(dockOrder);
      }, [dockOrder]);

      useEffect(() => {
        const handleClickOutside = (event) => {
          if (drawerRef.current && !drawerRef.current.contains(event.target)) {
            setShowMoreDrawer(false);
          }
        };
        if (showMoreDrawer) document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
      }, [showMoreDrawer]);

      const handleDockDrop = (e, targetLocation, targetId = null) => {
        e.preventDefault();
        const widgetType = e.dataTransfer.getData('widgetType');
        if (!widgetType) return;

        let sourceLocation = 'main';
        if (dockOrder.drawer.includes(widgetType)) sourceLocation = 'drawer';
        else if (!dockOrder.main.includes(widgetType)) return;

        // If dropping onto itself, do nothing
        if (widgetType === targetId) return;

        setDockOrder(prev => {
          // Remove from old lists
          const newMain = prev.main.filter(id => id !== widgetType);
          const newDrawer = prev.drawer.filter(id => id !== widgetType);

          // Prepare target list
          let targetList = targetLocation === 'main' ? [...newMain] : [...newDrawer];

          if (targetId) {
            // Insert BEFORE the targetId
            const targetIndex = targetList.indexOf(targetId);
            if (targetIndex !== -1) {
              targetList.splice(targetIndex, 0, widgetType);
            } else {
              targetList.push(widgetType); // Fallback
            }
          } else {
            // Append to end
            targetList.push(widgetType);
          }

          if (targetLocation === 'main') {
            return { main: targetList, drawer: newDrawer };
          } else {
            return { main: newMain, drawer: targetList };
          }
        });
      };


      const [showOnboarding, setShowOnboarding] = useState(false);
      const [showSettingsModal, setShowSettingsModal] = useState(false);
      const [settingsInitialTab, setSettingsInitialTab] = useState('roster');
      const [showBackupPrompt, setShowBackupPrompt] = useState(true); // Control visibility of backup prompt

      // New Background State
      const [background, setBackground] = useState(getBackground());
      const [slideBackgrounds, setSlideBackgrounds] = useState(() => { try { return JSON.parse(localStorage.getItem('homeroom_slide_backgrounds')) || {}; } catch (e) { return {}; } });
      const [customBackgrounds, setCustomBackgrounds] = useState(() => { try { return JSON.parse(localStorage.getItem('homeroom_my_backgrounds')) || []; } catch (e) { return []; } });
      const [showBgPicker, setShowBgPicker] = useState(false);
      const [isGridEnabled, setIsGridEnabled] = useState(() => { try { return JSON.parse(localStorage.getItem('homeroom_grid_enabled')) || false; } catch (e) { return false; } });
      useEffect(() => { localStorage.setItem('homeroom_grid_enabled', JSON.stringify(isGridEnabled)); }, [isGridEnabled]);
      useEffect(() => { localStorage.setItem('homeroom_slide_backgrounds', JSON.stringify(slideBackgrounds)); }, [slideBackgrounds]);
      useEffect(() => { localStorage.setItem('homeroom_my_backgrounds', JSON.stringify(customBackgrounds)); }, [customBackgrounds]);

      // Backup Settings
      const [backupEnabled, setBackupEnabled] = useState(() => { try { return JSON.parse(localStorage.getItem('homeroom_backup_enabled')) ?? true; } catch { return true; } });
      const [backupInterval, setBackupInterval] = useState(() => { try { return parseInt(localStorage.getItem('homeroom_backup_interval')) || 7; } catch { return 7; } });

      useEffect(() => { localStorage.setItem('homeroom_backup_enabled', JSON.stringify(backupEnabled)); }, [backupEnabled]);
      useEffect(() => { localStorage.setItem('homeroom_backup_interval', backupInterval); }, [backupInterval]);

      // Initialize backup timer on first load
      useEffect(() => {
        if (!localStorage.getItem('homeroom_last_backup')) {
          localStorage.setItem('homeroom_last_backup', Date.now());
        }
      }, []);

      // --- PERSISTENCE & DATA ---
      useEffect(() => {
        const t = setTimeout(() => {
          localStorage.setItem(WIDGETS_STORAGE_KEY, JSON.stringify(slides));
          saveRoster(roster);
        }, 1000);
        return () => clearTimeout(t);
      }, [slides, roster]);

      const fileInputRef = useRef(null);
      const downloadData = () => {
        const data = {
          roster: getRoster(), // Current roster
          allRosters, // All class rosters
          activeRosterId,
          scheduleTemplate: getScheduleTemplate(), // Weekly schedule
          dock: getDockOrder(),
          widgets: slides, // Includes widget data (seating positions, randomizer picks, whiteboard lines, etc.)
          background,
          slideBackgrounds,
          customBackgrounds,
          timestamp: Date.now()
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `homeroom-backup-${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        // Auto-dismiss prompt on backup
        setShowBackupPrompt(false);
        localStorage.setItem('homeroom_last_backup', Date.now());
      };

      const uploadData = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const d = JSON.parse(ev.target.result);
            // Restore Rosters
            if (d.allRosters) {
              setAllRosters(d.allRosters);
              localStorage.setItem('homeroom_all_rosters', JSON.stringify(d.allRosters));
            } else if (d.roster) {
              // Backward compatibility for single roster exports
              saveRoster(d.roster);
              setRoster(d.roster);
            }

            if (d.activeRosterId) {
              setActiveRosterId(d.activeRosterId);
              localStorage.setItem('homeroom_active_roster_id', d.activeRosterId);
            }

            if (d.scheduleTemplate) {
              setScheduleTemplate(d.scheduleTemplate);
              saveScheduleTemplate(d.scheduleTemplate);
            }
            // Restore other settings
            if (d.dock) saveDockOrder(d.dock);
            if (d.background) saveBackground(d.background);
            if (d.widgets) setSlides(d.widgets);
            if (d.dock) setDockOrder(d.dock);
            if (d.background) setBackground(d.background);
            if (d.slideBackgrounds) setSlideBackgrounds(d.slideBackgrounds);
            if (d.customBackgrounds) setCustomBackgrounds(d.customBackgrounds);
            alert("Import successful!");
          } catch (err) { alert("Import failed."); }
        };
        reader.readAsText(file);
      };

      // ... existing effects/callbacks ...
      const widgets = slides[currentSlideIndex] || [];
      const setWidgets = useCallback((updater) => { setSlides(prev => { const newS = [...prev]; newS[currentSlideIndex] = updater(newS[currentSlideIndex]); return newS; }); }, [currentSlideIndex]);
      const currentDate = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
      useEffect(() => { const timer = setInterval(() => { setCurrentTime(new Date().toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })); }, 1000 * 60); return () => clearInterval(timer); }, []);
      useEffect(() => { if (!hasRoster()) setShowOnboarding(true); }, []);

      const currentBg = slideBackgrounds[currentSlideIndex] || background;

      const handleBgSelect = (newBg, mode = 'all') => {
        if (mode === 'single') {
          setSlideBackgrounds(prev => ({ ...prev, [currentSlideIndex]: newBg }));
        } else {
          setBackground(newBg);
          saveBackground(newBg);
          setSlideBackgrounds({});
        }
      };

      // --- WIDGET MANAGEMENT ---
      const addWidget = (type, extraData = {}) => { addToHistory(); const id = Date.now().toString(); const size = WIDGET_SIZES[type]; let startY = (window.innerHeight / 2) - (size.height / 2) + (Math.random() * 40 - 20); if (type === 'GROUP_MAKER') startY -= 100; const position = { x: (window.innerWidth / 2) - (size.width / 2) + (Math.random() * 40 - 20), y: startY }; let data = { fontSize: 16 }; if (type === 'TIMER') data = { ...data, timeLeft: 120, isRunning: false, mode: 'visual' }; if (type === 'RANDOMIZER') data = { ...data, students: getInitialStudents(), currentName: null, isAnimating: false }; if (type === 'GROUP_MAKER') data = { ...data, students: getInitialStudents(), groupCount: 4, groups: [] }; if (type === 'SEAT_PICKER') { const savedDesks = getSeatLayout(); if (savedDesks && savedDesks.length > 0) { data = { ...data, desks: savedDesks, isEditing: false }; } else { const initialStudents = getInitialStudents(); const initialDesks = initialStudents.slice(0, 8).map((s, i) => ({ id: `desk-${i}`, x: 50 + (i % 4) * 120, y: 50 + Math.floor(i / 4) * 100, student: s.name, color: 'blue', type: 'student', rotation: 0 })); data = { ...data, desks: initialDesks, isEditing: false }; } } if (type === 'TEXT') data = { ...data, mode: 'text', content: '', items: [] }; if (type === 'WEBCAM') data = { ...data, isMirrored: true, isActive: true }; if (type === 'DICE') data = { ...data, sides: 6, diceCount: 1, results: [1], isRolling: false }; if (type === 'TRAFFIC') data = { ...data, activeLight: null }; if (type === 'QR') data = { ...data, url: '' }; if (type === 'VOTE') data = { ...data, question: 'Class Poll', options: [{ id: 1, text: 'Yes', count: 0 }, { id: 2, text: 'No', count: 0 }] }; if (type === 'WHITEBOARD') data = { ...data, lines: [], color: '#000000', size: 5, tool: 'pen' }; if (type === 'SCHEDULE') { const template = getScheduleTemplate(); const today = DAYS_OF_WEEK[new Date().getDay()]; data = { ...data, items: template[today] || [] }; } if (type === 'YOUTUBE') { data = { ...data, youtubeUrl: '' }; } data = { ...data, ...extraData }; const newWidget = { id, type, position, size, zIndex: maxZIndex + 1, data, isMinimized: false }; setWidgets(prev => [...prev, newWidget]); setMaxZIndex(prev => prev + 1); setSelectedId(id); };

      useEffect(() => {
        const handlePaste = (e) => {
          if (['INPUT', 'TEXTAREA'].includes(document.activeElement?.tagName) || document.activeElement?.isContentEditable) return;
          const items = e.clipboardData?.items;
          if (!items) return;
          for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.type.indexOf('image') !== -1) {
              const blob = item.getAsFile();
              const reader = new FileReader();
              reader.onload = (event) => {
                const src = event.target.result;
                const img = new Image();
                img.onload = () => {
                  // Whiteboard widget with image
                  const aspect = img.width / img.height;
                  addWidget('WHITEBOARD', {
                    imageItems: [{ id: Date.now().toString(), x: 0.5, y: 0.5, src, scale: 1, width: 300, height: 300 / aspect }]
                  });
                };
                img.src = src;
              };
              reader.readAsDataURL(blob);
              e.preventDefault();
              return;
            }
            if (item.type.indexOf('text/plain') !== -1 && item.kind === 'string') {
              item.getAsString((text) => {
                if (text && text.trim()) {
                  addWidget('TEXT', { content: text });
                }
              });
              e.preventDefault();
              return;
            }
          }
        };
        window.addEventListener('paste', handlePaste);
        return () => window.removeEventListener('paste', handlePaste);
      }, [addWidget]);
      const removeWidget = (id) => { addToHistory(); const widget = widgets.find(w => w.id === id); if (widget && widget.type === 'SEAT_PICKER' && widget.data.desks) { saveSeatLayout(widget.data.desks); } setWidgets(prev => prev.filter(w => w.id !== id)); if (selectedId === id) setSelectedId(null); };
      const updateWidgetLayout = useCallback((id, newPos, newSize) => { setWidgets(prev => prev.map(w => w.id === id ? { ...w, position: newPos, size: newSize } : w)); }, [setWidgets]);
      const updateWidgetData = useCallback((id, updates) => { setWidgets(prev => prev.map(w => w.id === id ? { ...w, data: { ...w.data, ...updates } } : w)); }, [setWidgets]);
      const bringToFront = (id) => { setSelectedId(id); setMaxZIndex(prev => prev + 1); setWidgets(prev => prev.map(w => w.id === id ? { ...w, zIndex: maxZIndex + 1 } : w)); };
      const toggleMinimize = useCallback((id) => { setWidgets(prev => prev.map(w => w.id === id ? { ...w, isMinimized: !w.isMinimized } : w)); }, [setWidgets]);
      const toggleSpotlight = useCallback((id) => { setSpotlightId(prev => prev === id ? null : id); }, []);
      const nextSlide = () => { if (currentSlideIndex === slides.length - 1) { setSlides(prev => [...prev, []]); } setCurrentSlideIndex(prev => prev + 1); setSelectedId(null); };
      const prevSlide = () => { if (currentSlideIndex > 0) { setCurrentSlideIndex(prev => prev - 1); setSelectedId(null); } };
      const deleteCurrentSlide = () => {
        if (slides.length <= 1) return;

        const idxToDelete = currentSlideIndex;

        // 1. Update Slides Array
        setSlides(prev => {
          const newSlides = prev.filter((_, i) => i !== idxToDelete);
          return newSlides.length > 0 ? newSlides : [[]];
        });

        // 2. Update Slide Backgrounds (Shift remaining keys down)
        setSlideBackgrounds(prev => {
          const next = { ...prev };
          delete next[idxToDelete];
          // Determine max index to check - safe to iterate existing
          Object.keys(next).map(Number).sort((a, b) => a - b).forEach(k => {
            if (k > idxToDelete) {
              next[k - 1] = next[k];
              delete next[k];
            }
          });
          return next;
        });

        // 3. Update Index (Safely)
        // If we deleted the last slide (e.g. index 2 of 3), go to 1.
        // If we deleted middle (index 1 of 3), stay at 1 (which holds old #2).
        if (currentSlideIndex >= slides.length - 1) {
          setCurrentSlideIndex(Math.max(0, slides.length - 2));
        }
      };

      const duplicateCurrentSlide = () => {
        addToHistory();
        const newSlide = JSON.parse(JSON.stringify(slides[currentSlideIndex])).map(w => ({ ...w, id: Date.now().toString() + Math.random().toString(36).substr(2, 5) }));
        setSlides(prev => [...prev, newSlide]);
        // Also copy background if custom
        if (slideBackgrounds[currentSlideIndex]) {
          setSlideBackgrounds(prev => ({ ...prev, [slides.length]: slideBackgrounds[currentSlideIndex] }));
        }
        setCurrentSlideIndex(slides.length);
      };

      // Removed legacy saveDock/handleDockDrop
      const renderDockItem = (id, location) => {
        const info = DOCK_LABELS[id];
        if (!info) return null;
        return (
          <div
            key={id}
            draggable={!isDockLocked}
            onDragStart={(e) => {
              e.dataTransfer.setData('widgetType', id);
              // Rotation Snap Effect for GHOST
              e.currentTarget.style.transform = "none";
              // Hide source immediately after ghost generation
              requestAnimationFrame(() => {
                e.target.classList.add('opacity-0');
              });
            }}
            onDragEnd={(e) => {
              e.currentTarget.style.transform = "";
              e.target.classList.remove('opacity-0');
            }}
            onDragOver={(e) => {
              if (!isDockLocked) {
                e.preventDefault();
                e.stopPropagation();
              }
            }}
            onDrop={(e) => {
              if (!isDockLocked) {
                e.preventDefault();
                e.stopPropagation();
                handleDockDrop(e, location, id);
              }
            }}
            onClick={() => {
              // When unlocked (edit mode), don't add widget on click - only drag works
              if (!isDockLocked || isDockMinimized) return;
              addWidget(id);
              if (location === 'drawer') setShowMoreDrawer(false);
            }}
            className={`flex flex-col items-center gap-1 p-2 rounded-xl transition-all cursor-pointer group relative
              ${!isDockLocked ? 'hover:bg-blue-50 hover:scale-105 active:scale-95 cursor-grab active:cursor-grabbing border-2 border-dashed border-blue-300' : 'hover:bg-white/50 hover:scale-110 active:scale-95 border-2 border-transparent'}`}
            title={!isDockLocked ? "Drag to reorder" : info.label}
          >
            {!isDockLocked && <div className="absolute -top-1 -right-1 bg-blue-500 text-white rounded-full p-0.5 shadow-sm"><GripVertical size={10} /></div>}
            <div className={`p-2 rounded-xl text-slate-600 transition-colors ${!isDockLocked ? 'bg-blue-100' : 'bg-white/80 group-hover:bg-white group-hover:text-blue-600 shadow-sm'}`}>
              {info.icon}
            </div>
            <span className="text-[10px] font-bold text-slate-700 group-hover:text-slate-900">{info.label}</span>
          </div>
        );
      };

      const renderWidgetContent = (widget) => { const props = { widget, updateData: updateWidgetData, roster, onUpdateRoster: setRoster }; switch (widget.type) { case 'TIMER': return <TimerWidget {...props} />; case 'RANDOMIZER': return <RandomizerWidget {...props} />; case 'GROUP_MAKER': return <GroupMakerWidget {...props} />; case 'SEAT_PICKER': return <SeatPickerWidget {...props} />; case 'TEXT': return <TextWidget {...props} />; case 'WEBCAM': return <WebcamWidget {...props} />; case 'DICE': return <DiceWidget {...props} />; case 'TRAFFIC': return <TrafficLightWidget {...props} />; case 'QR': return <QRCodeWidget {...props} />; case 'VOTE': return <VoteWidget {...props} />; case 'WHITEBOARD': return <WhiteboardWidget {...props} />; case 'SCHEDULE': return <ScheduleWidget {...props} onOpenSettings={() => { setSettingsInitialTab('schedule'); setShowSettingsModal(true); }} />; case 'YOUTUBE': return <YouTubeWidget {...props} />; default: return null; } };

      return (
        <div className="w-screen h-screen overflow-hidden relative" style={{
          backgroundColor: '#dbeafe', // fallback
          backgroundImage: currentBg && currentBg.id !== 'default' ? `url(${currentBg.src})` : 'none',
          backgroundSize: 'cover',
          backgroundPosition: 'center'
        }}>
          {/* Modals */}
          {showOnboarding && <OnboardingModal onComplete={() => setShowOnboarding(false)} onSaveRoster={(newRoster) => setRoster(newRoster)} />}
          {showSettingsModal && <SettingsModal
            roster={roster}
            allRosters={allRosters}
            activeRosterId={activeRosterId}
            onSetActiveRoster={handleSetActiveRoster}
            onAddRoster={handleAddRoster}
            onDeleteRoster={handleDeleteRoster}
            onRenameRoster={handleRenameRoster}
            onClose={() => { setShowSettingsModal(false); setSettingsInitialTab('roster'); }}
            onSave={(newRoster) => { setRoster(newRoster); }}
            downloadData={downloadData}
            uploadData={uploadData}
            fileInputRef={fileInputRef}
            initialTab={settingsInitialTab}
            isGridEnabled={isGridEnabled}
            onToggleGrid={setIsGridEnabled}
            currentBg={currentBg}
            onBgSelect={handleBgSelect}
            myBackgrounds={customBackgrounds}
            onAddCustomBg={(bg) => setCustomBackgrounds(prev => [bg, ...prev])}
            onDeleteCustomBg={(id) => setCustomBackgrounds(prev => prev.filter(bg => bg.id !== id))}
            backupEnabled={backupEnabled}
            setBackupEnabled={setBackupEnabled}
            backupInterval={backupInterval}
            setBackupInterval={setBackupInterval}
            settingsTimePickerIndex={settingsTimePickerIndex}
            setSettingsTimePickerIndex={setSettingsTimePickerIndex}
          />}
          <input ref={fileInputRef} type="file" accept=".json" className="hidden" onChange={uploadData} />

          {/* Default Geometric Background Layer */}
          {(!currentBg || currentBg.id === 'default') && (
            <div className="absolute inset-0 pointer-events-none z-0">
              <svg className="w-full h-full" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="gradOrange" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style={{ stopColor: "#fb923c", stopOpacity: 1 }} /><stop offset="100%" style={{ stopColor: "#ea580c", stopOpacity: 1 }} /></linearGradient><linearGradient id="gradBlue" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style={{ stopColor: "#3b82f6", stopOpacity: 1 }} /><stop offset="100%" style={{ stopColor: "#60a5fa", stopOpacity: 1 }} /></linearGradient></defs><rect width="100%" height="100%" fill="#dbeafe" /><path d="M1920 0V900C1400 900 1000 400 500 0H1920Z" fill="url(#gradOrange)" opacity="0.9" /><path d="M1920 0V700C1600 700 1300 300 900 0H1920Z" fill="#fed7aa" opacity="0.5" /><path d="M0 1080V300C500 300 900 800 1600 1080H0Z" fill="url(#gradBlue)" opacity="0.9" /><path d="M0 1080V500C300 500 700 900 1200 1080H0Z" fill="#93c5fd" opacity="0.5" /></svg>
            </div>
          )}

          {/* Dark Overlay for better contrast on images */}
          {currentBg && currentBg.id !== 'default' && <div className="absolute inset-0 bg-black/20 z-0 pointer-events-none" />}

          {/* Top Info Bar - Clickable for About - CHANGED Z-INDEX TO 1 TO BE BELOW WIDGETS */}
          <div className={`absolute top-10 left-12 z-1 select-none transition-colors duration-300 hover:opacity-80 ${currentBg.textColor || 'text-slate-800'}`} style={{ textShadow: currentBg.textColor === 'text-white' ? '0 1px 3px rgba(0,0,0,0.3)' : 'none' }}>
            <div onClick={() => setShowSettingsModal(true)} className="cursor-pointer">
              <div className="flex items-center gap-1.5 mb-1 opacity-80"><div className={`px-1.5 py-0.5 rounded text-[10px] font-black tracking-tighter shadow-md ${currentBg.textColor === 'text-white' ? 'bg-white text-slate-900' : 'bg-slate-800 text-white'}`}>HR</div><div className="text-xs font-bold uppercase tracking-widest">HomeRoom</div></div>
              <div className={`text-8xl font-bold tracking-tight ${currentBg.textColor === 'text-white' ? 'drop-shadow-lg' : 'drop-shadow-sm'}`}>{currentTime}</div>
              <div className={`text-3xl font-medium mt-2 opacity-90 ${currentBg.textColor === 'text-white' ? 'drop-shadow-md' : ''}`}>{currentDate}</div>
            </div>
            {(() => {
              // Don't show if disabled
              if (!backupEnabled) return null;

              const last = localStorage.getItem('homeroom_last_backup');
              // If last backup time is valid check vs interval, otherwise wait (initialized to now above)
              const days = last ? (Date.now() - Number(last)) / (1000 * 60 * 60 * 24) : 0;

              if (days > backupInterval && showBackupPrompt) {
                return (
                  <div className="mt-4 animate-in fade-in slide-in-from-top-2 flex items-center gap-1 bg-red-100/90 rounded-lg p-1 pr-2 shadow-sm border border-red-200">
                    <button onClick={downloadData} className="flex items-center gap-2 text-red-600 px-2 py-1 rounded text-xs font-bold hover:bg-red-200 transition-colors">
                      <AlertTriangle size={14} /> Backup Data
                    </button>
                    <div className="w-px h-4 bg-red-200" />
                    <button onClick={() => setShowBackupPrompt(false)} className="p-1 text-red-400 hover:text-red-700 hover:bg-red-200 rounded-md transition-colors" title="Dismiss">
                      <X size={14} />
                    </button>
                  </div>
                );
              }
              return null;
            })()}
          </div>

          {/* Top Right Controls */}
          <div className="absolute top-8 right-8 z-50 flex gap-2">
            <button onClick={handleUndo} disabled={history.length === 0} className="p-3 bg-white/80 backdrop-blur-md hover:bg-white text-slate-600 disabled:opacity-30 disabled:hover:bg-white/80 rounded-full shadow-lg border border-white/50 transition-all active:scale-95 group" title="Undo (Ctrl+Z)">
              <Undo2 size={24} className="group-hover:text-blue-600" />
            </button>
          </div>

          {/* Widgets Area */}
          <div className="absolute inset-0 z-30 pointer-events-none">
            {/* Spotlight Overlay - inside widget container so only spotlighted widget appears above it */}
            {spotlightId && <div className="fixed inset-0 bg-black/80 cursor-pointer pointer-events-auto animate-in fade-in duration-300" style={{ zIndex: 9999, boxShadow: 'inset 0 0 200px 100px rgba(0,0,0,0.5)' }} onClick={() => setSpotlightId(null)}><div className="absolute inset-0 bg-gradient-radial from-transparent via-transparent to-black/40" /></div>}
            {widgets.map(w => (<DraggableResizable key={w.id} id={w.id} position={w.position} size={w.size} zIndex={w.zIndex} isSelected={selectedId === w.id} isMinimized={w.isMinimized} isSpotlighted={spotlightId === w.id} isGridEnabled={isGridEnabled} widgetType={w.type} onSelect={bringToFront} onUpdate={updateWidgetLayout} onRemove={removeWidget} onMinimizeToggle={toggleMinimize} onSpotlight={toggleSpotlight} onFontSizeChange={['WHITEBOARD', 'QR', 'WEBCAM', 'YOUTUBE'].includes(w.type) ? undefined : (d) => updateWidgetData(w.id, { fontSize: Math.max(8, (w.data.fontSize || 16) + d) })}>{renderWidgetContent(w)}</DraggableResizable>))}
          </div>

          {/* Slide Controls - Refined Styles */}
          <div className="absolute bottom-6 right-8 z-50 flex items-center pointer-events-none">
            <div className="pointer-events-auto flex items-center gap-0.5 backdrop-blur-2xl rounded-full shadow-2xl p-0.5 ring-1 ring-white/50 relative">
              <div className="absolute inset-0 bg-white/20 rounded-full overflow-hidden -z-10 border border-white/40" />
              <button onClick={prevSlide} disabled={currentSlideIndex === 0} className="p-1.5 hover:bg-white/40 rounded-full text-gray-500 hover:text-blue-700 transition-all duration-200 disabled:opacity-20 group active:scale-95"><ChevronLeft size={20} /></button>
              <div className="px-2 flex items-center justify-center min-w-[35px]"><span className="text-[10px] font-extrabold text-blue-900 leading-none">{currentSlideIndex + 1} / {slides.length}</span></div>
              <button onClick={nextSlide} className="p-1.5 hover:bg-white/40 rounded-full text-gray-500 hover:text-blue-700 transition-all duration-200 group active:scale-95 flex items-center justify-center">{currentSlideIndex === slides.length - 1 ? <Plus size={20} /> : <ChevronRight size={20} />}</button>
              {slides.length > 0 && (
                <>
                  <div className="w-px h-4 bg-gray-300 mx-1" />
                  <button onClick={duplicateCurrentSlide} className="p-1.5 hover:bg-indigo-50 rounded-xl text-gray-400 hover:text-indigo-600 transition-all duration-200 active:scale-95" title="Duplicate Page"><ArrowRightSquare size={16} /></button>
                </>
              )}
              {slides.length > 1 && (
                <>
                  <div className="w-px h-4 bg-gray-300 mx-1" />
                  <button onClick={deleteCurrentSlide} className="p-1.5 hover:bg-red-50 rounded-xl text-gray-400 hover:text-red-600 transition-all duration-200 active:scale-95" title="Delete Page"><Trash2 size={16} /></button>
                </>
              )}
            </div>
          </div>

          {/* Dock */}
          <div className="absolute bottom-6 left-0 right-0 z-50 flex flex-col items-center justify-end pointer-events-none">
            <div className={`max-w-6xl mx-4 mb-4 transition-all duration-300 ease-in-out origin-bottom pointer-events-auto ${isDockMinimized ? 'translate-y-20 opacity-0 scale-95 pointer-events-none invisible' : 'translate-y-0 opacity-100 scale-100 visible'}`}>
              <div className={`flex items-center backdrop-blur-2xl rounded-3xl shadow-2xl p-0.5 ring-1 ring-white/50 relative`}>
                <div className="absolute inset-0 bg-white/20 rounded-3xl overflow-hidden -z-10 border border-white/40">
                  <div className="absolute inset-0 bg-gradient-to-b from-white/40 to-white/5 pointer-events-none" />
                </div>



                {/* MAIN DOCK */}
                <div
                  className={`flex gap-2 p-2 rounded-xl border-2 transition-all duration-300 ease-in-out ${!isDockLocked ? 'bg-blue-50/50 border-dashed border-blue-200 min-w-[200px]' : 'border-transparent'}`}
                  onDragOver={(e) => { e.preventDefault(); e.currentTarget.classList.add('bg-blue-100'); }}
                  onDragLeave={(e) => e.currentTarget.classList.remove('bg-blue-100')}
                  onDrop={(e) => {
                    e.currentTarget.classList.remove('bg-blue-100');
                    handleDockDrop(e, 'main');
                  }}
                >
                  {dockOrder.main.map((id) => renderDockItem(id, 'main'))}
                </div>

                <div className="w-px h-8 bg-slate-300 mx-2" />

                {/* MORE DRAWER BUTTON */}
                <div className="relative" ref={drawerRef}>
                  <button
                    onClick={() => setShowMoreDrawer(!showMoreDrawer)}
                    className={`flex flex-col items-center gap-1 p-2 rounded-xl transition-all cursor-pointer group
                            ${showMoreDrawer ? 'bg-indigo-100' : 'hover:bg-white/50'}
                            ${!isDockLocked && dockOrder.drawer.length > 0 ? 'border-2 border-dashed border-indigo-300 bg-indigo-50' : ''}
                        `}
                    onDragOver={(e) => {
                      if (!isDockLocked) {
                        e.preventDefault();
                        setShowMoreDrawer(true);
                      }
                    }}
                    onDrop={(e) => {
                      if (!isDockLocked) {
                        e.preventDefault();
                        handleDockDrop(e, 'drawer');
                      }
                    }}
                  >
                    <div className={`p-2 rounded-xl text-indigo-600 transition-colors ${showMoreDrawer ? 'bg-indigo-200 text-indigo-800' : 'bg-indigo-50 group-hover:bg-indigo-100 group-hover:text-indigo-700 shadow-sm'}`}>
                      {showMoreDrawer ? <ChevronDown size={24} /> : <MoreHorizontal size={24} />}
                    </div>
                    <span className="text-[10px] font-extrabold text-indigo-900 group-hover:text-indigo-700">More</span>
                  </button>

                  {/* DRAWER POPUP */}
                  {showMoreDrawer && (
                    <div
                      className="absolute bottom-full right-0 mb-4 bg-white/90 backdrop-blur-xl border border-white/50 p-4 rounded-2xl shadow-2xl flex flex-wrap gap-2 w-64 z-50 animate-in slide-in-from-bottom-2 fade-in duration-200"
                      onDragOver={(e) => { e.preventDefault(); e.currentTarget.classList.add('bg-indigo-50'); }}
                      onDragLeave={(e) => e.currentTarget.classList.remove('bg-indigo-50')}
                      onDrop={(e) => {
                        e.currentTarget.classList.remove('bg-indigo-50');
                        handleDockDrop(e, 'drawer');
                      }}
                    >
                      <div className="w-full text-[10px] font-bold text-slate-400 uppercase tracking-widest mb-1 border-b pb-1">Additional Tools</div>
                      {dockOrder.drawer.length > 0 ? (
                        dockOrder.drawer.map((id) => renderDockItem(id, 'drawer'))
                      ) : (
                        <div className="w-full text-center py-4 text-xs text-gray-400 italic">
                          {isDockLocked ? "No tools here." : "Drag tools here to hide them."}
                        </div>
                      )}
                    </div>
                  )}
                </div>

                <div className="w-px h-8 bg-slate-300 mx-2" />

                <button
                  onClick={() => setIsDockLocked(!isDockLocked)}
                  className={`p-3 rounded-full transition-all ${!isDockLocked ? 'bg-blue-100 text-blue-600 shadow-inner' : 'hover:bg-slate-100 text-slate-400 hover:text-slate-600'}`}
                  title={isDockLocked ? "Unlock Dock to Rearrange" : "Lock Dock"}
                >
                  {isDockLocked ? <Lock size={16} /> : <Unlock size={16} />}
                </button>
                <button
                  onClick={() => { setShowSettingsModal(true); setSettingsInitialTab('roster'); }}
                  className="p-3 rounded-full hover:bg-slate-100 text-slate-400 hover:text-slate-600 transition-colors"
                  title="Settings"
                >
                  <Settings size={20} />
                </button>
              </div>
            </div>
            <div className="pointer-events-auto transition-all duration-300 z-50 mt-4"><button onClick={() => setIsDockMinimized(!isDockMinimized)} className="bg-white/90 backdrop-blur-md hover:bg-white text-slate-500 hover:text-blue-600 p-1.5 rounded-full shadow-lg border border-white/50 transition-all active:scale-95">{isDockMinimized ? <ChevronUp size={22} /> : <ChevronDown size={22} />}</button></div>
          </div>
        </div>
      );
    };

    const ToolBtn = ({ icon, label, onClick, isEditing, index, moveTool }) => { const handleDragStart = (e) => { if (!isEditing) return; e.dataTransfer.setData('text/plain', index); e.dataTransfer.effectAllowed = 'move'; }; const handleDragOver = (e) => { if (!isEditing) return; e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }; const handleDrop = (e) => { if (!isEditing || !moveTool) return; e.preventDefault(); moveTool(e, index); }; return <button onClick={onClick} draggable={isEditing} onDragStart={handleDragStart} onDragOver={handleDragOver} onDrop={handleDrop} className={`flex flex-col items-center justify-center min-w-[55px] px-1.5 py-2 rounded-xl group transition-all duration-200 active:scale-95 ${isEditing ? 'cursor-move bg-blue-100/50 hover:bg-blue-200 border border-blue-200 hover:rotate-3' : 'hover:bg-blue-50'}`}><div className={`text-gray-500 group-hover:text-blue-600 mb-0.5 transition-colors p-1.5 bg-transparent group-hover:bg-white rounded-full shadow-none group-hover:shadow-sm ${isEditing ? 'text-blue-500' : ''}`}>{React.cloneElement(icon, { size: 20 })}</div><span className={`text-[9px] font-bold uppercase tracking-wide ${isEditing ? 'text-blue-600' : 'text-gray-400 group-hover:text-blue-600'}`}>{label}</span></button>; };

    const root = createRoot(document.getElementById('root')); root.render(<App />);
  </script>
</body>

</html>