<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HomeRoom</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      overflow: hidden;
    }

    .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
      background: transparent;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    /* Wobble animation for dock edit mode */
    @keyframes wobble {
      0% {
        transform: rotate(0deg);
      }

      25% {
        transform: rotate(-2deg);
      }

      75% {
        transform: rotate(2deg);
      }

      100% {
        transform: rotate(0deg);
      }
    }

    .animate-wobble {
      animation: wobble 0.3s infinite linear;
    }
  </style>
  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Import Map -->
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "lucide-react": "https://esm.sh/lucide-react@0.292.0"
    }
  }
  </script>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef, useCallback } from 'react';
    import { createRoot } from 'react-dom/client';
    import {
      Timer, Shuffle, Users, Type, Armchair,
      Camera, Dices, ChevronDown, ChevronUp,
      Maximize2, GripHorizontal, Minus, Plus, Pause, Play, RotateCcw,
      Settings, CheckSquare, Square, RefreshCw, GripVertical, Trash2,
      Wand2, CameraOff, FlipHorizontal, X, Bold, List, ChevronLeft, ChevronRight,
      Save, AlertCircle, Share2, Edit3, Layout, User, MoreVertical, MoreHorizontal, Briefcase,
      RotateCw, Lock, Unlock, Grip, Palette, Image as ImageIcon, UploadCloud,
      Sun, Moon, BarChart2, Italic, Underline, AlignLeft, Clock,
      Volume2, VolumeX, Download, Upload, Check, Info, ExternalLink, Mail, Calendar
    } from 'lucide-react';

    // --- CONSTANTS ---
    const DEFAULT_NAMES = [];


    const DESK_COLORS = {
      blue: 'bg-white border-blue-400',
      red: 'bg-red-50 border-red-400',
      green: 'bg-green-50 border-green-400',
      yellow: 'bg-yellow-50 border-yellow-400'
    };

    const INIT_DOCK_ORDER = ['TIMER', 'RANDOMIZER', 'GROUP_MAKER', 'SEAT_PICKER', 'SCHEDULE', 'TEXT', 'TRAFFIC', 'QR', 'WEBCAM', 'DICE', 'VOTE', 'WHITEBOARD'];
    const TrafficLightIcon = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <rect x="7" y="2" width="10" height="20" rx="4" />
        <circle cx="12" cy="7" r="2" />
        <circle cx="12" cy="12" r="2" />
        <circle cx="12" cy="17" r="2" />
      </svg>
    );

    const DOCK_LABELS = {
      TIMER: { label: 'Timer', icon: <Timer /> },
      RANDOMIZER: { label: 'Random', icon: <Shuffle /> },
      GROUP_MAKER: { label: 'Groups', icon: <Users /> },
      SEAT_PICKER: { label: 'Seats', icon: <Armchair /> },
      TEXT: { label: 'Text', icon: <Type /> },
      TRAFFIC: { label: 'Noise', icon: <TrafficLightIcon /> },
      QR: { label: 'QR Code', icon: <Share2 /> },
      WEBCAM: { label: 'Cam', icon: <Camera /> },
      DICE: { label: 'Dice', icon: <Dices /> },
      VOTE: { label: 'Poll', icon: <BarChart2 /> },
      WHITEBOARD: { label: 'Draw', icon: <Edit3 /> },
      SCHEDULE: { label: 'Schedule', icon: <Calendar /> }
    };

    // --- BACKGROUND PRESETS (UPDATED) ---
    const BACKGROUNDS = [
      { id: 'default', name: 'Original', type: 'preset', preview: 'bg-gradient-to-br from-blue-200 to-orange-200', style: {}, textColor: 'text-slate-800' },
      { id: 'whimsical', name: 'Whimsical', type: 'preset', preview: '', src: 'https://plus.unsplash.com/premium_photo-1747948722627-ddbc400ac06a?fm=jpg&q=80&w=1920&auto=format&fit=crop', textColor: 'text-white' },
      { id: 'forest', name: 'Forest', type: 'preset', preview: '', src: 'https://images.unsplash.com/photo-1470115636492-6d2b56f9146d?fm=jpg&q=80&w=1920&auto=format&fit=crop', textColor: 'text-white' },
      { id: 'ocean', name: 'Ocean', type: 'preset', preview: '', src: 'https://plus.unsplash.com/premium_photo-1666286163385-abe05f0326c4?fm=jpg&q=80&w=1920&auto=format&fit=crop', textColor: 'text-white' },
      { id: 'sunset', name: 'Sunset', type: 'preset', preview: '', src: 'https://images.unsplash.com/photo-1475924156734-496f6cac6ec1?fm=jpg&q=80&w=1920&auto=format&fit=crop', textColor: 'text-white' },
      { id: 'galaxy', name: 'Galaxy', type: 'preset', preview: '', src: 'https://images.unsplash.com/photo-1538370965046-79c0d6907d47?fm=jpg&q=80&w=1920&auto=format&fit=crop', textColor: 'text-white' },
      { id: 'puppy', name: 'Puppy', type: 'preset', preview: '', src: 'https://images.unsplash.com/photo-1517849845537-4d257902454a?auto=format&fit=crop&q=80&w=1920', textColor: 'text-white' },
      { id: 'kitten', name: 'Kitten', type: 'preset', preview: '', src: 'https://images.unsplash.com/photo-1514888286974-6c03e2ca1dba?auto=format&fit=crop&q=80&w=1920', textColor: 'text-white' }, // Landscape Kitten
    ];

    // --- STORAGE SERVICE ---
    const ROSTER_STORAGE_KEY = 'homeroom_roster_v2';
    const DOCK_ORDER_KEY = 'homeroom_dock_order';
    const BG_STORAGE_KEY = 'homeroom_background';
    const WIDGETS_STORAGE_KEY = 'homeroom_widgets';

    const getRoster = () => {
      try {
        const stored = JSON.parse(localStorage.getItem(ROSTER_STORAGE_KEY));
        if (!stored) return DEFAULT_NAMES.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true }));
        // Migration: If array of strings, convert to objects
        if (Array.isArray(stored) && stored.length > 0 && typeof stored[0] === 'string') {
          return stored.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true }));
        }
        return stored;
      } catch (e) { return DEFAULT_NAMES.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true })); }
    };
    const saveRoster = (roster) => { try { localStorage.setItem(ROSTER_STORAGE_KEY, JSON.stringify(roster)); } catch (e) { } };
    const hasRoster = () => !!localStorage.getItem(ROSTER_STORAGE_KEY);

    const getDockOrder = () => { try { return JSON.parse(localStorage.getItem(DOCK_ORDER_KEY)) || INIT_DOCK_ORDER; } catch (e) { return INIT_DOCK_ORDER; } };
    const saveDockOrder = (order) => { try { localStorage.setItem(DOCK_ORDER_KEY, JSON.stringify(order)); } catch (e) { } };

    const getBackground = () => { try { return JSON.parse(localStorage.getItem(BG_STORAGE_KEY)) || BACKGROUNDS[0]; } catch (e) { return BACKGROUNDS[0]; } };
    const saveBackground = (bg) => { try { localStorage.setItem(BG_STORAGE_KEY, JSON.stringify(bg)); } catch (e) { } };

    // Seat Layout Persistence (survives widget close/reopen)
    const SEAT_LAYOUT_KEY = 'homeroom_seat_layout';
    const getSeatLayout = () => { try { return JSON.parse(localStorage.getItem(SEAT_LAYOUT_KEY)); } catch (e) { return null; } };
    const saveSeatLayout = (desks) => { try { localStorage.setItem(SEAT_LAYOUT_KEY, JSON.stringify(desks)); } catch (e) { } };

    // Schedule Persistence
    const SCHEDULE_STORAGE_KEY = 'homeroom_schedule';
    const DAYS_OF_WEEK = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const getDefaultScheduleTemplate = () => ({ Monday: [], Tuesday: [], Wednesday: [], Thursday: [], Friday: [] });
    const getScheduleTemplate = () => { try { return JSON.parse(localStorage.getItem(SCHEDULE_STORAGE_KEY)) || getDefaultScheduleTemplate(); } catch (e) { return getDefaultScheduleTemplate(); } };
    const saveScheduleTemplate = (schedule) => { try { localStorage.setItem(SCHEDULE_STORAGE_KEY, JSON.stringify(schedule)); } catch (e) { } };

    const getInitialStudents = () => {
      const stored = getRoster();
      // stored is guaranteed to be objects now due to getRoster migration
      return stored;
    };

    const WIDGET_SIZES = {
      TIMER: { width: 280, height: 340 },
      RANDOMIZER: { width: 250, height: 250 },
      GROUP_MAKER: { width: 1000, height: 550 },
      SEAT_PICKER: { width: 900, height: 600 },
      TEXT: { width: 340, height: 260 },
      WEBCAM: { width: 320, height: 240 },
      DICE: { width: 300, height: 320 },
      TRAFFIC: { width: 140, height: 320 },
      QR: { width: 250, height: 280 },
      VOTE: { width: 400, height: 350 },
      WHITEBOARD: { width: 500, height: 400 },
      SCHEDULE: { width: 380, height: 500 }
    };

    // --- COMPONENTS ---
    // (DraggableResizable, TimerWidget, RandomizerWidget, GroupMakerWidget, WebcamWidget are UNCHANGED)
    // NOTE: In a real scenario I would include them, but here I trust the existing file has them.
    // Wait, the replace tool needs context. I will rely on existing lines being present or I need to rewrite them if I touch them.
    // I am NOT touching Timer, Randomizer, GroupMaker, Webcam.
    // I AM touching TextWidget, DiceWidget.
    // I AM adding VoteWidget.

    // I must include DraggableResizable definition if it's in the block I'm replacing?
    // StartLine: 75 closes `script`? No, 75 is imports.
    // My previous edit replaced up to line 276.
    // The previous view_file showed logic up to 385.
    // I will rewrite the CHANGED widgets and the constants block.

    // ... Skip Draggable/Timer/Randomizer/Group/Webcam ...

    const TextWidget = ({ widget, updateData }) => {
      const editorRef = useRef(null);
      const { content, fontSize = 16 } = widget.data;

      useEffect(() => {
        if (editorRef.current && document.activeElement !== editorRef.current) {
          if (editorRef.current.innerHTML !== (content || '')) {
            editorRef.current.innerHTML = content || '';
          }
        }
      }, [content]);

      const exec = (command, value = null) => {
        document.execCommand(command, false, value);
        if (editorRef.current) updateData(widget.id, { content: editorRef.current.innerHTML });
      };

      return (
        <div className="h-full bg-amber-50 flex flex-col font-sans">
          <div className="flex items-center gap-1 p-2 bg-amber-100/50 border-b border-amber-200/50 overflow-x-auto no-scrollbar">
            <select onChange={(e) => exec('fontName', e.target.value)} className="text-xs border rounded p-1 bg-white/50 w-24 mr-1">
              <option value="Arial">Arial</option>
              <option value="Times New Roman">Times</option>
              <option value="Courier New">Mono</option>
              <option value="Comic Sans MS">Comic</option>
            </select>
            <button onClick={() => exec('bold')} className="p-1.5 hover:bg-white/50 rounded text-amber-900 transition-colors" title="Bold"><Bold size={14} /></button>
            <button onClick={() => exec('italic')} className="p-1.5 hover:bg-white/50 rounded text-amber-900 transition-colors" title="Italic"><Italic size={14} /></button>
            <button onClick={() => exec('underline')} className="p-1.5 hover:bg-white/50 rounded text-amber-900 transition-colors" title="Underline"><Underline size={14} /></button>
            <div className="w-px h-4 bg-amber-300 mx-1" />
            <button onClick={() => exec('insertUnorderedList')} className="p-1.5 hover:bg-white/50 rounded text-amber-900 transition-colors" title="List"><List size={14} /></button>
          </div>
          <div className="flex-1 relative cursor-text group" onClick={() => editorRef.current?.focus()}>
            <div
              ref={editorRef}
              className="w-full h-full p-4 outline-none overflow-auto custom-scrollbar text-gray-800"
              contentEditable
              suppressContentEditableWarning
              onInput={(e) => updateData(widget.id, { content: e.currentTarget.innerHTML })}
              style={{ fontSize: fontSize + 'px' }}
            />
          </div>
        </div>
      );
    };

    const DiceWidget = ({ widget, updateData }) => {
      const { sides = 6, results = [1], isRolling, fontSize = 16 } = widget.data;
      const [showSettings, setShowSettings] = useState(false);
      const displayResults = results || [1];

      const roll = () => {
        if (isRolling) return;
        updateData(widget.id, { isRolling: true });
        let count = 0;
        const animate = () => {
          const temp = Array.from({ length: 1 }, () => Math.floor(Math.random() * sides) + 1);
          updateData(widget.id, { results: temp });
          count++;
          if (count < 10) { setTimeout(animate, 80); }
          else { updateData(widget.id, { isRolling: false }); }
        };
        animate();
      };

      const renderDot = (active) => <div className={`w-3 h-3 rounded-full ${active ? 'bg-indigo-600' : 'bg-transparent'}`} />;

      const renderFace = (num) => {
        if (sides !== 6) return <span className="font-black text-indigo-800" style={{ fontSize: (fontSize * 3) + 'px' }}>{num}</span>;

        // D6 Dot Layout
        const positions = {
          1: [4], 2: [0, 8], 3: [0, 4, 8], 4: [0, 2, 6, 8], 5: [0, 2, 4, 6, 8], 6: [0, 2, 3, 5, 6, 8]
        };
        const activeDots = positions[num] || [];
        return (
          <div className="grid grid-cols-3 gap-1.5 p-2">
            {[0, 1, 2, 3, 4, 5, 6, 7, 8].map(i => renderDot(activeDots.includes(i)))}
          </div>
        );
      };

      if (showSettings) {
        return (
          <div className="h-full bg-white flex flex-col p-4">
            <div className="flex justify-between items-center mb-4"><h3 className="font-bold">Dice Settings</h3><button onClick={() => setShowSettings(false)} className="text-blue-600">Done</button></div>
            <label className="text-sm font-bold text-gray-700">Number of Sides</label>
            <div className="flex items-center gap-2 mt-2">
              <input type="range" min="2" max="20" value={sides} onChange={e => updateData(widget.id, { sides: Number(e.target.value) })} className="flex-1 accent-indigo-600" />
              <span className="font-bold text-indigo-600 w-8 text-center">{sides}</span>
            </div>
          </div>
        );
      }

      return (
        <div className="h-full bg-gradient-to-br from-indigo-50 to-white flex flex-col items-center justify-center relative p-4 select-none cursor-pointer group" onClick={roll}>
          <button onClick={(e) => { e.stopPropagation(); setShowSettings(true); }} className="absolute top-2 right-2 p-2 text-gray-300 hover:text-indigo-600 rounded-full hover:bg-indigo-50 opacity-0 group-hover:opacity-100 transition-opacity"><Settings size={16} /></button>
          <div className={`relative w-32 h-32 bg-white rounded-2xl shadow-xl border-2 border-indigo-100 flex items-center justify-center transform transition-transform ${isRolling ? 'rotate-180 scale-105' : ''}`}>
            {renderFace(displayResults[0])}
          </div>
          <div className="text-indigo-400 font-bold text-[10px] uppercase mt-6 tracking-widest">{isRolling ? "Rolling..." : `Click to Roll`}</div>
        </div>
      );
    };

    const VoteWidget = ({ widget, updateData }) => {
      const { question = "Class Poll", options = [{ id: 1, text: "Yes", count: 0 }, { id: 2, text: "No", count: 0 }], fontSize = 16 } = widget.data;
      const [isEditing, setIsEditing] = useState(false);

      const vote = (id) => updateData(widget.id, { options: options.map(o => o.id === id ? { ...o, count: o.count + 1 } : o) });
      const totalVotes = options.reduce((acc, o) => acc + o.count, 0) || 1; // avoid /0

      const updateOption = (id, text) => updateData(widget.id, { options: options.map(o => o.id === id ? { ...o, text } : o) });
      const addOption = () => updateData(widget.id, { options: [...options, { id: Date.now(), text: "", count: 0 }] });
      const removeOption = (id) => updateData(widget.id, { options: options.filter(o => o.id !== id) });
      const resetCounts = () => updateData(widget.id, { options: options.map(o => ({ ...o, count: 0 })) });

      if (isEditing) {
        return (
          <div className="h-full bg-white flex flex-col p-4 overflow-hidden">
            <div className="flex justify-between items-center mb-2"><h3 className="font-bold text-sm">Edit Poll</h3><button onClick={() => setIsEditing(false)} className="text-blue-600 font-bold text-xs bg-blue-50 px-2 py-1 rounded">Done</button></div>
            <div className="flex-1 overflow-y-auto custom-scrollbar space-y-2">
              <div className="space-y-1">
                <label className="text-[10px] font-bold uppercase text-gray-400">Question</label>
                <input className="w-full border rounded p-1 text-sm font-bold" value={question} onChange={e => updateData(widget.id, { question: e.target.value })} />
              </div>
              <div className="space-y-1">
                <label className="text-[10px] font-bold uppercase text-gray-400">Options</label>
                {options.map((o, i) => (
                  <div key={o.id} className="flex gap-1 items-center">
                    <input className="flex-1 border rounded p-1 text-sm" value={o.text} onChange={e => updateOption(o.id, e.target.value)} placeholder={`Option ${i + 1}`} />
                    <button onClick={() => removeOption(o.id)} className="text-red-400 hover:text-red-600"><Trash2 size={14} /></button>
                  </div>
                ))}
                <button onClick={addOption} className="text-blue-600 text-xs font-bold hover:underline flex items-center gap-1">+ Add Option</button>
              </div>
            </div>
            <button onClick={resetCounts} className="mt-2 w-full py-2 border border-red-200 text-red-600 rounded text-xs font-bold hover:bg-red-50">Reset Votes</button>
          </div>
        );
      }

      return (
        <div className="h-full bg-white flex flex-col p-4 relative group">
          <button onClick={() => setIsEditing(true)} className="absolute top-2 right-2 p-1 text-gray-300 hover:text-blue-600 rounded hover:bg-blue-50 opacity-0 group-hover:opacity-100 transition-opacity"><Settings size={14} /></button>
          <h3 className="font-bold text-center mb-4 text-gray-800" style={{ fontSize: fontSize + 'px' }}>{question}</h3>
          <div className="flex-1 overflow-y-auto custom-scrollbar space-y-2">
            {options.map(o => {
              const pct = Math.round((o.count / totalVotes) * 100);
              return (
                <div key={o.id} onClick={() => vote(o.id)} className="cursor-pointer group/opt">
                  <div className="flex justify-between text-xs mb-1 font-medium text-gray-600"><span>{o.text || "Option"}</span><span>{o.count} ({options.every(x => x.count === 0) ? 0 : pct}%)</span></div>
                  <div className="h-8 bg-gray-100 rounded-lg overflow-hidden relative">
                    <div className="absolute top-0 left-0 bottom-0 bg-blue-500 transition-all duration-500 ease-out" style={{ width: options.every(x => x.count === 0) ? '0%' : `${pct}%` }} />
                    <div className="absolute inset-0 hover:bg-black/5 transition-colors" />
                  </div>
                </div>
              );
            })}
          </div>
          <div className="mt-2 text-center text-[10px] text-gray-400 uppercase tracking-widest">{options.reduce((a, b) => a + b.count, 0)} Total Votes</div>
        </div>
      );
    };

    // (TrafficLightWidget, QRCodeWidget, SeatPickerWidget are UNCHANGED)
    // I need to skip them in replacement or include them?
    // I will use START/END lines to target just the changed area.
    // The previous file content has TextWidget, DiceWidget.
    // I need to be careful with line numbers.
    // I will replace `// --- CONSTANTS ---` down to `const TrafficLightWidget`.
    // Wait, TrafficLightWidget is AFTER DiceWidget.
    // Order: Text, Dice, Traffic, QR.
    // I will replace from `import ...` to `const TrafficLightWidget`.
    // But I must include `DraggableResizable`, `Timer`, etc.
    // This is too big.
    // I should replace chunks.

    // Chunk 1: Imports
    // Chunk 2: Constants (Backgrounds, Dock Labels)
    // Chunk 3: Widget Sizes
    // Chunk 4: TextWidget
    // Chunk 5: DiceWidget
    // Chunk 6: VoteWidget (New) & renderWidgetContent & addWidget

    // Let's do a multi-replace.



    // --- COMPONENTS ---
    // (DraggableResizable, TimerWidget, RandomizerWidget, GroupMakerWidget, WebcamWidget, TextWidget, DiceWidget, TrafficLightWidget, QRCodeWidget are UNCHANGED)

    const DraggableResizable = ({ id, position, size, zIndex, isSelected, onUpdate, onSelect, onRemove, onFontSizeChange, children }) => {
      const [isDragging, setIsDragging] = useState(false); const [isResizing, setIsResizing] = useState(false); const startMousePos = useRef({ x: 0, y: 0 }); const startWidgetPos = useRef({ x: 0, y: 0 }); const startWidgetSize = useRef({ width: 0, height: 0 }); const onUpdateRef = useRef(onUpdate); const positionRef = useRef(position); const sizeRef = useRef(size); useEffect(() => { onUpdateRef.current = onUpdate; positionRef.current = position; sizeRef.current = size; }, [onUpdate, position, size]);
      const handleMouseDown = (e) => { e.stopPropagation(); onSelect(id); setIsDragging(true); startMousePos.current = { x: e.clientX, y: e.clientY }; startWidgetPos.current = { ...position }; };
      const handleResizeStart = (e) => { e.stopPropagation(); e.preventDefault(); onSelect(id); setIsResizing(true); startMousePos.current = { x: e.clientX, y: e.clientY }; startWidgetPos.current = { ...position }; startWidgetSize.current = { ...size }; };
      useEffect(() => { if (!isDragging && !isResizing) return; const handleMouseMove = (e) => { e.preventDefault(); const dx = e.clientX - startMousePos.current.x; const dy = e.clientY - startMousePos.current.y; if (isDragging) { onUpdateRef.current(id, { x: startWidgetPos.current.x + dx, y: startWidgetPos.current.y + dy }, sizeRef.current); } else if (isResizing) { const newWidth = Math.max(200, startWidgetSize.current.width + dx); const newHeight = Math.max(150, startWidgetSize.current.height + dy); onUpdateRef.current(id, positionRef.current, { width: newWidth, height: newHeight }); } }; const handleMouseUp = () => { setIsDragging(false); setIsResizing(false); }; window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', handleMouseUp); return () => { window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', handleMouseUp); }; }, [isDragging, isResizing, id]);
      return (<div className={`absolute flex flex-col bg-white rounded-xl shadow-xl overflow-hidden border-2 transition-shadow duration-200 ${isSelected ? 'border-blue-500 shadow-2xl' : 'border-transparent border-gray-100'}`} style={{ left: position.x, top: position.y, width: size.width, height: size.height, zIndex: isSelected ? 9999 : (zIndex + 100), touchAction: 'none' }} onMouseDown={() => { if (!isSelected) onSelect(id); }}> <div className="h-8 bg-gray-50 flex items-center justify-between px-2 cursor-move border-b border-gray-100 group select-none flex-shrink-0" onMouseDown={handleMouseDown}> <div className="flex items-center gap-1"> <button onClick={(e) => { e.stopPropagation(); onFontSizeChange?.(-2); }} className="p-1 text-gray-400 hover:text-blue-600 hover:bg-blue-100 rounded transition-colors"><Minus size={14} strokeWidth={3} /></button> <button onClick={(e) => { e.stopPropagation(); onFontSizeChange?.(2); }} className="p-1 text-gray-400 hover:text-blue-600 hover:bg-blue-100 rounded transition-colors"><Plus size={14} strokeWidth={3} /></button> </div> <div className="flex-1 flex justify-center"><div className="w-12 h-1.5 bg-gray-300 rounded-full group-hover:bg-blue-400 transition-colors" /></div> <button onClick={(e) => { e.stopPropagation(); onRemove(id); }} className="p-1 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded transition-colors"> <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> </button> </div> <div className="flex-1 relative overflow-hidden flex flex-col custom-scrollbar">{children}</div> <div className="absolute bottom-0 right-0 w-8 h-8 cursor-nwse-resize flex items-end justify-end p-1 opacity-0 hover:opacity-100 transition-opacity bg-gradient-to-tl from-gray-100 to-transparent z-10" onMouseDown={handleResizeStart}> <Maximize2 size={16} className="text-gray-400 transform rotate-90" /> </div> </div>);
    };
    const TimerWidget = ({ widget, updateData }) => {
      const { durationMinutes = 2, timeLeft = 120, isRunning = false, fontSize = 16, mode = 'digital', color = 'blue', isMuted = false } = widget.data;
      const [customTime, setCustomTime] = useState("");
      const intervalRef = useRef(null);
      const isDraggingRef = useRef(false);
      const timerRef = useRef(null);

      // Colors
      const COLORS = {
        blue: { stroke: '#3b82f6', handle: '#2563eb', bg: 'bg-blue-500' },
        red: { stroke: '#ef4444', handle: '#dc2626', bg: 'bg-red-500' },
        green: { stroke: '#22c55e', handle: '#16a34a', bg: 'bg-green-500' },
        orange: { stroke: '#f97316', handle: '#ea580c', bg: 'bg-orange-500' },
        purple: { stroke: '#a855f7', handle: '#9333ea', bg: 'bg-purple-500' }
      };
      const theme = COLORS[color] || COLORS.blue;

      const playDing = () => {
        if (isMuted) return;
        try {
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.type = 'sine';
          osc.frequency.setValueAtTime(523.25, ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(261.63, ctx.currentTime + 0.4);
          gain.gain.setValueAtTime(0.5, ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);
          osc.start();
          osc.stop(ctx.currentTime + 0.4);
        } catch (e) { }
      };

      useEffect(() => {
        if (isRunning && timeLeft > 0) {
          intervalRef.current = window.setInterval(() => {
            updateData(widget.id, { timeLeft: Math.max(0, timeLeft - 1) });
          }, 1000);
        } else if (timeLeft === 0 && isRunning) {
          updateData(widget.id, { isRunning: false });
          playDing();
        }
        return () => { if (intervalRef.current) clearInterval(intervalRef.current); };
      }, [isRunning, timeLeft, widget.id, updateData]);

      const calculateTimeFromMouseEvent = (e) => {
        if (!timerRef.current) return;
        const rect = timerRef.current.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const x = e.clientX - cx;
        const y = e.clientY - cy;

        let angleRad = Math.atan2(y, x);
        let angle = angleRad + Math.PI / 2;
        if (angle < 0) angle += 2 * Math.PI;

        const totalMins = (angle / (2 * Math.PI)) * 60;
        const newSeconds = Math.max(0, Math.min(3600, Math.round(totalMins) * 60));

        return newSeconds;
      };

      const handleMouseDown = (e) => {
        if (isRunning) return;
        e.stopPropagation();
        e.preventDefault();
        isDraggingRef.current = true;

        const newTime = calculateTimeFromMouseEvent(e);
        if (newTime !== undefined) updateData(widget.id, { timeLeft: newTime });

        const handleGlobalMove = (ev) => {
          if (!isDraggingRef.current) return;
          ev.preventDefault();
          const t = calculateTimeFromMouseEvent(ev);
          if (t !== undefined) updateData(widget.id, { timeLeft: t });
        };

        const handleGlobalUp = () => {
          isDraggingRef.current = false;
          window.removeEventListener('mousemove', handleGlobalMove);
          window.removeEventListener('mouseup', handleGlobalUp);
        };

        window.addEventListener('mousemove', handleGlobalMove);
        window.addEventListener('mouseup', handleGlobalUp);
      };

      const toggleTimer = () => updateData(widget.id, { isRunning: !isRunning });
      const resetTimer = () => updateData(widget.id, { isRunning: false, timeLeft: 120 });
      const adjustTime = (delta) => updateData(widget.id, { timeLeft: Math.max(0, timeLeft + delta) });
      const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;

      const progress = timeLeft / 3600;
      const circum = 2 * Math.PI * 45; // Based on r=45?
      // Wait, we want the handle to be in the MIDDLE of the stroke.
      // Stroke width = 45.
      // Stroke is centered at r=22.5? 
      // Circle r="22.5" stroke-width="45".
      // Inner radius = 0. Outer radius = 45.
      // So visual timer fills the whole circle.
      // The handle should be at r=22.5 to be in the middle of the "pie slice"?
      // Or at r=40 near the edge?
      // User said "lines up with the edge of the blue area".
      // If the blue area ends at r=45 (outer edge), and the handle is at r=45, it matches the outer edge.
      // If the user meant the flat "leading edge" of the time sector...
      // The handle IS at the leading edge.
      // But maybe the handle needs to be slightly inward to look good?
      // Let's try r=35.

      const angle = progress * 2 * Math.PI;
      // Handle Position
      const handleR = 38; // Slightly inside outer edge (45)
      const handleX = 50 + handleR * Math.cos(angle);
      const handleY = 50 + handleR * Math.sin(angle);

      return (
        <div className="flex flex-col items-center justify-between h-full p-2 relative bg-white select-none group">
          <div className="absolute top-2 left-2 flex gap-1 z-20 opacity-0 group-hover:opacity-100 transition-opacity">
            {Object.keys(COLORS).map(c => (
              <button key={c} onClick={() => updateData(widget.id, { color: c })} className={`w-3 h-3 rounded-full ${COLORS[c].bg} ${color === c ? 'ring-2 ring-slate-400' : ''}`} />
            ))}
          </div>
          <button onClick={() => updateData(widget.id, { mode: mode === 'digital' ? 'visual' : 'digital' })} className="absolute top-2 right-2 p-1.5 text-gray-300 hover:text-blue-600 rounded-full hover:bg-blue-50 opacity-0 group-hover:opacity-100 transition-opacity z-20" title="Switch Mode"><Clock size={16} /></button>

          <div className="flex-1 w-full flex items-center justify-center p-2 min-h-0">
            {mode === 'visual' ? (
              <div className="relative w-full h-full max-h-[90%] aspect-square flex items-center justify-center">
                <svg ref={timerRef} className="transform -rotate-90 w-full h-full overflow-visible" viewBox="0 0 100 100" onMouseDown={handleMouseDown} style={{ cursor: isRunning ? 'default' : 'grab' }}>
                  {/* Track */}
                  <circle cx="50" cy="50" r="45" stroke="#f3f4f6" strokeWidth="10" fill="white" />

                  {/* colored slice - r=22.5, width=45 covers 0-45 radius (full pie) */}
                  {timeLeft > 0 && (
                    <circle cx="50" cy="50" r="22.5" stroke={theme.stroke} strokeWidth="45" fill="none"
                      strokeDasharray={`${2 * Math.PI * 22.5} ${2 * Math.PI * 22.5}`}
                      strokeDashoffset={2 * Math.PI * 22.5 * (1 - progress)}
                      className="transition-all duration-75 ease-linear pointer-events-none"
                    />
                  )}

                  {/* Border */}
                  <circle cx="50" cy="50" r="45" stroke="#e5e7eb" strokeWidth="1" fill="none" pointerEvents="none" />

                  {/* Handle */}
                  {!isRunning && (
                    <g transform={`translate(${handleX}, ${handleY})`}>
                      <circle r="5" fill="white" stroke={theme.handle} strokeWidth="2" className="shadow-sm cursor-grab active:cursor-grabbing" />
                    </g>
                  )}
                </svg>
                <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                  <span className="font-bold text-2xl text-slate-700 bg-white/80 px-2 rounded-lg backdrop-blur-sm shadow-sm">{formatTime(timeLeft)}</span>
                </div>
              </div>
            ) : (
              <div className="flex flex-col items-center">
                <div className={`text-6xl font-black text-slate-800 tracking-widest mb-4 font-sans`}>{formatTime(timeLeft)}</div>
                {!isRunning && (
                  <div className="flex flex-col items-center gap-2">
                    <div className="flex gap-4">
                      {/* Removed -30/+30 buttons */}
                    </div>
                    <div className="flex gap-2 items-center mt-2">
                      <input
                        type="text"
                        placeholder="00:00"
                        className="w-20 text-center border rounded p-1 text-sm font-bold text-gray-600"
                        value={customTime}
                        onChange={(e) => setCustomTime(e.target.value)}
                        onKeyDown={(e) => {
                          if (e.key === 'Enter') {
                            const parts = customTime.split(':').map(Number);
                            let seconds = 0;
                            if (parts.length === 2) seconds = parts[0] * 60 + parts[1];
                            else if (parts.length === 1) seconds = parts[0] * 60; // Assume minutes if just one number? Or seconds? User said "amount of time". Assume minutes for single number is standard teacher timer behavior, or seconds? Let's assume minutes if < 100, else seconds? Let's check logic. Actually, standard is usually minutes. Let's do M:S support.
                            // Improved parsing
                            if (parts.length === 1 && !isNaN(parts[0])) seconds = parts[0] * 60;

                            if (seconds > 0) {
                              updateData(widget.id, { timeLeft: seconds });
                              setCustomTime("");
                            }
                          }
                        }}
                      />
                      <button onClick={() => {
                        const parts = customTime.split(':').map(Number);
                        let seconds = 0;
                        if (parts.length === 2) seconds = parts[0] * 60 + parts[1];
                        else if (parts.length === 1 && !isNaN(parts[0])) seconds = parts[0] * 60;
                        if (seconds > 0) {
                          updateData(widget.id, { timeLeft: seconds });
                          setCustomTime("");
                        }
                      }} className="bg-slate-200 hover:bg-slate-300 text-slate-600 px-2 py-1 rounded text-xs font-bold">Set</button>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>

          <div className="flex gap-4 items-center z-10 py-2">
            <button onClick={() => updateData(widget.id, { isMuted: !isMuted })} className={`p-2 rounded-full transition-colors ${isMuted ? 'text-red-400 bg-red-50' : 'text-slate-400 hover:bg-slate-100 hover:text-slate-600'}`} title={isMuted ? "Unmute" : "Mute"}>
              {isMuted ? <VolumeX size={18} /> : <Volume2 size={18} />}
            </button>
            <button onClick={toggleTimer} className={`p-4 rounded-full text-white shadow-lg transition-transform active:scale-95 flex items-center justify-center ${isRunning ? 'bg-orange-500 hover:bg-orange-600' : 'bg-green-500 hover:bg-green-600'}`}>
              {isRunning ? <Pause size={24} fill="currentColor" /> : <Play size={24} fill="currentColor" className="ml-1" />}
            </button>
            <button onClick={resetTimer} className="p-3 hover:bg-slate-100 rounded-full text-slate-500 transition-colors" title="Reset"><RotateCcw size={20} /></button>
          </div>
        </div>
      );
    };

    const RandomizerWidget = ({ widget, updateData, roster }) => {
      const { currentName, isAnimating, fontSize = 16 } = widget.data;
      const steps = useRef(0);
      const intervalRef = useRef(null);
      const activeStudents = roster.filter(s => s.active);

      useEffect(() => {
        if (isAnimating) {
          if (activeStudents.length === 0) { updateData(widget.id, { isAnimating: false }); return; }
          intervalRef.current = window.setInterval(() => {
            const randomName = activeStudents[Math.floor(Math.random() * activeStudents.length)].name;
            updateData(widget.id, { currentName: randomName });
            steps.current++;
            if (steps.current >= 20) {
              if (intervalRef.current) clearInterval(intervalRef.current);
              updateData(widget.id, { isAnimating: false });
              steps.current = 0;
            }
          }, 100);
        }
        return () => { if (intervalRef.current) clearInterval(intervalRef.current); };
      }, [isAnimating, widget.id, activeStudents, updateData]);

      const scaledFS = (fontSize / 16) * 30;

      return (
        <div className="flex flex-col items-center justify-center h-full p-4 bg-indigo-50 relative group">
          <div className="flex-1 flex items-center justify-center w-full">
            <h2 className="font-bold text-center break-words text-indigo-900 leading-tight" style={{ fontSize: scaledFS + 'px' }}>{currentName || <span className="text-indigo-200">?</span>}</h2>
          </div>
          <button onClick={() => { steps.current = 0; updateData(widget.id, { isAnimating: true }); }} disabled={isAnimating || activeStudents.length === 0} className="bg-indigo-600 text-white px-8 py-3 rounded-full flex gap-2 items-center font-bold shadow-lg transition-all active:scale-95">
            <Shuffle size={18} /> Pick Random
          </button>
          {activeStudents.length === 0 && <div className="absolute bottom-16 text-xs text-red-500 font-bold">No active students in roster!</div>}
        </div>
      );
    };

    const GroupMakerWidget = ({ widget, updateData, roster }) => {
      const { groups = [], fontSize = 16, groupCount = 4 } = widget.data;

      const activeStudents = roster.filter(s => s.active);
      const count = activeStudents.length;
      const scaledFS = (fontSize / 16) * 14;

      const createGroups = (countNeeded) => {
        const shuffled = [...activeStudents].sort(() => Math.random() - 0.5);
        const newG = Array.from({ length: countNeeded }, () => []);
        shuffled.forEach((s, i) => newG[i % countNeeded].push(s));
        updateData(widget.id, { groups: newG, groupCount: countNeeded });
      };

      return (
        <div className="flex flex-col h-full bg-gray-50 relative p-4">
          <div className="flex flex-col gap-2 flex-1 min-h-0">
            <div className="flex justify-between items-center mb-1 shrink-0">
              <div className="bg-white border border-gray-200 px-2 py-0.5 rounded-md shadow-sm">
                <span className="text-[10px] uppercase font-bold text-gray-400 tracking-wider">Present: </span>
                <span className="text-xs font-bold text-blue-600">{count}</span>
              </div>
            </div>

            <div className="grid grid-cols-4 gap-2 overflow-y-auto content-start custom-scrollbar flex-1">
              {groups.length > 0 ? groups.map((g, i) => (
                <div key={i} className="bg-white p-2 rounded-xl shadow-sm border border-gray-100 min-h-[80px] flex flex-col">
                  <div className="font-bold text-[10px] uppercase text-gray-400 mb-1 tracking-wider">Group {i + 1}</div>
                  <div className="flex-1 space-y-0.5">
                    {g.map(s => (
                      <div key={s.id} className="px-1.5 py-0.5 bg-gray-50 rounded flex items-center text-gray-700 font-medium truncate" style={{ fontSize: scaledFS + 'px' }}>{s.name}</div>
                    ))}
                  </div>
                </div>
              )) : <div className="col-span-4 flex items-center justify-center text-gray-400 italic">No groups created</div>}
            </div>

            <div className="bg-white p-2 rounded-xl border border-gray-200 shadow-sm mt-auto shrink-0">
              <div className="flex justify-between items-center mb-1">
                <span className="text-xs font-bold text-slate-600">Groups: {groupCount}</span>
                <span className="text-[10px] text-slate-400">~{Math.ceil(count / groupCount)} students/group</span>
              </div>
              <input
                type="range" min="2" max="12" value={groupCount}
                onChange={e => {
                  const c = Number(e.target.value);
                  updateData(widget.id, { groupCount: c });
                  createGroups(c);
                }}
                className="w-full accent-blue-600 h-2 bg-slate-100 rounded-lg appearance-none cursor-pointer mb-2"
              />
              <button onClick={() => createGroups(groupCount)} className="w-full py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold rounded-lg transition-colors">
                Shuffle Groups
              </button>
            </div>
          </div>
        </div>
      );
    };
    const WebcamWidget = ({ widget, updateData }) => {
      const { isMirrored = true, isActive = true } = widget.data; const videoRef = useRef(null); const streamRef = useRef(null);
      const takePhoto = () => {
        if (videoRef.current) {
          const canvas = document.createElement('canvas');
          canvas.width = videoRef.current.videoWidth;
          canvas.height = videoRef.current.videoHeight;
          const ctx = canvas.getContext('2d');
          if (isMirrored) {
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
          }
          ctx.drawImage(videoRef.current, 0, 0);
          const link = document.createElement('a');
          link.download = `photo-${Date.now()}.png`;
          link.href = canvas.toDataURL('image/png');
          link.click();
        }
      };
      useEffect(() => { const startCamera = async () => { if (isActive) { try { const stream = await navigator.mediaDevices.getUserMedia({ video: true }); streamRef.current = stream; if (videoRef.current) { videoRef.current.srcObject = stream; } } catch (e) { updateData(widget.id, { isActive: false }); } } else { stopCamera(); } }; startCamera(); return () => { stopCamera(); }; }, [isActive]); const stopCamera = () => { if (streamRef.current) { streamRef.current.getTracks().forEach(track => track.stop()); streamRef.current = null; } if (videoRef.current) { videoRef.current.srcObject = null; } }; return <div className="w-full h-full bg-black relative flex flex-col group overflow-hidden"><div className="flex-1 relative bg-gray-900 flex items-center justify-center">{isActive ? <video ref={videoRef} autoPlay playsInline muted className={`w-full h-full object-cover pointer-events-none ${isMirrored ? 'scale-x-[-1]' : ''}`} /> : <div className="text-white/50 text-center flex flex-col items-center"><CameraOff size={48} className="mb-2 opacity-50" /><span className="text-sm font-medium">Camera Off</span></div>}</div><div className="absolute bottom-4 left-0 right-0 flex justify-center gap-3 opacity-0 group-hover:opacity-100 transition-opacity bg-gradient-to-t from-black/50 to-transparent pb-4 pt-8"><button onClick={() => updateData(widget.id, { isActive: !isActive })} className="p-3 bg-white/20 backdrop-blur-md hover:bg-white/30 rounded-full text-white">{isActive ? <CameraOff size={20} /> : <Camera size={20} />}</button><button onClick={takePhoto} className="p-3 bg-white/20 backdrop-blur-md hover:bg-white/30 rounded-full text-white"><Camera size={20} /></button>{isActive && (<button onClick={() => updateData(widget.id, { isMirrored: !isMirrored })} className="p-3 bg-white/20 backdrop-blur-md hover:bg-white/30 rounded-full text-white"><FlipHorizontal size={20} /></button>)}</div></div>;
    };




    // Draw tool emojis/stickers
    const DRAW_EMOJIS = ['â­', 'â¤ï¸', 'âœ…', 'âŒ', 'ðŸ‘', 'ðŸ‘Ž', 'ðŸŽ¯', 'ðŸ†', 'ðŸ”¥', 'ðŸ’¡', 'ðŸ“Œ', 'ðŸŽ¨', 'ðŸ“', 'ðŸŒŸ', 'âœ¨', 'ðŸŽ‰', 'ðŸ’¯', 'ðŸ‘€', 'ðŸ¤”', 'ðŸ’ª', 'ðŸŒˆ', 'âš¡', 'ðŸŽ', 'ðŸ˜Š', 'ðŸ™Œ'];

    const WhiteboardWidget = ({ widget, updateData }) => {
      const { lines = [], color = '#000000', size = 5, tool = 'pen', textItems = [], emojiItems = [] } = widget.data;
      const canvasRef = useRef(null);
      const isDrawing = useRef(false);
      const lastPos = useRef({ x: 0, y: 0 });
      const [showEmojiPicker, setShowEmojiPicker] = useState(false);
      const [editingTextId, setEditingTextId] = useState(null);
      useEffect(() => {
        const cvs = canvasRef.current;
        if (!cvs) return;
        const ctx = cvs.getContext('2d');
        const rect = cvs.getBoundingClientRect();

        cvs.width = rect.width;
        cvs.height = rect.height;

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.clearRect(0, 0, cvs.width, cvs.height);

        lines.forEach(line => {
          ctx.beginPath();
          ctx.strokeStyle = line.tool === 'eraser' ? '#ffffff' : line.color;
          ctx.lineWidth = line.size;
          ctx.moveTo(line.points[0].x * rect.width, line.points[0].y * rect.height);
          for (let i = 1; i < line.points.length; i++) {
            ctx.lineTo(line.points[i].x * rect.width, line.points[i].y * rect.height);
          }
          ctx.stroke();
        });
      }, [lines, widget.size, widget.id]);

      const getPos = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        return { x: (e.clientX - rect.left) / rect.width, y: (e.clientY - rect.top) / rect.height };
      };

      const start = (e) => {
        if (tool === 'text') {
          // Add new text box at click position
          e.stopPropagation();
          const rect = canvasRef.current.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width;
          const y = (e.clientY - rect.top) / rect.height;
          const newTextItem = { id: Date.now(), x, y, text: 'Text', color };
          updateData(widget.id, { textItems: [...textItems, newTextItem] });
          setEditingTextId(newTextItem.id);
          return;
        }
        if (tool === 'emoji') {
          setShowEmojiPicker(!showEmojiPicker);
          return;
        }
        e.stopPropagation();
        isDrawing.current = true;
        const pos = getPos(e);
        lastPos.current = pos;
        const newLine = { points: [pos], color, size, tool };
        updateData(widget.id, { lines: [...lines, newLine] });
      };

      const move = (e) => {
        if (!isDrawing.current) return;
        e.stopPropagation();
        e.preventDefault();
        const pos = getPos(e);
        const newLines = [...lines];
        const currentLine = { ...newLines[newLines.length - 1] };
        currentLine.points = [...currentLine.points, pos];
        newLines[newLines.length - 1] = currentLine;
        updateData(widget.id, { lines: newLines });
        lastPos.current = pos;
      };

      const end = () => { isDrawing.current = false; };

      const addEmoji = (emoji, e) => {
        e.stopPropagation();
        const rect = canvasRef.current.getBoundingClientRect();
        // Place emoji in center of canvas
        const newEmojiItem = { id: Date.now(), x: 0.5, y: 0.5, emoji };
        updateData(widget.id, { emojiItems: [...emojiItems, newEmojiItem] });
        setShowEmojiPicker(false);
        updateData(widget.id, { tool: 'pen' }); // Switch back to pen
      };

      const updateTextItem = (id, text) => {
        updateData(widget.id, { textItems: textItems.map(t => t.id === id ? { ...t, text } : t) });
      };

      const deleteTextItem = (id) => {
        updateData(widget.id, { textItems: textItems.filter(t => t.id !== id) });
        setEditingTextId(null);
      };

      const deleteEmojiItem = (id) => {
        updateData(widget.id, { emojiItems: emojiItems.filter(e => e.id !== id) });
      };

      const savePNG = () => {
        const cvs = canvasRef.current;
        if (!cvs) return;

        // Create a temporary canvas with all elements
        const tempCanvas = document.createElement('canvas');
        const rect = cvs.getBoundingClientRect();
        tempCanvas.width = rect.width;
        tempCanvas.height = rect.height;
        const tempCtx = tempCanvas.getContext('2d');

        // Fill white background
        tempCtx.fillStyle = 'white';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

        // Draw lines
        lines.forEach(line => {
          tempCtx.beginPath();
          tempCtx.strokeStyle = line.tool === 'eraser' ? '#ffffff' : line.color;
          tempCtx.lineWidth = line.size;
          tempCtx.lineCap = 'round';
          tempCtx.lineJoin = 'round';
          tempCtx.moveTo(line.points[0].x * rect.width, line.points[0].y * rect.height);
          for (let i = 1; i < line.points.length; i++) {
            tempCtx.lineTo(line.points[i].x * rect.width, line.points[i].y * rect.height);
          }
          tempCtx.stroke();
        });

        // Draw text items
        textItems.forEach(t => {
          tempCtx.font = 'bold 16px sans-serif';
          tempCtx.fillStyle = t.color;
          tempCtx.fillText(t.text, t.x * rect.width, t.y * rect.height);
        });

        // Draw emoji items
        tempCtx.font = '32px serif';
        emojiItems.forEach(e => {
          tempCtx.fillText(e.emoji, e.x * rect.width - 16, e.y * rect.height + 12);
        });

        // Download
        const link = document.createElement('a');
        link.download = `drawing-${Date.now()}.png`;
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
      };

      const clearAll = () => {
        updateData(widget.id, { lines: [], textItems: [], emojiItems: [] });
      };

      return (
        <div className="h-full bg-white flex flex-col relative">
          <div className="bg-gray-100 p-2 border-b flex items-center justify-between shrink-0">
            <div className="flex gap-1 items-center">
              <input type="color" value={color} onChange={e => updateData(widget.id, { color: e.target.value, tool: 'pen' })} className="w-6 h-6 rounded cursor-pointer border-none" />
              <button onClick={() => updateData(widget.id, { tool: 'pen' })} className={`p-1.5 rounded ${tool === 'pen' ? 'bg-blue-200 text-blue-800' : 'hover:bg-gray-200'}`} title="Pen"><Edit3 size={16} /></button>
              <button onClick={() => updateData(widget.id, { tool: 'eraser' })} className={`p-1.5 rounded ${tool === 'eraser' ? 'bg-blue-200 text-blue-800' : 'hover:bg-gray-200'}`} title="Eraser"><div className="w-4 h-4 bg-white border border-gray-400 rounded-sm" /></button>
              <button onClick={() => updateData(widget.id, { tool: 'text' })} className={`p-1.5 rounded ${tool === 'text' ? 'bg-blue-200 text-blue-800' : 'hover:bg-gray-200'}`} title="Add Text"><Type size={16} /></button>
              <div className="relative">
                <button onClick={() => setShowEmojiPicker(!showEmojiPicker)} className={`p-1.5 rounded ${tool === 'emoji' ? 'bg-blue-200 text-blue-800' : 'hover:bg-gray-200'}`} title="Add Sticker">ðŸ˜Š</button>
                {showEmojiPicker && (
                  <div className="absolute left-0 top-full mt-1 z-50 bg-white rounded-xl shadow-xl border border-gray-200 p-2 w-48 max-h-40 overflow-y-auto custom-scrollbar" onClick={(e) => e.stopPropagation()}>
                    <div className="grid grid-cols-5 gap-1">
                      {DRAW_EMOJIS.map((emoji, i) => (
                        <button key={i} onClick={(e) => addEmoji(emoji, e)} className="text-xl p-1 rounded hover:bg-blue-100 transition-colors">
                          {emoji}
                        </button>
                      ))}
                    </div>
                  </div>
                )}
              </div>
              <input type="range" min="2" max="20" value={size} onChange={e => updateData(widget.id, { size: Number(e.target.value) })} className="w-16" />
            </div>
            <div className="flex gap-1">
              <button onClick={savePNG} className="text-green-600 hover:bg-green-50 p-1.5 rounded font-bold text-xs flex items-center gap-1" title="Save as PNG"><Download size={14} /> Save</button>
              <button onClick={clearAll} className="text-red-500 hover:bg-red-50 p-1.5 rounded font-bold text-xs">Clear</button>
            </div>
          </div>
          <div className="flex-1 relative overflow-hidden">
            <canvas
              ref={canvasRef}
              className="absolute inset-0 w-full h-full touch-none cursor-crosshair"
              onMouseDown={start}
              onMouseMove={move}
              onMouseUp={end}
              onMouseLeave={end}
            />
            {/* Text overlays */}
            {textItems.map(t => (
              <div
                key={t.id}
                className="absolute cursor-move group"
                style={{ left: `${t.x * 100}%`, top: `${t.y * 100}%`, transform: 'translate(-50%, -50%)' }}
              >
                {editingTextId === t.id ? (
                  <input
                    type="text"
                    value={t.text}
                    onChange={(e) => updateTextItem(t.id, e.target.value)}
                    onBlur={() => setEditingTextId(null)}
                    onKeyDown={(e) => e.key === 'Enter' && setEditingTextId(null)}
                    autoFocus
                    className="border-2 border-blue-500 rounded px-1 py-0.5 font-bold outline-none min-w-[60px]"
                    style={{ color: t.color }}
                  />
                ) : (
                  <div
                    onClick={() => setEditingTextId(t.id)}
                    className="font-bold text-base px-1 py-0.5 rounded hover:bg-blue-50 border border-transparent hover:border-blue-300"
                    style={{ color: t.color }}
                  >
                    {t.text}
                    <button
                      onClick={(e) => { e.stopPropagation(); deleteTextItem(t.id); }}
                      className="absolute -top-2 -right-2 w-4 h-4 bg-red-500 text-white rounded-full text-[10px] flex items-center justify-center opacity-0 group-hover:opacity-100"
                    >Ã—</button>
                  </div>
                )}
              </div>
            ))}
            {/* Emoji overlays */}
            {emojiItems.map(e => (
              <div
                key={e.id}
                className="absolute cursor-move group text-2xl"
                style={{ left: `${e.x * 100}%`, top: `${e.y * 100}%`, transform: 'translate(-50%, -50%)' }}
              >
                {e.emoji}
                <button
                  onClick={() => deleteEmojiItem(e.id)}
                  className="absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white rounded-full text-[10px] flex items-center justify-center opacity-0 group-hover:opacity-100"
                >Ã—</button>
              </div>
            ))}
          </div>
        </div>
      );
    };


    const TrafficLightWidget = ({ widget, updateData }) => { const { activeLight = null, fontSize = 16 } = widget.data; const size = (fontSize / 16) * 60; return <div className="h-full bg-gray-800 flex flex-col items-center justify-center gap-4 p-4 rounded-xl border-4 border-gray-900 shadow-2xl">{['red', 'yellow', 'green'].map(color => (<button key={color} onClick={() => updateData(widget.id, { activeLight: activeLight === color ? null : color })} className={`rounded-full transition-all duration-300 shadow-inner ${activeLight === color ? (color === 'red' ? 'bg-red-500 shadow-[0_0_30px_rgba(239,68,68,0.6)]' : color === 'yellow' ? 'bg-yellow-400 shadow-[0_0_30px_rgba(250,204,21,0.6)]' : 'bg-green-500 shadow-[0_0_30px_rgba(34,197,94,0.6)]') + ' scale-110 ring-4 ring-white/10' : (color === 'red' ? 'bg-red-900/30' : color === 'yellow' ? 'bg-yellow-900/30' : 'bg-green-900/30') + ' opacity-40 scale-95 hover:opacity-100'}`} style={{ width: size, height: size }} />))}</div>; };
    const QRCodeWidget = ({ widget, updateData }) => { const { url = "", fontSize = 16 } = widget.data; const [input, setInput] = useState(url); const [showInput, setShowInput] = useState(!url); const applyUrl = () => { updateData(widget.id, { url: input }); setShowInput(false); }; return <div className="h-full bg-white flex flex-col p-4"> {showInput ? (<div className="flex flex-col gap-2 h-full justify-center"> <label className="font-bold text-gray-700 text-xs">QR Link URL</label> <input className="border p-2 rounded text-sm mb-2" value={input} onChange={e => setInput(e.target.value)} placeholder="https://..." /> <button onClick={applyUrl} className="bg-blue-600 text-white p-2 rounded text-sm font-bold">Generate QR</button> {url && <button onClick={() => setShowInput(false)} className="text-gray-400 text-xs text-center mt-2 hover:text-gray-600">Cancel</button>} </div>) : (<div className="flex-1 flex items-center justify-center relative flex-col gap-2"> <button onClick={() => setShowInput(true)} className="absolute top-0 right-0 p-1 text-gray-400 hover:text-blue-600 rounded-full hover:bg-gray-50"><Settings size={16} /></button> {url ? (<img src={`https://api.qrserver.com/v1/create-qr-code/?size=250x250&data=${encodeURIComponent(url)}`} alt="QR Code" className="max-w-full max-h-[85%] object-contain mix-blend-multiply" />) : <div className="text-gray-400 text-sm">No URL</div>} <div className="text-[10px] text-gray-400 truncate max-w-full px-2" title={url}>{url}</div> </div>)} </div>; };
    const SeatPickerWidget = ({ widget, updateData, roster }) => {
      const { desks = [], isEditing = false, fontSize = 16 } = widget.data;
      const containerRef = useRef(null);
      const [draggedDesk, setDraggedDesk] = useState(null);
      const [rotatingDesk, setRotatingDesk] = useState(null);
      const dragStart = useRef({ x: 0, y: 0 });

      // Sync with Global Roster
      // We only run this when roster changes or desks is empty to avoid re-shuffling constantly
      useEffect(() => {
        // Filter for active students
        const activeStudents = roster.filter(s => s.active).map(s => s.name);

        let currentDesks = Array.isArray(desks) ? [...desks] : [];
        let needsUpdate = false;

        // 1. Remove students who are no longer active/present from desks
        currentDesks = currentDesks.map(d => {
          if (d.type === 'teacher') return d;
          if (d.student && !activeStudents.includes(d.student)) {
            needsUpdate = true;
            return { ...d, student: null };
          }
          return d;
        });

        // 2. Assign unseated active students
        const seated = currentDesks.map(d => d.student).filter(Boolean);
        const unseated = activeStudents.filter(name => !seated.includes(name));

        if (unseated.length > 0) {
          needsUpdate = true;
          // Fill empty desks first
          currentDesks = currentDesks.map(d => {
            if (d.type !== 'teacher' && !d.student && unseated.length > 0) {
              return { ...d, student: unseated.shift() };
            }
            return d;
          });
          // Create new desks for remaining
          unseated.forEach((s, i) => {
            currentDesks.push({
              id: Date.now() + Math.random(),
              x: 50 + (i % 5) * 110,
              y: 50 + Math.floor(i / 5) * 80 + 100,
              student: s,
              color: 'blue',
              type: 'student',
              rotation: 0
            });
          });
        }

        if (needsUpdate) {
          updateData(widget.id, { desks: currentDesks });
        }
      }, [roster, widget.id]); // Removed updateData from dependency to avoid loop if careful, but mostly roster triggers it.

      const handleMouseDown = (e, deskId) => {
        if (!isEditing) return;
        e.stopPropagation();
        setDraggedDesk(deskId);
        dragStart.current = { x: e.clientX, y: e.clientY };
      };

      const handleRotateMouseDown = (e, deskId) => {
        if (!isEditing) return;
        e.stopPropagation();
        setRotatingDesk(deskId);
      };

      const handleGlobalMouseMove = (e) => {
        if (draggedDesk && isEditing) {
          e.stopPropagation();
          e.preventDefault();
          const dx = e.clientX - dragStart.current.x;
          const dy = e.clientY - dragStart.current.y;
          dragStart.current = { x: e.clientX, y: e.clientY };
          updateData(widget.id, {
            desks: desks.map(d => {
              if (d.id === draggedDesk) return { ...d, x: d.x + dx, y: d.y + dy };
              return d;
            })
          });
        } else if (rotatingDesk && isEditing) {
          e.preventDefault();
          const desk = desks.find(d => d.id === rotatingDesk);
          if (desk && containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            const deskCenterX = rect.left + desk.x + (desk.type === 'teacher' ? 80 : 56);
            const deskCenterY = rect.top + desk.y + (desk.type === 'teacher' ? 40 : 32);
            const angle = Math.atan2(e.clientY - deskCenterY, e.clientX - deskCenterX) * (180 / Math.PI);
            updateData(widget.id, {
              desks: desks.map(d => {
                if (d.id === rotatingDesk) return { ...d, rotation: angle + 45 };
                return d;
              })
            });
          }
        }
      };

      const handleGlobalMouseUp = () => {
        setDraggedDesk(null);
        setRotatingDesk(null);
      };

      useEffect(() => {
        if (isEditing) {
          window.addEventListener('mousemove', handleGlobalMouseMove);
          window.addEventListener('mouseup', handleGlobalMouseUp);
          return () => {
            window.removeEventListener('mousemove', handleGlobalMouseMove);
            window.removeEventListener('mouseup', handleGlobalMouseUp);
          };
        }
      }, [isEditing, draggedDesk, rotatingDesk, desks]);

      const addDesk = (color = 'blue', type = 'student') => {
        const newDesk = { id: Date.now().toString(), x: 50, y: 50, student: null, color, type, rotation: 0 };
        updateData(widget.id, { desks: [...desks, newDesk] });
      };

      const removeDesk = (id) => updateData(widget.id, { desks: desks.filter(d => d.id !== id) });

      const shuffleSeats = () => {
        const activeStudentNames = roster.filter(s => s.active).map(s => s.name);
        if (activeStudentNames.length === 0) {
          alert("No active students in roster!");
          return;
        }
        const shuffled = [...activeStudentNames].sort(() => Math.random() - 0.5);
        let studentIdx = 0;
        const newDesks = desks.map((desk) => {
          if (desk.type === 'teacher') return desk;
          const student = shuffled[studentIdx] || null;
          studentIdx++;
          return { ...desk, student };
        });
        updateData(widget.id, { desks: newDesks });
      };

      return (
        <div className="flex flex-col h-full bg-slate-50 relative overflow-hidden">
          <div className="h-12 bg-white border-b flex items-center justify-between px-4 z-10 shrink-0">
            <h3 className="font-bold text-slate-700 flex items-center gap-2"><Layout size={18} /> Class Layout</h3>
            <div className="flex gap-2">
              {isEditing ? (
                <>
                  <div className="flex bg-gray-100 rounded-lg p-0.5 mr-2">
                    {['blue', 'red', 'green', 'yellow'].map(c => (<button key={c} onClick={() => addDesk(c)} className={`w-6 h-6 rounded border m-0.5 hover:scale-110 transition-transform ${DESK_COLORS[c].split(' ')[0]} ${DESK_COLORS[c].split(' ')[1]}`} />))}
                    <button onClick={() => addDesk('gray', 'teacher')} className="px-2 h-6 rounded bg-slate-600 text-[10px] m-0.5 text-white font-bold flex items-center gap-1 hover:scale-105 transition-transform"><Briefcase size={10} /> Teacher</button>
                  </div>
                  <button onClick={() => updateData(widget.id, { isEditing: false })} className="px-3 py-1 bg-green-600 text-white rounded text-xs font-bold shadow hover:bg-green-700">Done</button>
                </>
              ) : (
                <>
                  <button onClick={shuffleSeats} className="px-3 py-1 bg-indigo-600 text-white rounded text-xs font-bold shadow hover:bg-indigo-700 flex items-center gap-1"><Shuffle size={12} /> Shuffle</button>
                  <button onClick={() => updateData(widget.id, { isEditing: true })} className="px-3 py-1 bg-white border border-gray-300 text-gray-600 rounded text-xs font-bold hover:bg-gray-50 flex items-center gap-1"><Edit3 size={12} /> Edit</button>
                </>
              )}
            </div>
          </div>
          <div ref={containerRef} className={`flex-1 relative overflow-hidden ${isEditing ? 'bg-slate-100' : 'bg-slate-50'}`} style={{ backgroundImage: isEditing ? 'radial-gradient(#cbd5e1 1px, transparent 1px)' : 'none', backgroundSize: '20px 20px' }}>
            {desks.map(desk => {
              const styleClass = desk.type === 'teacher' ? 'bg-slate-800 border-slate-600 text-white shadow-lg w-40 h-20 rounded-md' : `${DESK_COLORS[desk.color || 'blue']} w-28 h-16 rounded-lg`;
              return (
                <div key={desk.id} className={`absolute shadow-sm border-2 flex items-center justify-center transition-shadow ${isEditing ? 'cursor-move hover:shadow-md' : ''} ${styleClass}`} style={{ left: desk.x, top: desk.y, transform: `rotate(${desk.rotation || 0}deg)` }} onMouseDown={(e) => handleMouseDown(e, desk.id)} >
                  {isEditing && (
                    <>
                      <button onClick={(e) => { e.stopPropagation(); removeDesk(desk.id); }} className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-0.5 shadow-sm hover:bg-red-600 w-5 h-5 flex items-center justify-center z-20"><X size={12} strokeWidth={3} /></button>
                      <div onMouseDown={(e) => handleRotateMouseDown(e, desk.id)} className="absolute -top-3 -left-3 bg-blue-500 text-white rounded-full p-1 shadow-sm hover:bg-blue-600 w-6 h-6 flex items-center justify-center z-20 cursor-grab active:cursor-grabbing"><RotateCw size={14} strokeWidth={2.5} /></div>
                    </>
                  )}
                  {desk.type === 'teacher' ? <div className="flex flex-col items-center opacity-80"><Briefcase size={20} className="mb-1" /><span className="text-[10px] uppercase font-bold tracking-widest">Teacher</span></div> : (desk.student ? <span className="font-bold text-slate-800 text-center px-1 truncate w-full" style={{ fontSize: (fontSize || 14) + 'px' }}>{desk.student}</span> : <span className={`italic text-xs ${desk.color === 'yellow' ? 'text-yellow-700/50' : 'text-slate-300'}`}>Empty</span>)}
                  {desk.type !== 'teacher' && <div className={`absolute -bottom-1 w-12 h-1 rounded-full ${desk.color === 'yellow' ? 'bg-yellow-200' : 'bg-slate-200'}`} />}
                </div>
              );
            })}
          </div>
        </div>
      );
    };

    // --- Background Picker Modal (Updated) ---
    const BackgroundPicker = ({ currentBg, onSelect, onClose }) => {
      const fileInputRef = useRef(null);

      // Local state for the selected text color in case we are uploading
      const [selectedTextColor, setSelectedTextColor] = useState(currentBg.textColor || 'text-slate-800');

      const handleFileChange = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          // Default custom uploads to white text unless changed (logic could be refined)
          reader.onloadend = () => {
            onSelect({ id: 'custom', name: 'Custom Upload', type: 'custom', src: reader.result, textColor: selectedTextColor });
            onClose();
          };
          reader.readAsDataURL(file);
        }
      };

      const handlePresetSelect = (bg) => {
        // Apply the preset, but we might also want to respect the user's override if they just clicked the toggle?
        // For simplicity, Presets enforce their default color, but user can change it AFTER.
        onSelect(bg);
        onClose();
      };

      const handleTextColorChange = (colorClass) => {
        // If we are just changing text color of the CURRENT background
        onSelect({ ...currentBg, textColor: colorClass });
        setSelectedTextColor(colorClass);
        // Don't close, let them see the selection
      };

      return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-3xl overflow-hidden flex flex-col max-h-[90vh]">
            <div className="p-4 border-b flex justify-between items-center bg-gray-50">
              <h3 className="font-bold text-lg text-gray-800 flex items-center gap-2"><Palette size={20} /> Appearance</h3>
              <button onClick={onClose} className="p-2 hover:bg-gray-200 rounded-full text-gray-500 transition-colors"><X size={20} /></button>
            </div>

            <div className="p-4 border-b bg-gray-50/50 flex flex-col gap-2">
              <label className="text-xs font-bold text-gray-500 uppercase tracking-wide">Text Color Over Background</label>
              <div className="flex gap-4">
                <button onClick={() => handleTextColorChange('text-slate-800')} className={`flex items-center gap-2 px-4 py-2 rounded-lg border transition-all ${currentBg.textColor === 'text-slate-800' ? 'bg-slate-800 text-white border-slate-800' : 'bg-white text-slate-800 border-gray-200 hover:border-gray-300'}`}>
                  <Moon size={16} /> Dark Text
                </button>
                <button onClick={() => handleTextColorChange('text-white')} className={`flex items-center gap-2 px-4 py-2 rounded-lg border transition-all ${currentBg.textColor === 'text-white' ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-slate-800 border-gray-200 hover:border-gray-300'}`}>
                  <Sun size={16} /> Light Text
                </button>
              </div>
            </div>

            <div className="p-6 overflow-y-auto custom-scrollbar">
              <label className="text-xs font-bold text-gray-500 uppercase tracking-wide mb-3 block">Background Image</label>
              <div className="grid grid-cols-2 sm:grid-cols-3 gap-4">
                {/* Upload Option */}
                <div
                  onClick={() => fileInputRef.current.click()}
                  className="aspect-video bg-gray-100 rounded-xl border-2 border-dashed border-gray-300 hover:border-blue-500 hover:bg-blue-50 cursor-pointer flex flex-col items-center justify-center gap-2 transition-all group"
                >
                  <div className="p-3 bg-white rounded-full shadow-sm group-hover:scale-110 transition-transform"><UploadCloud size={24} className="text-blue-500" /></div>
                  <span className="text-sm font-bold text-gray-500 group-hover:text-blue-600">Upload Image</span>
                  <input ref={fileInputRef} type="file" accept="image/*" className="hidden" onChange={handleFileChange} />
                </div>

                {/* Presets */}
                {BACKGROUNDS.map(bg => (
                  <div
                    key={bg.id}
                    onClick={() => handlePresetSelect(bg)}
                    className={`relative aspect-video rounded-xl overflow-hidden cursor-pointer shadow-sm hover:shadow-lg transition-all ring-2 ${currentBg.id === bg.id ? 'ring-blue-500 ring-offset-2' : 'ring-transparent hover:ring-gray-200'}`}
                  >
                    {bg.id === 'default' ? (
                      <div className={`w-full h-full ${bg.preview} flex items-center justify-center`}><span className="font-bold text-slate-500">Original</span></div>
                    ) : (
                      <img src={bg.src} alt={bg.name} className="w-full h-full object-cover" />
                    )}
                    <div className="absolute inset-x-0 bottom-0 bg-gradient-to-t from-black/60 to-transparent p-3 pt-8">
                      <span className="text-white font-medium text-sm">{bg.name}</span>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
      );
    };

    // School-themed emojis for the picker
    const SCHEDULE_EMOJIS = [
      'ðŸ“š', 'âœï¸', 'ðŸŽ¨', 'ðŸ”¬', 'ðŸŽµ', 'ðŸƒ', 'ðŸŽ', 'ðŸŒ', 'ðŸ§®', 'ðŸ“–',
      'ðŸ–¥ï¸', 'ðŸŽ­', 'ðŸ¤', 'ðŸ§˜', 'â°', 'ðŸ“', 'ðŸŽ¯', 'ðŸ§ª', 'ðŸ“', 'ðŸŽ¹',
      'ðŸ€', 'âš½', 'ðŸŒ±', 'ðŸ”­', 'ðŸ’¡'
    ];

    // --- SCHEDULE WIDGET ---
    const ScheduleWidget = ({ widget, updateData, onOpenSettings }) => {
      const { fontSize = 14 } = widget.data;
      const [dragIndex, setDragIndex] = useState(null);
      const [emojiPickerIndex, setEmojiPickerIndex] = useState(null);

      // Get today's day name
      const today = DAYS_OF_WEEK[new Date().getDay()];

      // Read schedule directly from localStorage for real-time sync
      const [scheduleData, setScheduleData] = useState(() => {
        const template = getScheduleTemplate();
        return template[today] || [];
      });

      // Refresh from localStorage when widget becomes visible or settings close
      useEffect(() => {
        const refreshFromStorage = () => {
          const template = getScheduleTemplate();
          setScheduleData(template[today] || []);
        };

        // Refresh periodically to catch Settings changes
        const interval = setInterval(refreshFromStorage, 1000);
        return () => clearInterval(interval);
      }, [today]);

      // Close emoji picker when clicking outside
      useEffect(() => {
        const handleClickOutside = () => setEmojiPickerIndex(null);
        if (emojiPickerIndex !== null) {
          document.addEventListener('click', handleClickOutside);
          return () => document.removeEventListener('click', handleClickOutside);
        }
      }, [emojiPickerIndex]);

      // Get current time for highlighting
      const now = new Date();
      const currentMinutes = now.getHours() * 60 + now.getMinutes();

      const formatTime = (time) => {
        if (!time) return '';
        const [h, m] = time.split(':').map(Number);
        const hour12 = h % 12 || 12;
        const ampm = h >= 12 ? 'PM' : 'AM';
        return `${hour12}:${m.toString().padStart(2, '0')} ${ampm}`;
      };

      const parseTimeToMinutes = (time) => {
        if (!time) return 0;
        const [h, m] = time.split(':').map(Number);
        return h * 60 + m;
      };

      const isCurrentItem = (item, index) => {
        const itemMinutes = parseTimeToMinutes(item.time);
        const nextItem = scheduleData[index + 1];
        const nextMinutes = nextItem ? parseTimeToMinutes(nextItem.time) : 24 * 60;
        return currentMinutes >= itemMinutes && currentMinutes < nextMinutes;
      };

      // Save to localStorage and update local state
      const saveScheduleData = (newItems) => {
        const template = getScheduleTemplate();
        template[today] = newItems;
        saveScheduleTemplate(template);
        setScheduleData(newItems);
      };

      const updateItem = (index, field, value) => {
        const newItems = [...scheduleData];
        newItems[index] = { ...newItems[index], [field]: value };
        saveScheduleData(newItems);
      };

      const addItem = () => {
        const newItem = { id: Date.now().toString(), time: '09:00', emoji: 'ðŸ“š', title: 'New Activity', description: '' };
        const newItems = [...scheduleData, newItem].sort((a, b) => parseTimeToMinutes(a.time) - parseTimeToMinutes(b.time));
        saveScheduleData(newItems);
      };

      const removeItem = (index) => {
        const newItems = scheduleData.filter((_, i) => i !== index);
        saveScheduleData(newItems);
      };

      const handleDragStart = (index) => { setDragIndex(index); };
      const handleDragOver = (e) => { e.preventDefault(); };
      const handleDrop = (targetIndex) => {
        if (dragIndex === null || dragIndex === targetIndex) return;
        const newItems = [...scheduleData];
        const [moved] = newItems.splice(dragIndex, 1);
        newItems.splice(targetIndex, 0, moved);
        saveScheduleData(newItems);
        setDragIndex(null);
      };

      const selectEmoji = (index, emoji) => {
        updateItem(index, 'emoji', emoji);
        setEmojiPickerIndex(null);
      };

      return (
        <div className="flex flex-col h-full bg-gradient-to-br from-indigo-50 to-purple-50">
          <div className="h-10 bg-white/80 backdrop-blur border-b flex items-center justify-between px-3 shrink-0">
            <h3 className="font-bold text-indigo-800 text-sm flex items-center gap-2"><Calendar size={16} /> {today}'s Schedule</h3>
            <div className="flex gap-1">
              <button onClick={addItem} className="p-1.5 text-indigo-600 hover:bg-indigo-100 rounded-lg transition-colors" title="Add activity"><Plus size={16} /></button>
              <button onClick={onOpenSettings} className="p-1.5 text-gray-400 hover:bg-gray-100 rounded-lg transition-colors" title="Schedule settings"><Settings size={16} /></button>
            </div>
          </div>

          <div className="flex-1 overflow-y-auto p-2 space-y-1 custom-scrollbar">
            {scheduleData.length === 0 ? (
              <div className="flex flex-col items-center justify-center h-full text-center p-4">
                <Calendar size={40} className="text-indigo-200 mb-3" />
                <p className="text-indigo-400 text-sm font-medium mb-2">No schedule items yet</p>
                <button onClick={addItem} className="px-3 py-1.5 bg-indigo-600 text-white text-xs font-bold rounded-lg hover:bg-indigo-700 flex items-center gap-1"><Plus size={14} /> Add Activity</button>
              </div>
            ) : (
              scheduleData.map((item, index) => {
                const isCurrent = isCurrentItem(item, index);
                return (
                  <div
                    key={item.id}
                    draggable
                    onDragStart={() => handleDragStart(index)}
                    onDragOver={handleDragOver}
                    onDrop={() => handleDrop(index)}
                    className={`relative group flex gap-2 p-2 rounded-lg border transition-all cursor-move ${isCurrent ? 'bg-indigo-100 border-indigo-400 ring-2 ring-indigo-300' : 'bg-white border-gray-200 hover:border-indigo-200'}`}
                  >
                    {isCurrent && <div className="absolute -left-1 top-1/2 -translate-y-1/2 w-2 h-2 bg-indigo-500 rounded-full animate-pulse" />}
                    <div className="flex flex-col items-center shrink-0 w-14">
                      <input
                        type="time"
                        value={item.time || '09:00'}
                        onChange={(e) => updateItem(index, 'time', e.target.value)}
                        className="w-full text-[10px] font-bold text-indigo-600 bg-transparent border-none text-center cursor-pointer"
                      />
                      <span className="text-[10px] text-gray-400">{formatTime(item.time)}</span>
                    </div>
                    <div className="relative flex items-center text-xl shrink-0">
                      <div
                        className="cursor-pointer hover:scale-110 transition-transform p-1 rounded hover:bg-indigo-100"
                        onClick={(e) => { e.stopPropagation(); setEmojiPickerIndex(emojiPickerIndex === index ? null : index); }}
                      >
                        {item.emoji || 'ðŸ“š'}
                      </div>
                      {/* Emoji Picker Popup */}
                      {emojiPickerIndex === index && (
                        <div
                          className="absolute left-0 top-full mt-1 z-50 bg-white rounded-xl shadow-xl border border-gray-200 p-2 w-48 max-h-40 overflow-y-auto custom-scrollbar"
                          onClick={(e) => e.stopPropagation()}
                        >
                          <div className="grid grid-cols-5 gap-1">
                            {SCHEDULE_EMOJIS.map((emoji, i) => (
                              <button
                                key={i}
                                onClick={() => selectEmoji(index, emoji)}
                                className={`text-xl p-1.5 rounded-lg hover:bg-indigo-100 transition-colors ${item.emoji === emoji ? 'bg-indigo-200 ring-2 ring-indigo-400' : ''}`}
                              >
                                {emoji}
                              </button>
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                    <div className="flex-1 min-w-0">
                      <input
                        type="text"
                        value={item.title || ''}
                        onChange={(e) => updateItem(index, 'title', e.target.value)}
                        className="w-full font-bold text-gray-800 bg-transparent border-none outline-none truncate"
                        style={{ fontSize: fontSize + 'px' }}
                        placeholder="Activity name"
                      />
                      <input
                        type="text"
                        value={item.description || ''}
                        onChange={(e) => updateItem(index, 'description', e.target.value)}
                        className="w-full text-xs text-gray-500 bg-transparent border-none outline-none truncate"
                        placeholder="Description (optional)"
                      />
                    </div>
                    <button onClick={() => removeItem(index)} className="p-1 text-red-400 hover:text-red-600 opacity-0 group-hover:opacity-100 transition-opacity self-center"><X size={14} /></button>
                  </div>
                );
              })
            )}
          </div>
        </div>
      );
    };


    // --- MISSING COMPONENTS (Restored) ---
    // (Onboarding now works with object roster)
    const OnboardingModal = ({ onComplete }) => {
      const [text, setText] = useState(DEFAULT_NAMES.join('\n'));
      const handleSave = () => {
        const names = text.split('\n').map(n => n.trim()).filter(n => n);
        if (names.length > 0) {
          const roster = names.map(n => ({ id: Math.random().toString(36).substr(2, 9), name: n, active: true }));
          saveRoster(roster);
        }
        onComplete();
      };
      return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-in fade-in duration-300">
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg flex flex-col overflow-hidden">
            <div className="p-6 bg-gradient-to-r from-blue-600 to-indigo-600 text-white">
              <h2 className="text-2xl font-bold mb-2">Welcome to HomeRoom! ðŸŽ</h2>
              <p className="opacity-90 text-sm">Let's set up your class roster. You can change this anytime.</p>
            </div>
            <div className="p-6">
              <label className="block text-sm font-bold text-gray-700 mb-2">Student Names (one per line)</label>
              <textarea
                value={text}
                onChange={e => setText(e.target.value)}
                className="w-full h-48 border-2 border-gray-200 rounded-xl p-4 text-sm focus:border-blue-500 focus:ring-4 focus:ring-blue-50 outline-none transition-all custom-scrollbar resize-none"
                placeholder="Paste names here..."
              />
            </div>
            <div className="p-4 border-t bg-gray-50 flex justify-end">
              <button
                onClick={handleSave}
                className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl shadow-lg shadow-blue-200 transition-all active:scale-95 flex items-center gap-2"
              >
                <Save size={18} /> Save & Get Started
              </button>
            </div>
          </div>
        </div>
      );
    };

    const SettingsModal = ({ onClose, onSave, downloadData, uploadData, roster, fileInputRef, initialTab = 'roster' }) => {
      const [activeTab, setActiveTab] = useState(initialTab);
      const [mode, setMode] = useState('list');
      const [localRoster, setLocalRoster] = useState(roster);
      const [bulkText, setBulkText] = useState(roster.map(s => s.name).join('\n'));

      // Feedback form state
      const [feedbackName, setFeedbackName] = useState('');
      const [feedbackEmail, setFeedbackEmail] = useState('');
      const [feedbackMessage, setFeedbackMessage] = useState('');

      const toggleActive = (id) => {
        setLocalRoster(prev => prev.map(s => s.id === id ? { ...s, active: !s.active } : s));
      };

      const handleBulkSave = () => {
        const lines = bulkText.split('\n').map(n => n.trim()).filter(n => n);
        const newRoster = lines.map(name => {
          const existing = roster.find(s => s.name === name);
          return existing ? existing : { id: Math.random().toString(36).substr(2, 9), name: name, active: true };
        });
        setLocalRoster(newRoster);
        setMode('list');
      };

      const handleSaveAll = () => {
        onSave(localRoster);
        onClose();
      };

      const handleFeedbackSubmit = () => {
        const subject = encodeURIComponent('HomeRoom Feedback');
        const body = encodeURIComponent(`Name: ${feedbackName}\nEmail: ${feedbackEmail}\n\nMessage:\n${feedbackMessage}`);
        window.location.href = `mailto:jeffhennigar@gmail.com?subject=${subject}&body=${body}`;
      };

      // Schedule template state
      const [scheduleTemplate, setScheduleTemplate] = useState(getScheduleTemplate());
      const [selectedDay, setSelectedDay] = useState('Monday');
      const [settingsEmojiPickerIndex, setSettingsEmojiPickerIndex] = useState(null);

      const addScheduleItem = (day) => {
        const newItem = { id: Date.now().toString(), time: '09:00', emoji: 'ðŸ“š', title: 'New Activity', description: '' };
        setScheduleTemplate(prev => ({ ...prev, [day]: [...(prev[day] || []), newItem] }));
      };

      const updateScheduleItem = (day, index, field, value) => {
        setScheduleTemplate(prev => {
          const items = [...(prev[day] || [])];
          items[index] = { ...items[index], [field]: value };
          return { ...prev, [day]: items };
        });
      };

      const removeScheduleItem = (day, index) => {
        setScheduleTemplate(prev => ({ ...prev, [day]: prev[day].filter((_, i) => i !== index) }));
      };

      const saveSchedule = () => {
        saveScheduleTemplate(scheduleTemplate);
      };

      const tabs = [
        { id: 'roster', label: 'Roster', icon: <List size={16} /> },
        { id: 'schedule', label: 'Schedule', icon: <Calendar size={16} /> },
        { id: 'data', label: 'Data', icon: <Download size={16} /> },
        { id: 'about', label: 'About', icon: <Info size={16} /> },
        { id: 'feedback', label: 'Feedback', icon: <Mail size={16} /> }
      ];

      return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
          <div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg flex flex-col max-h-[90vh]">
            {/* Header with Tabs */}
            <div className="border-b">
              <div className="p-4 flex justify-between items-center">
                <h3 className="font-bold text-gray-800 flex items-center gap-2"><Settings size={20} /> Settings</h3>
                <button onClick={onClose} className="p-2 hover:bg-gray-200 rounded-full text-gray-500"><X size={20} /></button>
              </div>
              <div className="flex px-2 pb-0">
                {tabs.map(tab => (
                  <button
                    key={tab.id}
                    onClick={() => setActiveTab(tab.id)}
                    className={`flex items-center gap-1 px-2.5 py-2 text-xs font-bold transition-all border-b-2 ${activeTab === tab.id ? 'text-blue-600 border-blue-600' : 'text-gray-500 border-transparent hover:text-gray-700'}`}
                  >
                    {tab.icon} {tab.label}
                  </button>
                ))}
              </div>
            </div>

            {/* Tab Content */}
            <div className="flex-1 overflow-y-auto custom-scrollbar">
              {/* ROSTER TAB */}
              {activeTab === 'roster' && (
                <>
                  {mode === 'list' && (
                    <div className="p-2 border-b bg-gray-50 flex justify-end">
                      <button onClick={() => { setBulkText(localRoster.map(s => s.name).join('\n')); setMode('bulk'); }} className="text-xs font-bold text-blue-600 hover:bg-blue-50 px-3 py-1.5 rounded-lg">Bulk Edit</button>
                    </div>
                  )}
                  {mode === 'list' ? (
                    <div className="p-4">
                      <div className="space-y-1">
                        {localRoster.map(s => (
                          <div key={s.id} onClick={() => toggleActive(s.id)} className={`flex items-center justify-between p-2 rounded cursor-pointer border ${s.active ? 'bg-white border-gray-100 hover:border-blue-300' : 'bg-gray-50 border-transparent opacity-60'}`}>
                            <div className="flex items-center gap-3">
                              <div className={`w-4 h-4 rounded border flex items-center justify-center ${s.active ? 'bg-blue-500 border-blue-500' : 'border-gray-400 bg-white'}`}>
                                {s.active && <Check size={12} className="text-white" />}
                              </div>
                              <span className={`font-medium ${s.active ? 'text-gray-900' : 'text-gray-500 line-through'}`}>{s.name}</span>
                            </div>
                          </div>
                        ))}
                        {localRoster.length === 0 && <div className="text-center text-gray-400 py-8">No students. Click Bulk Edit to add.</div>}
                      </div>
                    </div>
                  ) : (
                    <div className="p-4 flex flex-col" style={{ minHeight: '300px' }}>
                      <label className="text-xs font-bold text-gray-500 uppercase mb-2">Edit Names (One per line)</label>
                      <textarea
                        className="flex-1 border-2 border-gray-200 rounded-xl p-4 outline-none focus:border-blue-500 focus:ring-4 focus:ring-blue-50 transition-all custom-scrollbar resize-none font-medium text-slate-700"
                        autoFocus
                        value={bulkText}
                        onChange={e => setBulkText(e.target.value)}
                        style={{ minHeight: '200px' }}
                      />
                      <button onClick={handleBulkSave} className="mt-2 bg-blue-100 text-blue-700 font-bold py-2 rounded-lg hover:bg-blue-200">Update List</button>
                    </div>
                  )}
                </>
              )}

              {/* SCHEDULE TAB */}
              {activeTab === 'schedule' && (
                <div className="p-4">
                  <p className="text-gray-600 text-sm mb-4">Set up your weekly schedule template. Each day's activities will load automatically when you open the Schedule widget.</p>

                  {/* Day Selector */}
                  <div className="flex gap-1 mb-4 overflow-x-auto pb-2">
                    {['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].map(day => (
                      <button
                        key={day}
                        onClick={() => setSelectedDay(day)}
                        className={`px-3 py-1.5 text-xs font-bold rounded-lg transition-colors whitespace-nowrap ${selectedDay === day ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                      >
                        {day.slice(0, 3)}
                        {scheduleTemplate[day]?.length > 0 && <span className="ml-1 opacity-70">({scheduleTemplate[day].length})</span>}
                      </button>
                    ))}
                  </div>

                  {/* Activities for selected day */}
                  <div className="space-y-2 max-h-60 overflow-y-auto custom-scrollbar">
                    {(scheduleTemplate[selectedDay] || []).map((item, index) => (
                      <div key={item.id} className="flex gap-2 p-2 bg-gray-50 rounded-lg border border-gray-200">
                        <input
                          type="time"
                          value={item.time || '09:00'}
                          onChange={(e) => updateScheduleItem(selectedDay, index, 'time', e.target.value)}
                          className="w-20 text-xs font-mono bg-white border border-gray-200 rounded px-1 py-0.5"
                        />
                        <div className="relative">
                          <div
                            className="text-lg cursor-pointer hover:scale-110 transition-transform p-1 rounded hover:bg-gray-200"
                            onClick={() => setSettingsEmojiPickerIndex(settingsEmojiPickerIndex === index ? null : index)}
                          >
                            {item.emoji || 'ðŸ“š'}
                          </div>
                          {settingsEmojiPickerIndex === index && (
                            <div className="absolute left-0 top-full mt-1 z-50 bg-white rounded-xl shadow-xl border border-gray-200 p-2 w-48 max-h-40 overflow-y-auto custom-scrollbar">
                              <div className="grid grid-cols-5 gap-1">
                                {SCHEDULE_EMOJIS.map((emoji, i) => (
                                  <button
                                    key={i}
                                    onClick={() => { updateScheduleItem(selectedDay, index, 'emoji', emoji); setSettingsEmojiPickerIndex(null); }}
                                    className={`text-xl p-1.5 rounded-lg hover:bg-indigo-100 transition-colors ${item.emoji === emoji ? 'bg-indigo-200 ring-2 ring-indigo-400' : ''}`}
                                  >
                                    {emoji}
                                  </button>
                                ))}
                              </div>
                            </div>
                          )}
                        </div>
                        <div className="flex-1 min-w-0">
                          <input
                            type="text"
                            value={item.title || ''}
                            onChange={(e) => updateScheduleItem(selectedDay, index, 'title', e.target.value)}
                            className="w-full text-sm font-bold bg-transparent border-none outline-none"
                            placeholder="Activity name"
                          />
                          <input
                            type="text"
                            value={item.description || ''}
                            onChange={(e) => updateScheduleItem(selectedDay, index, 'description', e.target.value)}
                            className="w-full text-xs text-gray-500 bg-transparent border-none outline-none"
                            placeholder="Description (optional)"
                          />
                        </div>
                        <button onClick={() => removeScheduleItem(selectedDay, index)} className="p-1 text-red-400 hover:text-red-600 self-center"><X size={14} /></button>
                      </div>
                    ))}
                    {(scheduleTemplate[selectedDay] || []).length === 0 && (
                      <div className="text-center py-4 text-gray-400 text-sm">No activities for {selectedDay}</div>
                    )}
                  </div>

                  <div className="flex gap-2 mt-3">
                    <button onClick={() => addScheduleItem(selectedDay)} className="flex-1 py-2 bg-indigo-100 text-indigo-700 font-bold text-sm rounded-lg hover:bg-indigo-200 flex items-center justify-center gap-1">
                      <Plus size={16} /> Add Activity
                    </button>
                  </div>

                  <button onClick={saveSchedule} className="w-full mt-4 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-xl flex items-center justify-center gap-2">
                    <Save size={18} /> Save Schedule Template
                  </button>
                </div>
              )}

              {/* ABOUT TAB */}
              {activeTab === 'about' && (
                <div className="p-6">
                  <div className="flex flex-col items-center mb-6">
                    <img src="effortless_edtech_logo.png" alt="Effortless EdTech" className="w-24 h-24 rounded-full bg-gradient-to-br from-teal-400 to-orange-400 p-1 shadow-lg mb-3" />
                    <h2 className="text-lg font-bold text-gray-800">HomeRoom</h2>
                    <p className="text-gray-500 text-sm text-center">A classroom management tool by <span className="font-semibold text-teal-600">Effortless EdTech</span></p>
                  </div>
                  <div className="space-y-2">
                    <a href="mailto:jeffhennigar@gmail.com" className="flex items-center gap-3 p-3 bg-gray-50 hover:bg-blue-50 rounded-xl transition-colors group">
                      <div className="p-2 bg-blue-100 rounded-lg text-blue-600"><Mail size={16} /></div>
                      <div><div className="text-xs text-gray-400">Contact</div><div className="text-sm font-semibold text-gray-700 group-hover:text-blue-600">jeffhennigar@gmail.com</div></div>
                    </a>
                    <a href="https://www.teacherspayteachers.com/store/effortless-edtech" target="_blank" rel="noopener noreferrer" className="flex items-center gap-3 p-3 bg-gray-50 hover:bg-green-50 rounded-xl transition-colors group">
                      <div className="p-2 bg-green-100 rounded-lg text-green-600"><ExternalLink size={16} /></div>
                      <div><div className="text-xs text-gray-400">Teachers Pay Teachers</div><div className="text-sm font-semibold text-gray-700 group-hover:text-green-600">Visit Store â†’</div></div>
                    </a>
                    <a href="https://www.etsy.com/shop/EffortlessEdtech" target="_blank" rel="noopener noreferrer" className="flex items-center gap-3 p-3 bg-gray-50 hover:bg-orange-50 rounded-xl transition-colors group">
                      <div className="p-2 bg-orange-100 rounded-lg text-orange-600"><ExternalLink size={16} /></div>
                      <div><div className="text-xs text-gray-400">Etsy Shop</div><div className="text-sm font-semibold text-gray-700 group-hover:text-orange-600">Visit Store â†’</div></div>
                    </a>
                  </div>
                </div>
              )}

              {/* DATA TAB */}
              {activeTab === 'data' && (
                <div className="p-6">
                  <p className="text-gray-600 text-sm mb-6">Export your data to save a backup, or import a previous backup to restore your settings, roster, and widgets.</p>
                  <div className="space-y-3">
                    <button onClick={downloadData} className="w-full flex items-center gap-3 p-4 bg-green-50 hover:bg-green-100 rounded-xl transition-colors group border border-green-200">
                      <div className="p-3 bg-green-500 rounded-xl text-white"><Download size={20} /></div>
                      <div className="text-left">
                        <div className="font-bold text-gray-800">Export Data</div>
                        <div className="text-xs text-gray-500">Download roster, widgets, and settings</div>
                      </div>
                    </button>
                    <button onClick={() => fileInputRef.current.click()} className="w-full flex items-center gap-3 p-4 bg-blue-50 hover:bg-blue-100 rounded-xl transition-colors group border border-blue-200">
                      <div className="p-3 bg-blue-500 rounded-xl text-white"><Upload size={20} /></div>
                      <div className="text-left">
                        <div className="font-bold text-gray-800">Import Data</div>
                        <div className="text-xs text-gray-500">Restore from a backup file</div>
                      </div>
                    </button>
                  </div>
                </div>
              )}

              {/* FEEDBACK TAB */}
              {activeTab === 'feedback' && (
                <div className="p-6">
                  <p className="text-gray-600 text-sm mb-4">Have feedback or questions? Fill out this form and we'll get back to you!</p>
                  <div className="space-y-3">
                    <div>
                      <label className="text-xs font-bold text-gray-500 uppercase mb-1 block">Your Name</label>
                      <input type="text" value={feedbackName} onChange={e => setFeedbackName(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-blue-500 transition-colors" placeholder="Your name" />
                    </div>
                    <div>
                      <label className="text-xs font-bold text-gray-500 uppercase mb-1 block">Email</label>
                      <input type="email" value={feedbackEmail} onChange={e => setFeedbackEmail(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-blue-500 transition-colors" placeholder="you@school.edu" />
                    </div>
                    <div>
                      <label className="text-xs font-bold text-gray-500 uppercase mb-1 block">Message</label>
                      <textarea value={feedbackMessage} onChange={e => setFeedbackMessage(e.target.value)} className="w-full border-2 border-gray-200 rounded-xl p-3 outline-none focus:border-blue-500 transition-colors resize-none" rows={4} placeholder="Your feedback or question..." />
                    </div>
                    <button onClick={handleFeedbackSubmit} disabled={!feedbackMessage.trim()} className="w-full py-3 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-300 text-white font-bold rounded-xl transition-colors flex items-center justify-center gap-2">
                      <Mail size={18} /> Send Feedback
                    </button>
                  </div>
                </div>
              )}
            </div>

            {/* Footer - only show save for roster tab */}
            {activeTab === 'roster' && (
              <div className="p-4 border-t bg-gray-50 flex justify-end gap-2">
                <button onClick={onClose} className="px-4 py-2 text-slate-500 font-bold hover:bg-slate-100 rounded-lg transition-colors">Cancel</button>
                <button onClick={handleSaveAll} className="px-6 py-2 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow transition-all active:scale-95 flex items-center gap-2">
                  <Save size={18} /> Save
                </button>
              </div>
            )}
          </div >
        </div >
      );
    };





    const App = () => {
      const [roster, setRoster] = useState(getRoster());

      const [slides, setSlides] = useState(() => {
        try { return JSON.parse(localStorage.getItem(WIDGETS_STORAGE_KEY)) || [[]]; } catch (e) { return [[]]; }
      });
      const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
      const [selectedId, setSelectedId] = useState(null);
      const [maxZIndex, setMaxZIndex] = useState(10);
      const [currentTime, setCurrentTime] = useState(new Date().toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' }));
      const [isDockMinimized, setIsDockMinimized] = useState(false);
      const [isDockEditing, setIsDockEditing] = useState(false);
      const [dockOrder, setDockOrder] = useState(() => {
        const stored = getDockOrder();
        if (Array.isArray(stored)) {
          const mainDefaults = ['TIMER', 'GROUP_MAKER', 'SEAT_PICKER', 'SCHEDULE', 'TEXT', 'RANDOMIZER'];
          const drawerDefaults = ['TRAFFIC', 'QR', 'WEBCAM', 'DICE', 'VOTE', 'WHITEBOARD'];
          const allKnown = [...mainDefaults, ...drawerDefaults];
          const extras = stored.filter(id => !allKnown.includes(id));
          return {
            main: mainDefaults.filter(id => stored.includes(id)),
            drawer: [...drawerDefaults.filter(id => stored.includes(id)), ...extras]
          };
        }
        return stored;
      });

      const [isDockLocked, setIsDockLocked] = useState(true);
      const [showMoreDrawer, setShowMoreDrawer] = useState(false);
      const drawerRef = useRef(null);

      useEffect(() => {
        saveDockOrder(dockOrder);
      }, [dockOrder]);

      useEffect(() => {
        const handleClickOutside = (event) => {
          if (drawerRef.current && !drawerRef.current.contains(event.target)) {
            setShowMoreDrawer(false);
          }
        };
        if (showMoreDrawer) document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
      }, [showMoreDrawer]);

      const handleDockDrop = (e, targetLocation) => {
        e.preventDefault();
        const widgetType = e.dataTransfer.getData('widgetType');
        if (!widgetType) return;

        let sourceLocation = 'main';
        if (dockOrder.drawer.includes(widgetType)) sourceLocation = 'drawer';
        else if (!dockOrder.main.includes(widgetType)) return;

        if (sourceLocation === targetLocation) {
          return;
        }

        setDockOrder(prev => {
          const newMain = prev.main.filter(id => id !== widgetType);
          const newDrawer = prev.drawer.filter(id => id !== widgetType);

          if (targetLocation === 'main') {
            return { main: [...newMain, widgetType], drawer: newDrawer };
          } else {
            return { main: newMain, drawer: [...newDrawer, widgetType] };
          }
        });
      };


      const [showOnboarding, setShowOnboarding] = useState(false);
      const [showSettingsModal, setShowSettingsModal] = useState(false);
      const [settingsInitialTab, setSettingsInitialTab] = useState('roster');

      // New Background State
      const [background, setBackground] = useState(getBackground());
      const [showBgPicker, setShowBgPicker] = useState(false);

      // --- PERSISTENCE & DATA ---
      useEffect(() => {
        const t = setTimeout(() => { localStorage.setItem(WIDGETS_STORAGE_KEY, JSON.stringify(slides)); saveRoster(roster); }, 1000);
        return () => clearTimeout(t);
      }, [slides, roster]);

      const fileInputRef = useRef(null);
      const downloadData = () => {
        const data = { roster: getRoster(), dock: getDockOrder(), widgets: slides, background, timestamp: Date.now() };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `homeroom-${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
      };

      const uploadData = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const d = JSON.parse(ev.target.result);
            if (d.roster) saveRoster(d.roster);
            if (d.dock) saveDockOrder(d.dock);
            if (d.background) saveBackground(d.background);
            if (d.widgets) setSlides(d.widgets);
            if (d.dock) setDockOrder(d.dock);
            if (d.background) setBackground(d.background);
            alert("Import successful!");
          } catch (err) { alert("Import failed."); }
        };
        reader.readAsText(file);
      };

      // ... existing effects/callbacks ...
      const widgets = slides[currentSlideIndex];
      const setWidgets = useCallback((updater) => { setSlides(prev => { const newS = [...prev]; newS[currentSlideIndex] = updater(newS[currentSlideIndex]); return newS; }); }, [currentSlideIndex]);
      const currentDate = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
      useEffect(() => { const timer = setInterval(() => { setCurrentTime(new Date().toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })); }, 1000 * 60); return () => clearInterval(timer); }, []);
      useEffect(() => { if (!hasRoster()) setShowOnboarding(true); }, []);

      const handleBgSelect = (newBg) => {
        setBackground(newBg);
        saveBackground(newBg);
      };

      // ... (addWidget, removeWidget, updateWidgetLayout, updateWidgetData, bringToFront, nextSlide, prevSlide, saveDock, handleDockDrop, renderWidgetContent SAME AS PREVIOUS)
      // Including minimal versions for functionality
      const addWidget = (type) => { if (isDockEditing) return; const id = Date.now().toString(); const size = WIDGET_SIZES[type]; const position = { x: (window.innerWidth / 2) - (size.width / 2) + (Math.random() * 40 - 20), y: (window.innerHeight / 2) - (size.height / 2) + (Math.random() * 40 - 20) }; let data = { fontSize: 16 }; if (type === 'TIMER') data = { ...data, timeLeft: 120, isRunning: false }; if (type === 'RANDOMIZER') data = { ...data, students: getInitialStudents(), currentName: null, isAnimating: false }; if (type === 'GROUP_MAKER') data = { ...data, students: getInitialStudents(), groupCount: 4, groups: [] }; if (type === 'SEAT_PICKER') { const savedDesks = getSeatLayout(); if (savedDesks && savedDesks.length > 0) { data = { ...data, desks: savedDesks, isEditing: false }; } else { const initialStudents = getInitialStudents(); const initialDesks = initialStudents.slice(0, 8).map((s, i) => ({ id: `desk-${i}`, x: 50 + (i % 4) * 120, y: 50 + Math.floor(i / 4) * 100, student: s.name, color: 'blue', type: 'student', rotation: 0 })); data = { ...data, desks: initialDesks, isEditing: false }; } } if (type === 'TEXT') data = { ...data, content: '' }; if (type === 'WEBCAM') data = { ...data, isMirrored: true, isActive: true }; if (type === 'DICE') data = { ...data, sides: 6, diceCount: 1, results: [1], isRolling: false }; if (type === 'TRAFFIC') data = { ...data, activeLight: null }; if (type === 'QR') data = { ...data, url: '' }; if (type === 'VOTE') data = { ...data, question: 'Class Poll', options: [{ id: 1, text: 'Yes', count: 0 }, { id: 2, text: 'No', count: 0 }] }; if (type === 'WHITEBOARD') data = { ...data, lines: [], color: '#000000', size: 5, tool: 'pen' }; if (type === 'SCHEDULE') { const template = getScheduleTemplate(); const today = DAYS_OF_WEEK[new Date().getDay()]; data = { ...data, items: template[today] || [] }; } const newWidget = { id, type, position, size, zIndex: maxZIndex + 1, data }; setWidgets(prev => [...prev, newWidget]); setMaxZIndex(prev => prev + 1); setSelectedId(id); };
      const removeWidget = (id) => { const widget = widgets.find(w => w.id === id); if (widget && widget.type === 'SEAT_PICKER' && widget.data.desks) { saveSeatLayout(widget.data.desks); } setWidgets(prev => prev.filter(w => w.id !== id)); if (selectedId === id) setSelectedId(null); };
      const updateWidgetLayout = useCallback((id, newPos, newSize) => { setWidgets(prev => prev.map(w => w.id === id ? { ...w, position: newPos, size: newSize } : w)); }, [setWidgets]);
      const updateWidgetData = useCallback((id, updates) => { setWidgets(prev => prev.map(w => w.id === id ? { ...w, data: { ...w.data, ...updates } } : w)); }, [setWidgets]);
      const bringToFront = (id) => { setSelectedId(id); setMaxZIndex(prev => prev + 1); setWidgets(prev => prev.map(w => w.id === id ? { ...w, zIndex: maxZIndex + 1 } : w)); };
      const nextSlide = () => { if (currentSlideIndex === slides.length - 1) { setSlides(prev => [...prev, []]); } setCurrentSlideIndex(prev => prev + 1); setSelectedId(null); };
      const prevSlide = () => { if (currentSlideIndex > 0) { setCurrentSlideIndex(prev => prev - 1); setSelectedId(null); } };
      // Removed legacy saveDock/handleDockDrop
      const renderDockItem = (id, location) => {
        const info = DOCK_LABELS[id];
        if (!info) return null;
        return (
          <div
            key={id}
            draggable={!isDockLocked}
            onDragStart={(e) => {
              e.dataTransfer.setData('widgetType', id);
              if (location === 'drawer') setShowMoreDrawer(false);
            }}
            onClick={() => {
              const widget = {
                id: Date.now().toString(),
                type: id,
                x: 100 + Math.random() * 50,
                y: 100 + Math.random() * 50,
                width: WIDGET_SIZES[id].width,
                height: WIDGET_SIZES[id].height,
                zIndex: maxZIndex + 1,
                data: { fontSize: 16 } // Basic Init
              };
              // Specific Init Logic (Duplicated from addWidget for now, or just call addWidget? addWidget uses isDockEditing check which might be undesirable here? No, addWidget is fine)
              // Actually, renderDockItem's onClick used `setWidgets` directly in my previous snippet? 
              // Let's just call addWidget(id) to keep it DRY and safe.
              addWidget(id);
              if (location === 'drawer') setShowMoreDrawer(false);
            }}
            className={`flex flex-col items-center gap-1 p-2 rounded-xl transition-all cursor-pointer group relative
              ${!isDockLocked ? 'hover:bg-blue-50 hover:scale-105 active:scale-95 cursor-grab active:cursor-grabbing border-2 border-dashed border-blue-300' : 'hover:bg-white/50 hover:scale-110 active:scale-95'}`}
            title={!isDockLocked ? "Drag to reorder" : info.label}
          >
            {!isDockLocked && <div className="absolute -top-1 -right-1 bg-blue-500 text-white rounded-full p-0.5 shadow-sm"><GripVertical size={10} /></div>}
            <div className={`p-2 rounded-xl text-slate-600 transition-colors ${!isDockLocked ? 'bg-blue-100' : 'bg-white/80 group-hover:bg-white group-hover:text-blue-600 shadow-sm'}`}>
              {info.icon}
            </div>
            <span className="text-[10px] font-bold text-slate-500 group-hover:text-slate-700">{info.label}</span>
          </div>
        );
      };

      const renderWidgetContent = (widget) => { const props = { widget, updateData: updateWidgetData, roster }; switch (widget.type) { case 'TIMER': return <TimerWidget {...props} />; case 'RANDOMIZER': return <RandomizerWidget {...props} />; case 'GROUP_MAKER': return <GroupMakerWidget {...props} />; case 'SEAT_PICKER': return <SeatPickerWidget {...props} />; case 'TEXT': return <TextWidget {...props} />; case 'WEBCAM': return <WebcamWidget {...props} />; case 'DICE': return <DiceWidget {...props} />; case 'TRAFFIC': return <TrafficLightWidget {...props} />; case 'QR': return <QRCodeWidget {...props} />; case 'VOTE': return <VoteWidget {...props} />; case 'WHITEBOARD': return <WhiteboardWidget {...props} />; case 'SCHEDULE': return <ScheduleWidget {...props} onOpenSettings={() => { setSettingsInitialTab('schedule'); setShowSettingsModal(true); }} />; default: return null; } };

      return (
        <div className="w-screen h-screen overflow-hidden relative" style={{
          backgroundColor: '#dbeafe', // fallback
          backgroundImage: background && background.id !== 'default' ? `url(${background.src})` : 'none',
          backgroundSize: 'cover',
          backgroundPosition: 'center'
        }}>
          {/* Modals */}
          {showOnboarding && <OnboardingModal onComplete={() => setShowOnboarding(false)} />}
          {showSettingsModal && <SettingsModal
            roster={roster}
            onClose={() => { setShowSettingsModal(false); setSettingsInitialTab('roster'); }}
            onSave={(newRoster) => { saveRoster(newRoster); setRoster(newRoster); }}
            downloadData={downloadData}
            uploadData={uploadData}
            fileInputRef={fileInputRef}
            initialTab={settingsInitialTab}
          />}
          {showBgPicker && <BackgroundPicker currentBg={background} onSelect={handleBgSelect} onClose={() => setShowBgPicker(false)} />}
          <input ref={fileInputRef} type="file" accept=".json" className="hidden" onChange={uploadData} />

          {/* Default Geometric Background Layer */}
          {(!background || background.id === 'default') && (
            <div className="absolute inset-0 pointer-events-none z-0">
              <svg className="w-full h-full" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="gradOrange" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style={{ stopColor: "#fb923c", stopOpacity: 1 }} /><stop offset="100%" style={{ stopColor: "#ea580c", stopOpacity: 1 }} /></linearGradient><linearGradient id="gradBlue" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style={{ stopColor: "#3b82f6", stopOpacity: 1 }} /><stop offset="100%" style={{ stopColor: "#60a5fa", stopOpacity: 1 }} /></linearGradient></defs><rect width="100%" height="100%" fill="#dbeafe" /><path d="M1920 0V900C1400 900 1000 400 500 0H1920Z" fill="url(#gradOrange)" opacity="0.9" /><path d="M1920 0V700C1600 700 1300 300 900 0H1920Z" fill="#fed7aa" opacity="0.5" /><path d="M0 1080V300C500 300 900 800 1600 1080H0Z" fill="url(#gradBlue)" opacity="0.9" /><path d="M0 1080V500C300 500 700 900 1200 1080H0Z" fill="#93c5fd" opacity="0.5" /></svg>
            </div>
          )}

          {/* Dark Overlay for better contrast on images */}
          {background && background.id !== 'default' && <div className="absolute inset-0 bg-black/20 z-0 pointer-events-none" />}

          {/* Top Info Bar - Clickable for About - CHANGED Z-INDEX TO 1 TO BE BELOW WIDGETS */}
          <div onClick={() => setShowSettingsModal(true)} className={`absolute top-10 left-12 z-1 cursor-pointer select-none transition-colors duration-300 hover:opacity-80 ${background.textColor || 'text-slate-800'}`}>
            <div className="flex items-center gap-1.5 mb-1 opacity-80"><div className={`px-1.5 py-0.5 rounded text-[10px] font-black tracking-tighter shadow-md ${background.textColor === 'text-white' ? 'bg-white text-slate-900' : 'bg-slate-800 text-white'}`}>HR</div><div className="text-xs font-bold uppercase tracking-widest">HomeRoom</div></div>
            <div className={`text-8xl font-bold tracking-tight ${background.textColor === 'text-white' ? 'drop-shadow-lg' : 'drop-shadow-sm'}`}>{currentTime}</div>
            <div className={`text-3xl font-medium mt-2 opacity-90 ${background.textColor === 'text-white' ? 'drop-shadow-md' : ''}`}>{currentDate}</div>
          </div>

          {/* Top Right Controls */}
          <div className="absolute top-8 right-8 z-50 flex gap-2">
            <button onClick={() => setShowBgPicker(true)} className="p-3 bg-white/80 backdrop-blur-md hover:bg-white text-slate-600 rounded-full shadow-lg border border-white/50 transition-all active:scale-95 group" title="Appearance">
              <ImageIcon size={24} className="group-hover:text-purple-600" />
            </button>
          </div>

          {/* Widgets Area - UPDATED Z-INDEX TO 30 TO BE ABOVE CLOCK (z-20) */}
          <div className="absolute inset-0 z-30">{widgets.map(w => (<DraggableResizable key={w.id} id={w.id} position={w.position} size={w.size} zIndex={w.zIndex} isSelected={selectedId === w.id} onSelect={bringToFront} onUpdate={updateWidgetLayout} onRemove={removeWidget} onFontSizeChange={(d) => updateWidgetData(w.id, { fontSize: Math.max(8, (w.data.fontSize || 16) + d) })}>{renderWidgetContent(w)}</DraggableResizable>))}</div>

          {/* Slide Controls */}
          <div className="absolute bottom-6 right-8 z-50 flex items-center pointer-events-none"><div className="pointer-events-auto flex items-center gap-0.5 bg-white/80 backdrop-blur-xl rounded-2xl shadow-xl p-1 border border-white/60 ring-1 ring-black/5"><button onClick={prevSlide} disabled={currentSlideIndex === 0} className="p-1.5 hover:bg-blue-50 rounded-xl text-gray-500 hover:text-blue-600 transition-all duration-200 disabled:opacity-20 group active:scale-95"><ChevronLeft size={20} /></button><div className="px-2 flex items-center justify-center min-w-[35px]"><span className="text-[10px] font-bold text-blue-600 leading-none">{currentSlideIndex + 1} / {slides.length}</span></div><button onClick={nextSlide} className="p-1.5 hover:bg-blue-50 rounded-xl text-gray-500 hover:text-blue-600 transition-all duration-200 group active:scale-95 flex items-center justify-center">{currentSlideIndex === slides.length - 1 ? <Plus size={20} /> : <ChevronRight size={20} />}</button></div></div>

          {/* Dock */}
          <div className="absolute bottom-6 left-0 right-0 z-50 flex flex-col items-center justify-end pointer-events-none">
            <div className={`max-w-6xl mx-4 mb-1 transition-all duration-300 ease-in-out origin-bottom pointer-events-auto ${isDockMinimized ? 'translate-y-20 opacity-0 scale-95 pointer-events-none' : 'translate-y-0 opacity-100 scale-100'}`}>
              <div className={`flex items-center bg-white/80 backdrop-blur-xl rounded-2xl shadow-xl p-2 border border-white/60 ring-1 ring-black/5`}>



                {/* MAIN DOCK */}
                <div
                  className={`flex gap-2 transition-all duration-300 ease-in-out ${!isDockLocked ? 'bg-blue-50/50 p-2 rounded-2xl border-2 border-dashed border-blue-200 min-w-[200px]' : ''}`}
                  onDragOver={(e) => { e.preventDefault(); e.currentTarget.classList.add('bg-blue-100'); }}
                  onDragLeave={(e) => e.currentTarget.classList.remove('bg-blue-100')}
                  onDrop={(e) => {
                    e.currentTarget.classList.remove('bg-blue-100');
                    handleDockDrop(e, 'main');
                  }}
                >
                  {dockOrder.main.map((id) => renderDockItem(id, 'main'))}
                </div>

                <div className="w-px h-8 bg-slate-300 mx-2" />

                {/* MORE DRAWER BUTTON */}
                <div className="relative" ref={drawerRef}>
                  <button
                    onClick={() => setShowMoreDrawer(!showMoreDrawer)}
                    className={`flex flex-col items-center gap-1 p-2 rounded-xl transition-all cursor-pointer group
                            ${showMoreDrawer ? 'bg-indigo-100' : 'hover:bg-white/50'}
                            ${!isDockLocked && dockOrder.drawer.length > 0 ? 'border-2 border-dashed border-indigo-300 bg-indigo-50' : ''}
                        `}
                    onDragOver={(e) => {
                      if (!isDockLocked) {
                        e.preventDefault();
                        setShowMoreDrawer(true); // Auto open on hover drag
                      }
                    }}
                  >
                    <div className={`p-2 rounded-xl text-indigo-600 transition-colors ${showMoreDrawer ? 'bg-indigo-200 text-indigo-800' : 'bg-indigo-50 group-hover:bg-indigo-100 group-hover:text-indigo-700 shadow-sm'}`}>
                      {showMoreDrawer ? <ChevronDown size={24} /> : <MoreHorizontal size={24} />}
                    </div>
                    <span className="text-[10px] font-bold text-indigo-500 group-hover:text-indigo-700">More</span>
                  </button>

                  {/* DRAWER POPUP */}
                  {showMoreDrawer && (
                    <div
                      className="absolute bottom-full right-0 mb-4 bg-white/90 backdrop-blur-xl border border-white/50 p-4 rounded-2xl shadow-2xl flex flex-wrap gap-2 w-64 z-50 animate-in slide-in-from-bottom-2 fade-in duration-200"
                      onDragOver={(e) => { e.preventDefault(); e.currentTarget.classList.add('bg-indigo-50'); }}
                      onDragLeave={(e) => e.currentTarget.classList.remove('bg-indigo-50')}
                      onDrop={(e) => {
                        e.currentTarget.classList.remove('bg-indigo-50');
                        handleDockDrop(e, 'drawer');
                      }}
                    >
                      <div className="w-full text-[10px] font-bold text-slate-400 uppercase tracking-widest mb-1 border-b pb-1">Additional Tools</div>
                      {dockOrder.drawer.length > 0 ? (
                        dockOrder.drawer.map((id) => renderDockItem(id, 'drawer'))
                      ) : (
                        <div className="w-full text-center py-4 text-xs text-gray-400 italic">
                          {isDockLocked ? "No tools here." : "Drag tools here to hide them."}
                        </div>
                      )}
                    </div>
                  )}
                </div>

                <div className="w-px h-8 bg-slate-300 mx-2" />

                <button
                  onClick={() => setIsDockLocked(!isDockLocked)}
                  className={`p-3 rounded-full transition-all ${!isDockLocked ? 'bg-blue-100 text-blue-600 shadow-inner' : 'hover:bg-slate-100 text-slate-400 hover:text-slate-600'}`}
                  title={isDockLocked ? "Unlock Dock to Rearrange" : "Lock Dock"}
                >
                  {isDockLocked ? <Lock size={16} /> : <Unlock size={16} />}
                </button>
              </div>
            </div>
            <div className="pointer-events-auto transition-all duration-300 z-50"><button onClick={() => setIsDockMinimized(!isDockMinimized)} className="bg-white/90 backdrop-blur-md hover:bg-white text-slate-500 hover:text-blue-600 p-1.5 rounded-full shadow-lg border border-white/50 transition-all active:scale-95">{isDockMinimized ? <ChevronUp size={22} /> : <ChevronDown size={22} />}</button></div>
          </div>
        </div>
      );
    };

    const ToolBtn = ({ icon, label, onClick, isEditing, index, moveTool }) => { const handleDragStart = (e) => { if (!isEditing) return; e.dataTransfer.setData('text/plain', index); e.dataTransfer.effectAllowed = 'move'; }; const handleDragOver = (e) => { if (!isEditing) return; e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }; const handleDrop = (e) => { if (!isEditing || !moveTool) return; e.preventDefault(); moveTool(e, index); }; return <button onClick={onClick} draggable={isEditing} onDragStart={handleDragStart} onDragOver={handleDragOver} onDrop={handleDrop} className={`flex flex-col items-center justify-center min-w-[55px] px-1.5 py-2 rounded-xl group transition-all duration-200 active:scale-95 ${isEditing ? 'cursor-move animate-wobble bg-blue-100/50 hover:bg-blue-200 border border-blue-200' : 'hover:bg-blue-50'}`}><div className={`text-gray-500 group-hover:text-blue-600 mb-0.5 transition-colors p-1.5 bg-transparent group-hover:bg-white rounded-full shadow-none group-hover:shadow-sm ${isEditing ? 'text-blue-500' : ''}`}>{React.cloneElement(icon, { size: 20 })}</div><span className={`text-[9px] font-bold uppercase tracking-wide ${isEditing ? 'text-blue-600' : 'text-gray-400 group-hover:text-blue-600'}`}>{label}</span></button>; };

    const root = createRoot(document.getElementById('root')); root.render(<App />);
  </script>
</body>

</html>